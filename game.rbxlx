<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="Lighting" referent="1">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0.415686</R>
        <G>0.415686</G>
        <B>0.415686</B>
      </Color3>
      <float name="Brightness">2</float>
      <float name="GeographicLatitude">-44.283</float>
      <bool name="GlobalShadows">true</bool>
      <Color3 name="OutdoorAmbient">
        <R>0.976471</R>
        <G>0.976471</G>
        <B>0.976471</B>
      </Color3>
      <float name="ShadowSoftness">0</float>
      <token name="Technology">4</token>
      <string name="TimeOfDay">00:19:27</string>
    </Properties>
    <Item class="Atmosphere" referent="2">
      <Properties>
        <string name="Name">Atmosphere</string>
        <Color3 name="Color">
          <R>0.780392</R>
          <G>0.666667</G>
          <B>0.419608</B>
        </Color3>
        <Color3 name="Decay">
          <R>0.360784</R>
          <G>0.235294</G>
          <B>0.0509804</B>
        </Color3>
        <float name="Density">0.386</float>
      </Properties>
    </Item>
    <Item class="BloomEffect" referent="3">
      <Properties>
        <string name="Name">Bloom</string>
        <float name="Intensity">2.5</float>
        <float name="Size">25</float>
        <float name="Threshold">1.8</float>
      </Properties>
    </Item>
    <Item class="BlurEffect" referent="4">
      <Properties>
        <string name="Name">Blur</string>
        <float name="Size">2</float>
      </Properties>
    </Item>
    <Item class="ColorCorrectionEffect" referent="5">
      <Properties>
        <string name="Name">ColorCorrection</string>
        <float name="Saturation">0</float>
      </Properties>
    </Item>
    <Item class="Sky" referent="6">
      <Properties>
        <string name="Name">Sky</string>
        <float name="MoonAngularSize">11</float>
        <Content name="MoonTextureId">
          <url>rbxasset://sky/moon.jpg</url>
        </Content>
        <Content name="SkyboxBk">
          <url>http://www.roblox.com/asset/?id=150335574</url>
        </Content>
        <Content name="SkyboxDn">
          <url>http://www.roblox.com/asset/?id=150335585</url>
        </Content>
        <Content name="SkyboxFt">
          <url>http://www.roblox.com/asset/?id=150335628</url>
        </Content>
        <Content name="SkyboxLf">
          <url>http://www.roblox.com/asset/?id=150335620</url>
        </Content>
        <Content name="SkyboxRt">
          <url>http://www.roblox.com/asset/?id=150335610</url>
        </Content>
        <Content name="SkyboxUp">
          <url>http://www.roblox.com/asset/?id=150335642</url>
        </Content>
        <int name="StarCount">1334</int>
        <float name="SunAngularSize">21</float>
        <Content name="SunTextureId">
          <url>rbxasset://sky/sun.jpg</url>
        </Content>
      </Properties>
    </Item>
    <Item class="SunRaysEffect" referent="7">
      <Properties>
        <string name="Name">SunRays</string>
        <float name="Intensity">0.085</float>
        <float name="Spread">0.11</float>
      </Properties>
    </Item>
  </Item>
  <Item class="ReplicatedStorage" referent="8">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="9">
      <Properties>
        <string name="Name">TS</string>
      </Properties>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">RuntimeTsPort</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local stack = {}
local function newNode(state)
	if state == nil then
		state = {}
	end
	return {}
end
local function destroyNode(node)
	if node.instance ~= nil then
		node.instance:Destroy()
	end
	for _, effect in node.effects do
		if effect.destructor ~= nil then
			effect.destructor()
		end
	end
	for _, child in node.children do
		destroyNode(child)
	end
end
local function newStackFrame(node)
	return {
		node = node,
	}
end
local function scope(level, scopeKey, fn, ...)
	local args = { ... }
	local parentFrame = stack[#stack - 1 + 1]
	local parentNode = parentFrame.node
	local file = debug.info(1 + level, "s")
	local line = debug.info(1 + level, "l")
	local _fn = string
	local _exp = scopeKey
	local _condition = tostring(parentFrame.discriminator)
	if _condition == nil then
		_condition = ""
	end
	local baseKey = _fn.format("%s:%s:%s%d", _exp, _condition, file, line)
	local _result = parentFrame.childCounts
	if _result ~= nil then
		local _result_1 = parentFrame.childCounts
		if _result_1 ~= nil then
			_result_1 = _result_1[baseKey]
		end
		local _condition_1 = _result_1
		if _condition_1 == nil then
			_condition_1 = 0
		end
		_result[baseKey] = _condition_1 + 1
	end
	local key = string.format("%s:%d", baseKey, parentFrame.childCounts[baseKey])
	local _currentNode = parentNode.children
	if _currentNode ~= nil then
		_currentNode = _currentNode[key]
	end
	local currentNode = _currentNode
	if currentNode == nil then
		currentNode = newNode()
		local _result_1 = parentNode.children
		if _result_1 ~= nil then
			local _currentNode_1 = currentNode
			_result_1[key] = _currentNode_1
		end
	end
	currentNode.generation = parentNode.generation
	local _arg0 = newStackFrame(currentNode)
	table.insert(stack, _arg0)
	local success, handle = xpcall(fn, debug.traceback, unpack(args))
	if not success then
		error()
	end
	local _arg0_1 = #stack
	table.remove(stack, _arg0_1 + 1)
	for childKey, childNode in currentNode.children do
		if childNode.generation ~= currentNode.generation then
			destroyNode(childNode)
			local _result_1 = currentNode.children
			if _result_1 ~= nil then
				_result_1[childKey] = nil
			end
		end
	end
	return handle
end
local Runtime
do
	Runtime = setmetatable({}, {
		__tostring = function()
			return "Runtime"
		end,
	})
	Runtime.__index = Runtime
	function Runtime.new(...)
		local self = setmetatable({}, Runtime)
		return self:constructor(...) or self
	end
	function Runtime:constructor()
	end
	function Runtime:default(rootInstance)
		local node = newNode()
		node.instance = rootInstance
		return node
	end
	function Runtime:start(rootNode, fn, ...)
		local args = { ... }
		if #stack > 0 then
			error("LightningSparks.start cannot be called while Lightning.start is already running", 2)
		end
		local handler = function(...)
			local args = { ... }
			local thread = coroutine.running()
			task.defer(function()
				if coroutine.status(thread) ~= "dead" then
					task.spawn(error, "Handler passed to LightningSparks.start yielded")
				end
			end)
			return fn(unpack(args))
		end
		stack[1] = newStackFrame(rootNode)
		scope(2, "root", handler, unpack(args))
		local _arg0 = #stack
		table.remove(stack, _arg0 + 1)
		for childKey, childNode in rootNode.children do
			if childNode.generation ~= rootNode.generation then
				destroyNode(childNode)
				local _result = rootNode.children
				if _result ~= nil then
					_result[childKey] = nil
				end
			end
		end
	end
	function Runtime:widget(fn)
		local file, line = debug.info(2, "sl")
		local scopeKey = string.format("%s+%d", file, line)
		return function(...)
			local args = { ... }
			return scope(2, scopeKey, fn, unpack(args))
		end
	end
	function Runtime:useInstance(creator)
		local node = stack[#stack - 1 + 1].node
	end
	function Runtime:spark(maxCountSparks)
	end
end
return {
	Runtime = Runtime,
}
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="11">
        <Properties>
          <string name="Name">chickynoid</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">components</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local component = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").component
local Charge = component("Charge")
local Collision = component("Collision")
local CombatStats = component("CombatStats")
local DebugAdornment = component("DebugAdornment")
local Effect = component("Effect")
local ImpactEffect = component("ImpactEffect")
local Lifetime = component()
local Mob = component()
local Projectile = component("Projectile")
local Renderable = component("Renderable")
local SplashDamage = component()
local Target = component("Target")
local Transform = component("Transform")
local Velocity = component("Velocity")
return {
	Charge = Charge,
	Collision = Collision,
	CombatStats = CombatStats,
	DebugAdornment = DebugAdornment,
	Effect = Effect,
	ImpactEffect = ImpactEffect,
	Lifetime = Lifetime,
	Mob = Mob,
	Projectile = Projectile,
	Renderable = Renderable,
	SplashDamage = SplashDamage,
	Target = Target,
	Transform = Transform,
	Velocity = Velocity,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">effects</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local variantModule = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "variant", "out").variantModule
local EffectVariant = variantModule({
	Dash = function(direction)
		return {
			direction = direction,
		}
	end,
	Damage = function(damage)
		return {
			damage = damage,
		}
	end,
})
return {
	EffectVariant = EffectVariant,
}
]]></string>
        </Properties>
        <Item class="Folder" referent="14">
          <Properties>
            <string name="Name">bin</string>
          </Properties>
          <Item class="ModuleScript" referent="15">
            <Properties>
              <string name="Name">dash</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local LightningBolt = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "lightning-beams", "src", "LightningBolt")
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local dust = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "bin", "dust").dust
local LightningSparks = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "bin", "lightningSparks").LightningSparks
local DashDirection
do
	local _inverse = {}
	DashDirection = setmetatable({}, {
		__index = _inverse,
	})
	DashDirection.Forward = 0
	_inverse[0] = "Forward"
	DashDirection.Left = 1
	_inverse[1] = "Left"
	DashDirection.Right = 2
	_inverse[2] = "Right"
	DashDirection.Back = 3
	_inverse[3] = "Back"
end
local InverseDirectionMap = {
	[DashDirection.Forward] = function(n)
		return n, -n, CFrame.new(0, 0, n)
	end,
	[DashDirection.Left] = function(n)
		return -n, n, CFrame.new(-n, 0, 0)
	end,
	[DashDirection.Right] = function(n)
		return n, n, CFrame.new(n, 0, 0)
	end,
	[DashDirection.Back] = function(n)
		return -n, -n, CFrame.new(0, 0, -n)
	end,
}
local function dash(direction, source)
	local _result = source
	if _result ~= nil then
		_result = _result.Character
		if _result ~= nil then
			_result = _result:FindFirstChild("HumanoidRootPart")
		end
	end
	local root = _result
	if not root then
		return nil
	end
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.FilterDescendantsInstances = { root.Parent }
	local attachment0 = Instance.new("Attachment")
	attachment0.Parent = Workspace.Terrain
	local attachment1 = Instance.new("Attachment")
	attachment1.Parent = Workspace.Terrain
	local range, tpd = InverseDirectionMap[direction](12)
	local _fn = Workspace
	local _exp = root.Position
	local _lookVector = root.CFrame.LookVector
	local _range = range
	local raycastResult = _fn:Raycast(_exp, _lookVector * _range, raycastParams)
	if raycastResult then
		local _position = root.Position
		local _position_1 = raycastResult.Position
		tpd = -(_position - _position_1).Magnitude
	end
	local _, _1, cf = InverseDirectionMap[direction](tpd)
	attachment0.CFrame = root.CFrame
	local _cFrame = root.CFrame
	local _cf = cf
	attachment1.CFrame = _cFrame * _cf
	local _cFrame_1 = root.CFrame
	local _cf_1 = cf
	root.CFrame = _cFrame_1 * _cf_1
	local bolt = LightningBolt.new(attachment0, attachment1, 22)
	bolt.CurveSize0, bolt.CurveSize1 = 0, 0
	bolt.ContractFrom = 0.1
	bolt.Thickness = 1.2
	bolt.PulseSpeed = 30
	bolt.PulseLength = 0.1
	bolt.FadeLength = 1
	bolt.PulseLength = 5
	local result = Workspace:Raycast(attachment1.WorldPosition, Vector3.new(0, -8, 0))
	if result and result.Instance then
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
		raycastParams.FilterDescendantsInstances = { root.Parent }
		local attachment = Instance.new("Attachment")
		attachment.Parent = root
		task.delay(0.5, function()
			return attachment:Destroy()
		end)
		local dashFx = dust()
		dashFx.Parent = attachment
		dashFx:Emit(15)
	end
	task.spawn(function()
		for i = 3, 1, -0.1 do
			task.wait(1 / 30)
			bolt.MaxRadius = i
		end
	end)
	bolt.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0.27451, 0.929412, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1)) })
	local sparks = LightningSparks.new(bolt, 11)
	sparks.minSpeed = 3
	sparks.maxSpeed = 5
	sparks.minDistance, sparks.maxDistance = 5, 5
end
return {
	dash = dash,
	DashDirection = DashDirection,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="16">
            <Properties>
              <string name="Name">dust</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local New = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").New
local function dust(texture, colour)
	local _fn = New("ParticleEmitter")
	local _object = {
		Brightness = 1.5,
		Color = colour or ColorSequence.new(Color3.fromRGB(191, 184, 148)),
		LightEmission = 0,
		LightInfluence = 0,
		Orientation = Enum.ParticleOrientation.FacingCamera,
		Size = NumberSequence.new({ NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 4, 2) }),
	}
	local _left = "Texture"
	local _condition = texture
	if _condition == nil then
		_condition = "rbxassetid://9232117588"
	end
	_object[_left] = _condition
	_object.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2, 0.95), NumberSequenceKeypoint.new(1, 1) })
	_object.Lifetime = NumberRange.new(0.75, 0.8)
	_object.Rate = 15
	_object.RotSpeed = NumberRange.new(-90, 90)
	_object.SpreadAngle = Vector2.new(5, 15)
	_object.Shape = Enum.ParticleEmitterShape.Box
	_object.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
	_object.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
	_object.Drag = 3
	_object.TimeScale = 1
	_object.VelocityInheritance = 0
	return _fn(_object)
end
return {
	dust = dust,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">lightningSparks</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local LightningBolt = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "lightning-beams", "src", "LightningBolt")
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
local RNG = Random.new()
local function randomVectorOffset(v, maxAngle)
	local _exp = CFrame.lookAt(Vector3.zero, v)
	local _exp_1 = CFrame.Angles(0, 0, RNG:NextNumber(0, 2 * math.pi))
	local _arg0 = CFrame.Angles(math.acos(RNG:NextNumber(math.cos(maxAngle), 1)), 0, 0)
	local _lookVector = (_exp_1 * _arg0).LookVector
	return _exp * _lookVector
end
local LightningSparks
do
	LightningSparks = setmetatable({}, {
		__tostring = function()
			return "LightningSparks"
		end,
	})
	LightningSparks.__index = LightningSparks
	function LightningSparks.new(...)
		local self = setmetatable({}, LightningSparks)
		return self:constructor(...) or self
	end
	function LightningSparks:constructor(lightningBolt, maxSparkCount)
		if maxSparkCount == nil then
			maxSparkCount = 10
		end
		self.lightningBolt = lightningBolt
		self.maxSparkCount = maxSparkCount
		self.enabled = true
		self.minSpeed = 4
		self.maxSpeed = 6
		self.minDistance = 3
		self.maxDistance = 6
		self.minPartsPerSpark = 8
		self.maxPartsPerSpark = 10
		self.sparksN = 0
		self.slotTable = {}
		self.connection = nil
		self.connection = RunService.Heartbeat:Connect(function()
			local _result = self.connection
			if _result ~= nil then
				_result = _result.Connected
			end
			if not _result then
				return nil
			end
			if self.enabled and self.sparksN < self.maxSparkCount then
				local bolt = self.lightningBolt
				if bolt._Parts[1].Parent == nil then
					self:destroy()
					return nil
				end
				local boltParts = bolt._Parts
				local boltPartsN = #boltParts
				local opaqueParts = {}
				for partIdx = 1, boltPartsN do
					if boltParts[partIdx - 1 + 1].Transparency < 0.3 then
						local _arg0 = (partIdx - 0.5) / boltPartsN
						table.insert(opaqueParts, _arg0)
					end
				end
				local minSlot, maxSlot = nil, nil
				if #opaqueParts ~= 0 then
					minSlot, maxSlot = math.ceil(opaqueParts[1] * self.maxSparkCount), math.ceil(opaqueParts[#opaqueParts - 1 + 1] * self.maxSparkCount)
				end
				for _ = 1, RNG:NextInteger(1, self.maxSparkCount - self.sparksN) do
					if #opaqueParts == 0 then
						break
					end
					local availableSlots = {}
					for slot = minSlot, maxSlot do
						if self.slotTable[slot - 1 + 1] == nil then
							table.insert(availableSlots, slot)
						end
					end
					local _ = _
					if #availableSlots ~= 0 then
						local chosenSlot = availableSlots[RNG:NextInteger(1, #availableSlots) - 1 + 1]
						local tRng = RNG:NextNumber(-0.5, 0.5)
						local chosenT = (chosenSlot - 0.5 + tRng) / self.maxSparkCount
						local dist, chosenPart = 10, 1
						for opaqueIdx = 1, #opaqueParts do
							local testDist = math.abs(opaqueParts[opaqueIdx - 1 + 1] - chosenT)
							if testDist < dist then
								dist, chosenPart = testDist, math.floor(opaqueParts[opaqueIdx - 1 + 1] * boltPartsN + 0.5 + 0.5)
							end
						end
						local part = boltParts[chosenPart - 1 + 1]
						local a1, a2 = {}, {}
						local _position = part.Position
						local _rightVector = part.CFrame.RightVector
						local _x = part.Size.X
						local _arg0 = _rightVector * _x * tRng
						a1.WorldPosition = _position + _arg0
						local _worldPosition = a1.WorldPosition
						local _exp = randomVectorOffset(part.CFrame.RightVector, math.pi / 4)
						local _arg0_1 = RNG:NextNumber(self.minDistance, self.maxDistance)
						a2.WorldPosition = _worldPosition + (_exp * _arg0_1)
						local _worldPosition_1 = a2.WorldPosition
						local _worldPosition_2 = a1.WorldPosition
						a1.WorldAxis = (_worldPosition_1 - _worldPosition_2).Unit
						a2.WorldAxis = a1.WorldAxis
						local spark = LightningBolt.new(a1, a2, RNG:NextInteger(self.minPartsPerSpark, self.maxPartsPerSpark))
						spark.MinRadius, spark.MaxRadius = 0, 0.8
						spark.AnimationSpeed = 0
						spark.Thickness = part.Size.Y / 2
						spark.MinThicknessMultiplier, spark.MaxThicknessMultiplier = 1, 1
						spark.PulseLength = 0.5
						spark.PulseSpeed = RNG:NextNumber(self.minSpeed, self.maxSpeed)
						spark.FadeLength = 0.25
						local H, S, V = Color3.toHSV(part.Color)
						spark.Color = Color3.fromHSV(H, S, V)
						self.slotTable[chosenSlot - 1 + 1] = spark
					end
				end
			end
			local slotsInuse = 0
			local _slotTable = self.slotTable
			local _arg0 = function(v, i)
				if v._Parts[1].Parent ~= nil then
					slotsInuse += 1
				else
					self.slotTable[i - 1 + 1] = nil
				end
			end
			for _k, _v in _slotTable do
				_arg0(_v, _k - 1, _slotTable)
			end
			self.sparksN = slotsInuse
		end)
	end
	function LightningSparks:destroy()
		local _result = self.connection
		if _result ~= nil then
			_result:Disconnect()
		end
		self.connection = nil
		setmetatable(self, nil)
	end
end
return {
	LightningSparks = LightningSparks,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">replicate_fx_on_client</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local match = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "variant", "out").match
local dash = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "bin", "dash").dash
local function replicate_fx_on_client(world, _param)
	local source = _param.source
	local variant = _param.variant
	local target = _param.target
	local pos = _param.pos
	match(variant, {
		Dash = function(_param_1)
			local direction = _param_1.direction
			return dash(direction, source)
		end,
		Damage = error,
	})
end
return {
	replicate_fx_on_client = replicate_fx_on_client,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="19">
        <Properties>
          <string name="Name">emitEffects</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Effect = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Effect
local remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "remotes")
local remoteEvent = remotes.Server:Get("CreateFx")
local function emitEffects(world)
	remoteEvent:Connect(function(_, effect)
		world:spawn(Effect(effect))
	end)
end
return {
	emitEffects = emitEffects,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="20">
        <Properties>
          <string name="Name">hotReloader</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local CollectionService = _services.CollectionService
local RunService = _services.RunService
local HotReloader
do
	HotReloader = setmetatable({}, {
		__tostring = function()
			return "HotReloader"
		end,
	})
	HotReloader.__index = HotReloader
	function HotReloader.new(...)
		local self = setmetatable({}, HotReloader)
		return self:constructor(...) or self
	end
	function HotReloader:constructor(listeners, clonedModules)
		if listeners == nil then
			listeners = {}
		end
		if clonedModules == nil then
			clonedModules = {}
		end
		self.listeners = listeners
		self.clonedModules = clonedModules
	end
	function HotReloader:destroy()
		local _listeners = self.listeners
		local _arg0 = function(listener)
			return listener:Disconnect()
		end
		for _k, _v in _listeners do
			_arg0(_v, _k - 1, _listeners)
		end
		self.listeners = {}
		local _clonedModules = self.clonedModules
		local _arg0_1 = function(cloned)
			return cloned:Destroy()
		end
		for _k, _v in _clonedModules do
			_arg0_1(_v, _k, _clonedModules)
		end
		self.clonedModules = {}
	end
	function HotReloader:listen(module, fn, cleanup)
		if RunService:IsStudio() then
			local module_changed = module.Changed:Connect(function()
				local _clonedModules = self.clonedModules
				local _module = module
				local mod = _clonedModules[_module]
				if mod then
					cleanup(mod)
					mod:Destroy()
				else
					cleanup(module)
				end
				local cloned = module:Clone()
				CollectionService:AddTag(cloned, "RewireClonedModule")
				cloned.Parent = module.Parent
				local _clonedModules_1 = self.clonedModules
				local _module_1 = module
				_clonedModules_1[_module_1] = cloned
				fn(cloned)
				warn("HotReloaded " .. (module:GetFullName() .. "!"))
			end)
			table.insert(self.listeners, module_changed)
		end
		fn(module)
	end
end
return {
	HotReloader = HotReloader,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="21">
        <Properties>
          <string name="Name">playEffect</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Plasma = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "plasma", "src")
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local RunService = _services.RunService
local Workspace = _services.Workspace
local function playEffect(title, fn, ...)
	local args = { ... }
	return function(target)
		local root = Plasma.new(target)
		local attachmentsToRemove = {}
		local connection = RunService.Heartbeat:Connect(function()
			Plasma.start(root, function()
				Plasma.window(title, function()
					if Plasma.button("Click Me"):clicked() then
						local attachment = Instance.new("Attachment")
						attachment.Parent = Workspace.Terrain
						local _cFrame = Workspace.CurrentCamera.CFrame
						local _cFrame_1 = CFrame.new(0, 0, -12)
						attachment.CFrame = _cFrame * _cFrame_1
						table.insert(attachmentsToRemove, attachment)
						local particle = fn(unpack(args))
						particle.Parent = attachment
						task.delay(particle.Lifetime.Max + 0.25, function()
							return attachment:Destroy()
						end)
					end
				end)
			end)
		end)
		return function()
			connection:Disconnect()
			connection = nil
			Plasma.start(root, function() end)
			local _arg0 = function(attachment)
				attachment.Parent = nil
				return attachment.Parent
			end
			for _k, _v in attachmentsToRemove do
				_arg0(_v, _k - 1, attachmentsToRemove)
			end
		end
	end
end
return {
	playEffect = playEffect,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="22">
        <Properties>
          <string name="Name">remotes</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Net = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "net", "out")
return Net.CreateDefinitions({
	MatterRemote = Net.Definitions.ServerToClientEvent(),
	CreateFx = Net.Definitions.ClientToServerEvent(),
})
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="23">
        <Properties>
          <string name="Name">setupTags</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Renderable = _components.Renderable
local Transform = _components.Transform
local CollectionService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").CollectionService
local boundTags = {}
local function setupTags(world)
	local function spawnBound(model, component)
		local id = world:spawn(component(), Renderable({
			model = model,
		}), Transform({
			cf = model:GetPivot(),
		}))
		model:SetAttribute("serverEntityId", id)
	end
	for component in boundTags do
		local tagName = tostring(component)
		for _, instance in CollectionService:GetTagged(tagName) do
			spawnBound(instance, component)
		end
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(instance)
			spawnBound(instance, component)
		end)
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(instance)
			local id = instance:GetAttribute("serverEntityId")
			if id ~= nil then
				world:despawn(id)
			end
		end)
	end
end
return {
	setupTags = setupTags,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="24">
        <Properties>
          <string name="Name">start</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _matter = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib")
local Debugger = _matter.Debugger
local Loop = _matter.Loop
local World = _matter.World
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local HotReloader = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "rewire", "out").HotReloader
local Plasma = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "plasma", "src")
-- import { ChickynoidClient, ChickynoidServer } from "./chickynoid/types";
local Renderable = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Renderable
local function start(containers, state)
	local world = World.new()
	local myDebugger = Debugger.new(Plasma)
	myDebugger.findInstanceFromEntity = function(id)
		if not world:contains(id) then
			return nil
		end
		local model = world:get(id, Renderable)
		return if model then model.model else nil
	end
	myDebugger.authorize = function(player)
		return player.UserId == 97718174
	end
	local loop = Loop.new(world, state, myDebugger:getWidgets())
	local hotReloader = HotReloader.new()
	local firstRunSystems = {}
	local systemsByModule = {}
	local function loadModule(mod, ctx)
		local originalModule = ctx.originalModule
		local ok, system = pcall(require, mod)
		if not ok then
			warn("Error when hot-reloading system", mod.Name, system)
			return nil
		end
		if firstRunSystems then
			table.insert(firstRunSystems, system)
		elseif systemsByModule[originalModule] ~= nil then
			loop:replaceSystem(systemsByModule[originalModule], system)
			myDebugger:replaceSystem(systemsByModule[originalModule], system)
		else
			loop:scheduleSystem(system)
		end
		systemsByModule[originalModule] = system
	end
	local function unloadModule(_, ctx)
		if ctx.isReloading then
			return nil
		end
		local originalModule = ctx.originalModule
		if systemsByModule[originalModule] ~= nil then
			loop:evictSystem(systemsByModule[originalModule])
			systemsByModule[originalModule] = nil
		end
	end
	local _containers = containers
	local _arg0 = function(container)
		return hotReloader:scan(container, loadModule, unloadModule)
	end
	for _k, _v in _containers do
		_arg0(_v, _k - 1, _containers)
	end
	loop:scheduleSystems(firstRunSystems)
	firstRunSystems = nil
	myDebugger:autoInitialize(loop)
	loop:begin({
		default = if RunService:IsClient() then RunService.RenderStepped else RunService.Heartbeat,
	})
	-- let chickynoid: typeof ChickynoidClient | typeof ChickynoidServer = ChickynoidClient;
	if RunService:IsClient() then
		UserInputService.InputBegan:Connect(function(input)
			if input.KeyCode == Enum.KeyCode.F4 then
				myDebugger:toggle()
				state.debugEnabled = myDebugger.enabled
			end
		end)
	end
	-- (chickynoid as typeof ChickynoidClient & typeof ChickynoidServer).Setup();
	return world, state
end
return {
	start = start,
}
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">stories</string>
        </Properties>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">dust.story</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local dust = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "bin", "dust").dust
local playEffect = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "playEffect").playEffect
return playEffect("Dust", dust)
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="27">
        <Properties>
          <string name="Name">systems</string>
        </Properties>
        <Item class="ModuleScript" referent="28">
          <Properties>
            <string name="Name">updateRenderableAttribute</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
local Renderable = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Renderable
local name = if RunService:IsServer() then "serverEntityId" else "clientEntityId"
local function updateRenderableAttribute(world)
	for id, record in world:queryChanged(Renderable) do
		if record.new then
			record.new.model:SetAttribute(name, id)
		end
	end
end
return updateRenderableAttribute
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="29">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="30">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="31">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="32">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="33">
          <Properties>
            <string name="Name">@rbxts</string>
          </Properties>
          <Item class="Folder" referent="34">
            <Properties>
              <string name="Name">compiler-types</string>
            </Properties>
            <Item class="Folder" referent="35">
              <Properties>
                <string name="Name">types</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="36">
            <Properties>
              <string name="Name">fusion</string>
            </Properties>
            <Item class="ModuleScript" referent="37">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = false},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring)
}) :: Fusion
]]></string>
              </Properties>
              <Item class="Folder" referent="38">
                <Properties>
                  <string name="Name">Animation</string>
                </Properties>
                <Item class="ModuleScript" referent="39">
                  <Properties>
                    <string name="Name">Spring</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping &lt; 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed &lt; 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring&lt;T>(
	goalState: PubTypes.Value&lt;T>,
	speed: PubTypes.CanBeState&lt;number>?,
	damping: PubTypes.CanBeState&lt;number>?
): Types.Spring&lt;T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="40">
                  <Properties>
                    <string name="Name">SpringScheduler</string>
                    <string name="Source">--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set&lt;T> = {[T]: any}
type Spring = Types.Spring&lt;any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set&lt;Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set&lt;Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="41">
                  <Properties>
                    <string name="Name">Tween</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween&lt;T>(
	goalState: PubTypes.StateObject&lt;PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState&lt;TweenInfo>?
): Types.Tween&lt;T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="42">
                  <Properties>
                    <string name="Name">TweenScheduler</string>
                    <string name="Source">--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set&lt;T> = {[T]: any}
type Tween = Types.Tween&lt;any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set&lt;Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="43">
                  <Properties>
                    <string name="Name">getTweenRatio</string>
                    <string name="Source">--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime &lt;= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="44">
                  <Properties>
                    <string name="Name">lerpType</string>
                    <string name="Source">--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio &lt; 0.5 then
		return from
	else
		return to
	end
end

return lerpType</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="45">
                  <Properties>
                    <string name="Name">packType</string>
                    <string name="Source">--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="46">
                  <Properties>
                    <string name="Name">springCoefficients</string>
                    <string name="Source">--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -ζω ± Sqrt[ζ^2 - 1] ω
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-tω)(1+tω) + v0(e^-tω)t
		-- v[t] -> x0(t ω^2)(-e^-tω) + v0(1 - tω)(e^-tω)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		-- α = Sqrt[1 - ζ^2]
		-- x[t] -> x0(e^-tζω)(α Cos[tα] + ζω Sin[tα])/α
		--       + v0(e^-tζω)(Sin[tα])/α
		-- v[t] -> x0(-e^-tζω)(α^2 + ζ^2 ω^2)(Sin[tα])/α
		--       + v0(e^-tζω)(α Cos[tα] - ζω Sin[tα])/α

		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * time
		local expTerm = math.exp(-time*damping*speed)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha / speed
		velPos = (sinInvAlphaDamp*damping + sinTerm*alpha) * -speed
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="47">
                  <Properties>
                    <string name="Name">unpackType</string>
                    <string name="Source">--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="48">
                <Properties>
                  <string name="Name">Colour</string>
                </Properties>
                <Item class="ModuleScript" referent="49">
                  <Properties>
                    <string name="Name">Oklab</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="50">
                <Properties>
                  <string name="Name">Dependencies</string>
                </Properties>
                <Item class="ModuleScript" referent="51">
                  <Properties>
                    <string name="Name">captureDependencies</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="52">
                  <Properties>
                    <string name="Name">initDependency</string>
                    <string name="Source">--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="53">
                  <Properties>
                    <string name="Name">sharedState</string>
                    <string name="Source">--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set&lt;PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set&lt;PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="54">
                  <Properties>
                    <string name="Name">updateAll</string>
                    <string name="Source">--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}
type Descendant = (PubTypes.Dependent &amp; PubTypes.Dependency) | PubTypes.Dependent

local function updateAll(ancestor: PubTypes.Dependency)
	--[[
		First things first, we need to mark all indirect dependents as needing
		an update. This means we can ignore any dependencies that aren't related
		to the current update operation.
	]]

	-- set of all dependents that still need to be updated
	local needsUpdateSet: Set&lt;Descendant> = {}
	-- the dependents to be processed now
	local processNow: {Descendant} = {}
	local processNowSize = 0
	-- the dependents of the open set to be processed next
	local processNext: {Descendant} = {}
	local processNextSize = 0

	-- initialise `processNow` with dependents of ancestor
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as needing an update
			needsUpdateSet[member] = true

			-- add the dependents of the member for processing
			-- FIXME: Typed Luau doesn't understand this type narrowing yet
			if (member :: any).dependentSet ~= nil then
				local member = member :: PubTypes.Dependent &amp; PubTypes.Dependency
				for dependent in pairs(member.dependentSet) do
					processNextSize += 1
					processNext[processNextSize] = dependent
					processingDone = false
				end
			end
		end

		-- swap in the next dependents to be processed
		processNow, processNext = processNext, processNow
		processNowSize, processNextSize = processNextSize, 0
		table.clear(processNext)
	until processingDone

	--[[
		`needsUpdateSet` is now set up. Now that we have this information, we
		can iterate over the dependents once more and update them only when the
		relevant dependencies have been updated.
	]]

	-- re-initialise `processNow` similar to before
	processNowSize = 0
	table.clear(processNow)
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as no longer needing an update
			needsUpdateSet[member] = nil

			--FUTURE: should this guard against errors?
			local didChange = member:update()

			-- add the dependents of the member for processing
			-- optimisation: if nothing changed, then we don't need to add these
			-- dependents, because they don't need processing.
			-- FIXME: Typed Luau doesn't understand this type narrowing yet
			if didChange and (member :: any).dependentSet ~= nil then
				local member = member :: PubTypes.Dependent &amp; PubTypes.Dependency
				for dependent in pairs(member.dependentSet) do
					-- don't add dependents that have un-updated dependencies
					local allDependenciesUpdated = true
					for dependentDependency in pairs(dependent.dependencySet) do
						-- HACK: keys of needsUpdateSet must be Dependents, so
						-- since we want to ignore non-Dependents, we just type
						-- cast here regardless of safety
						if needsUpdateSet[dependentDependency :: any] then
							allDependenciesUpdated = false
							break
						end
					end

					if allDependenciesUpdated then
						processNextSize += 1
						processNext[processNextSize] = dependent
						processingDone = false
					end
				end
			end
		end

		if not processingDone then
			-- swap in the next dependents to be processed
			processNow, processNext = processNext, processNow
			processNowSize, processNextSize = processNextSize, 0
			table.clear(processNext)
		end
	until processingDone

	--[[
		The update is now complete!
	]]
end

return updateAll</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="55">
                  <Properties>
                    <string name="Name">useDependency</string>
                    <string name="Source">--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="56">
                <Properties>
                  <string name="Name">Instances</string>
                </Properties>
                <Item class="ModuleScript" referent="57">
                  <Properties>
                    <string name="Name">Children</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set&lt;T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
	local newParented: Set&lt;Instance> = {}
	local oldParented: Set&lt;Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyToRef.instance
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateChildren()
	end)

	-- perform initial child parenting
	updateChildren()
end

return Children :: PubTypes.SpecialKey</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="58">
                  <Properties>
                    <string name="Name">Cleanup</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="59">
                  <Properties>
                    <string name="Name">Hydrate</string>
                    <string name="Source">--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local semiWeakRef = require(Package.Instances.semiWeakRef)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, semiWeakRef(target))
		return target
	end
end

return Hydrate</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="60">
                  <Properties>
                    <string name="Name">New</string>
                    <string name="Source">--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local semiWeakRef = require(Package.Instances.semiWeakRef)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, semiWeakRef(instance))

		return instance
	end
end

return New</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="61">
                  <Properties>
                    <string name="Name">OnChange</string>
                    <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
		local instance = applyToRef.instance :: Instance
		local ok, event = pcall(instance.GetPropertyChangedSignal, instance, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, instance.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				if applyToRef.instance ~= nil then
					callback((applyToRef.instance :: any)[propertyName])
				end
			end))
		end
	end

	return changeKey
end

return OnChange</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="62">
                  <Properties>
                    <string name="Name">OnEvent</string>
                    <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
		local instance = applyToRef.instance :: Instance
		local ok, event = pcall(getProperty_unsafe, instance, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, instance.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="63">
                  <Properties>
                    <string name="Name">Out</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
		local instance = applyToRef.instance :: Instance
		local ok, event = pcall(instance.GetPropertyChangedSignal, instance, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, instance.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
				logError("invalidOutType")
		else
			outState:set((applyToRef.instance :: any)[propertyName])
			table.insert(cleanupTasks, event:Connect(function()
				if applyToRef.instance ~= nil then
					outState:set((applyToRef.instance :: any)[propertyName])
				end
			end))
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="64">
                  <Properties>
                    <string name="Name">Ref</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyToRef: PubTypes.SemiWeakRef, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyToRef.instance)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="65">
                  <Properties>
                    <string name="Name">applyInstanceProps</string>
                    <string name="Source">--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local onDestroy = require(Package.Instances.onDestroy)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			-- property is not assignable
			logError("cannotAssignProperty", nil, instance.ClassName, property)
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instanceRef: PubTypes.SemiWeakRef, property: string, value: PubTypes.CanBeState&lt;any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instanceRef.instance :: Instance, property, value:get(false))
				end)
			end
		end

		setProperty(instanceRef.instance :: Instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instanceRef.instance :: Instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyToRef: PubTypes.SemiWeakRef)
	if applyToRef.instance == nil then
		-- this is possible, but not useful, so probably indicates an issue!
		return logWarn("applyPropsNilRef")
	end

	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyToRef, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyToRef, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyToRef, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyToRef, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyToRef, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyToRef, cleanupTasks)
	end

	onDestroy(applyToRef, cleanup, cleanupTasks)
end

return applyInstanceProps</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="66">
                  <Properties>
                    <string name="Name">defaultProps</string>
                    <string name="Source">--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="67">
                  <Properties>
                    <string name="Name">isAccessible</string>
                    <string name="Source">--!strict

--[[
	Returns true if an instance is considered 'accessible' - that is, a script
	could obtain a reference to an instance starting from the default instance
	globals (e.g. `game`, `script` and `plugin`).

	NOTE: The specific implementation of `isAccessible` does not handle some
	edge cases for performance reasons. Specifically, `isAccessible` only
	considers the hierarchical relationships between instances, and not
	references stored in instances like ObjectValues.

	This means that the only instances considered 'accessible' are those which
	are descendants of:

	- the data model containing `game`
	- the data model containing `script`
	- the data model containing `plugin`

	All other data models are not considered 'accessible' for simplicity.
]]

type Set&lt;T> = {[T]: any}

local dataModels: Set&lt;Instance> = {}
for _, descendant in ipairs({game, script, plugin}) do
	local root = descendant
	while root.Parent ~= nil do
		root = root.Parent
	end

	dataModels[root] = true
end

local function isAccessible(target: Instance): boolean
	for root in pairs(dataModels) do
		if root:IsAncestorOf(target) then
			return true
		end
	end
	return false
end

return isAccessible</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="68">
                  <Properties>
                    <string name="Name">onDestroy</string>
                    <string name="Source">--!strict

--[[
	Runs a callback with arguments when the referenced instance is destroyed.
	Returns a function to disconnect from this event later.

	This is more comprehensive than `instance.Destroyed` as it covers instances
	not explicitly destroyed with `:Destroy()`.

	NOTE: use of this function should be a last resort - if you have another way
	of more concretely tracking the lifetime of the instance, please use that
	instead. This function is intended for use with user-provided instances for
	which the lifetime is not known.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local isAccessible = require(Package.Instances.isAccessible)

-- FIXME: whenever they fix generic type packs in Roblox LSP:
--- onDestroy&lt;A...>(instanceRef: Types.SemiWeakRef, callback: (A...) -> (), ...: A...)

local function onDestroy(instanceRef: PubTypes.SemiWeakRef, callback: (...any) -> (), ...: any): () -> ()
	if instanceRef.instance == nil then
		-- if we get a nil reference initially, then there's probably an issue
		-- somewhere else - usually the instance isn't destroyed until later!
		logWarn("onDestroyNilRef")
		callback(...)
		return function() end
	end

	local ancestryConn: RBXScriptConnection
	local disconnected = false

	local function disconnect()
		if not disconnected then
			disconnected = true
			ancestryConn:Disconnect()
		end
	end

	local args = table.pack(...)
	local accessible: boolean

	local function onAncestryChange()
		if disconnected then
			return
		end

		accessible = if instanceRef.instance == nil then false else isAccessible(instanceRef.instance :: Instance)

		if accessible then
			-- don't need to monitor the instance if it's safely in the game
			return
		end

		-- start monitoring the instance for destruction
		task.defer(function()
			while not accessible and not disconnected do
				if not ancestryConn.Connected then
					callback(table.unpack(args, 1, args.n))
					disconnect()
					return
				end
				task.wait()
			end
		end)
	end

	ancestryConn = (instanceRef.instance :: Instance).AncestryChanged:Connect(onAncestryChange)
	onAncestryChange()

	return disconnect
end

return onDestroy</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="69">
                  <Properties>
                    <string name="Name">semiWeakRef</string>
                    <string name="Source">--!strict

--[[
	Returns a semi-weak reference to the given instance:

	- the reference acts like a strong reference when the instance can be
	accessed via the data model (see `isAccessible.lua`)
	- the reference acts like a weak reference otherwise

	This allows users to have a stable reference to an instance, while allowing
	the garbage collector to collect it when other users dispose of it.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local isAccessible = require(Package.Instances.isAccessible)

local WEAK_MODE = { __mode = "v" }
local STRONG_MODE = { __mode = "" }

-- Because the semi-weak refs are stored strongly here, the instance keys won't
-- garbage collect unless the semi-weak ref is weak, which only occurs when the
-- instance is not accessible.
local cachedRefs: {[Instance]: PubTypes.SemiWeakRef} = {}
setmetatable(cachedRefs, { __mode = "k"})

local function semiWeakRef_impl(strongReferTo: Instance?): PubTypes.SemiWeakRef
	if strongReferTo == nil then
		return {type = "SemiWeakRef", instance = nil}
	else
		if cachedRefs[strongReferTo] then
			return cachedRefs[strongReferTo]
		end

		local ref: PubTypes.SemiWeakRef = {
			type = "SemiWeakRef",
			instance = strongReferTo
		}
		cachedRefs[strongReferTo] = ref

		-- we don't want a strong reference lingering around in any closures here
		strongReferTo = nil

		local function updateStrength()
			if ref.instance ~= nil then
				setmetatable(ref, if isAccessible(ref.instance) then STRONG_MODE else WEAK_MODE)
			end
		end

		(ref.instance :: Instance).AncestryChanged:Connect(updateStrength)
		task.defer(updateStrength)

		return ref
	end
end

local semiWeakRef = (semiWeakRef_impl :: any) :: (referTo: Instance) -> PubTypes.SemiWeakRef

return semiWeakRef</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="70">
                <Properties>
                  <string name="Name">Logging</string>
                </Properties>
                <Item class="ModuleScript" referent="71">
                  <Properties>
                    <string name="Name">logError</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="72">
                  <Properties>
                    <string name="Name">logErrorNonFatal</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="73">
                  <Properties>
                    <string name="Name">logWarn</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="74">
                  <Properties>
                    <string name="Name">messages</string>
                    <string name="Source">--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	applyPropsNilRef = "`applyInstanceProps` got a nil ref! (this is an internal issue)",
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	onDestroyNilRef = "`onDestroy` got a nil ref! (this is an internal issue, was the instance lost too early?)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="75">
                  <Properties>
                    <string name="Name">parseError</string>
                    <string name="Source">--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="76">
                <Properties>
                  <string name="Name">PubTypes</string>
                  <string name="Source">--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set&lt;Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set&lt;Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject&lt;T> = Dependency &amp; {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject&lt;T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState&lt;T> = StateObject&lt;T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value&lt;T> = StateObject&lt;T> &amp; {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value&lt;T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KO, VO> = StateObject&lt;{ [KO]: VO }> &amp; Dependent &amp; {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KO, V> = StateObject&lt;{ [KO]: V }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;K, VO> = StateObject&lt;{ [K]: VO }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring&lt;T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring&lt;T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring&lt;T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent &amp; {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- A semi-weak instance reference.
export type SemiWeakRef = {
	type: string, -- replace with "SemiWeakRef" when Luau supports singleton types
	instance: Instance?
}

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: SemiWeakRef, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject&lt;Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="77">
                <Properties>
                  <string name="Name">State</string>
                </Properties>
                <Item class="ModuleScript" referent="78">
                  <Properties>
                    <string name="Name">Computed</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue = captureDependencies(self.dependencySet, self._callback)

	if ok then
		local oldValue = self._value
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not isSimilar(oldValue, newValue)
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed&lt;T>(callback: () -> T): Types.Computed&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_callback = callback,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="79">
                  <Properties>
                    <string name="Name">ForKeys</string>
                    <string name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

    Additionally, a `meta` table/value can optionally be returned to pass data created
    when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

local function forKeysCleanup(keyOut: any, meta: any?)
	cleanup(keyOut)

	if meta then
		cleanup(meta)
	end
end

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this key has changed

	It will recalculate those keys, storing information about any dependencies used
	in the processor callback during value generation, and saving the new key to the
	output array with the same value. If it is overwriting an older value, that older
	value will be passed to the destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output key from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local oldInputKeys = self._oldInputTable
	local newInputKeys = self._inputTable
	local keyOIMap = self._keyOIMap
	local outputKeys = self._outputTable
	local meta = self._meta

	if inputIsState then
		newInputKeys = newInputKeys:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- STEP 1: find keys that were not previously present
	for newInKey, _value in pairs(newInputKeys) do
		-- get or create key data
		local keyData = self._keyData[newInKey]
		if keyData == nil then
			keyData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- if an input key's previous value is non-nil, then there's no need to recalculate it
		-- this also allows it to have a non-truthy value, which is important since we don't care
		-- about the value; if we have dependencies then we also need to check if they've changed,
		-- since if they have then the key has "changed".
		local shouldRecalculate = oldInputKeys[newInKey] == nil

		if not shouldRecalculate then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- if we should recalculate the output by this point, do that
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				local oldInKey = keyOIMap[newOutKey]

				-- if there are colliding output keys, throw an error
				if oldInKey ~= newInKey and newInputKeys[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- make the old input match the new input value
				oldInputKeys[newInKey] = _value
				-- store the new meta value in the table
				meta[newOutKey] = newMetaValue
				-- store the new output key for next time we run the output comparison
				keyOIMap[newOutKey] = newInKey
				-- store the new output key in the table with its original value, which we give to the user
				outputKeys[newOutKey] = _value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end
	end

	-- STEP 2: find keys that were removed

	for outputKey, inputKey in pairs(keyOIMap) do
		-- if the output key doesn't have an equivalent input key in the new input table
		if newInputKeys[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove input key
			oldInputKeys[inputKey] = nil
			-- remove meta data
			meta[outputKey] = nil
			-- remove key OI data
			keyOIMap[outputKey] = nil
			-- remove output key
			outputKeys[outputKey] = nil
			-- remove key data
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys<KI, KO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys<KI, KO, M>
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = forKeysCleanup :: (KO, M?) -> ()
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="80">
                  <Properties>
                    <string name="Name">ForPairs</string>
                    <string name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

local function forPairsCleanup(keyOut: any, valueOut: any, meta: any?)
	cleanup(keyOut)
	cleanup(valueOut)

	if meta then
		cleanup(meta)
	end
end

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local oldInputPairs = self._oldInputTable
	local newInputPairs = self._inputTable
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	if inputIsState then
		newInputPairs = newInputPairs:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out new output pairs
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputPairs = self._oldOutputTable
	local newOutputPairs = self._outputTable
	table.clear(newOutputPairs)

	-- STEP 1: find key/value pairs that changed value or were not previously present

	--[[
		- if a key/value input pair doesn't change, it will have the same key/value output pair
		- if only a value changes, (KI) -> (OVI) is replaced by (KI) -> (NVI)
		- if only a key changes, (NKI) -> (VI) is added on to (OKI) -> (VI), and may replace (NKI) -> (OVI)

		- when just a key or a value changes, it is not guaranteed for (KO) -> (VO) to be replaced
			- we intend for keys and values to rely on both key and value, as such we cannot reliably check
				for a previous (KO, VO), given a KI and a VI that *might* have changed
			- as such, we don't need to check for changes in the input table, instead we need to check for
				changes in the output table

		- when both a key and value change, it is still not guaranteed for (KO) -> (VO) to be replaced
			- what if (KIA) -> (VIA) gives us (KO) -> (VO), but (KIB) -> (VIB) also gives us (KO) -> (VO)
				- in this case, (KO) -> (VO) has not been replaced

		maybe?:
			- Let f: (KI, VI) -> (KO, VO)
				- f is not one to one
				- but we want g: (KO) -> (KI, VI) to be a function on any given set of inputs
					- otherwise we can have conflicting inputs
				- we do not care if h: (VO) -> (KI, VI) is a function
					- it is expected for differing (KI, VI) to give the same VO
	]]

	for newInKey, newInValue in pairs(newInputPairs) do
		-- get or create key data
		local keyData = self._keyData[newInKey]
		if keyData == nil then
			keyData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- if an inputKey's inputValue hasn't changed, neither will its outputKey or outputValue
		local shouldRecalculate = oldInputPairs[newInKey] ~= newInValue

		if not shouldRecalculate then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- if we should recalculate the output by this point, do that
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				local oldOutValue = oldOutputPairs[newOutKey]

				-- if the output key/value pair has changed
				if oldOutValue ~= newOutValue then
					didChange = true

					-- clean up the old calculated value
					if oldOutValue ~= nil then
						local oldMetaValue = meta[newOutKey]

						local destructOK, err = xpcall(
							self._destructor,
							parseError,
							newOutKey,
							oldOutValue,
							oldMetaValue
						)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				-- when this occurs, (KIA, VIA) -> (KO, VOA) exists; but (KIB, VIB) -> (KO, VOB) also exists
				-- with no guarantee that VIB == VOB. And because ForPairs is meant to output a key and a value
				-- based on an input key and value, it means that there is a fatal error! Someone might expect
				-- two things to be output with separate values, but because (KO) is being written to twice,
				-- it will only output one thing!
				if newOutputPairs[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputPairs[inKey]

							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				-- make the old input match the new input
				oldInputPairs[newInKey] = newInValue
				-- store the key IO map for key removal detection
				keyIOMap[newInKey] = newOutKey
				-- store the new meta value in the table
				meta[newOutKey] = newMetaValue
				-- store the new output value for next time we run the output comparison
				oldOutputPairs[newOutKey] = newOutValue
				-- store the new output value in the table we give to the user
				newOutputPairs[newOutKey] = newOutValue
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local newOutKey = keyIOMap[newInKey]

			if newOutputPairs[newOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if newOutKey == outKey then
						previousNewValue = newInputPairs[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(newOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- store the old output value in the new table we give to the user
			newOutputPairs[newOutKey] = oldOutputPairs[newOutKey]
		end
	end

	-- STEP 2: find keys that were removed

	for key in pairs(oldOutputPairs) do
		-- if this key doesn't have an equivalent in the new output table
		if newOutputPairs[key] == nil then
			-- clean up the old calculated value
			local oldOutValue = oldOutputPairs[key]
			local oldMetaValue = meta[key]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor, parseError, key, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- remove meta data
			meta[key] = nil
			-- remove key data
			self._keyData[key] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	for key in pairs(oldInputPairs) do
		if newInputPairs[key] == nil then
			-- remove key/value pair in old input table
			oldInputPairs[key] = nil

			-- remove old key map
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs<KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs<KI, VI, KO, VO, M>
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = forPairsCleanup :: (KO, VO, M?) -> ()
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="81">
                  <Properties>
                    <string name="Name">ForValues</string>
                    <string name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForValues state object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

    Additionally, a `meta` table/value can optionally be returned to pass data created
    when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

local function forValuesCleanup(keyOut: any, meta: any?)
	cleanup(keyOut)

	if meta then
		cleanup(meta)
	end
end

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
    used in the processor callback during value generation, and save the new value
    to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
    the same value multiple times and this will function will update them as little as
    possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputValues = self._inputTable
	local newValueCache = self._oldValueCache -- _oldValueCache and _valueCache get swapped and cleared below
	local oldValueCache = self._valueCache
	local dependenciesCaptured = {} -- we use this to cache dependency checks/captures
	local outputValues = {}
	local meta = self._meta

	if inputIsState then
		inputValues = inputValues:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- swap caches and clear out the old value cache
	self._oldValueCache, self._valueCache = oldValueCache, newValueCache
	table.clear(newValueCache)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- STEP 1: find values that changed or were not previously present
	for _key, inValue in pairs(inputValues) do
		local cachedValue = oldValueCache[inValue]
		local newCachedValue = newValueCache[inValue]
		local shouldRecalculate = cachedValue == nil

		-- get value data
		local valueData = self._valueData[inValue]
		if valueData == nil then
			valueData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._valueData[inValue] = valueData
		end

		-- if we already cached a new constant (non-table) value on this run-through,
		-- then we can just re-use that as the cached value
		if newCachedValue ~= nil and type(newCachedValue) ~= "table" then
			cachedValue = newCachedValue
			shouldRecalculate = false

			-- check inputValue dependencies if we have a cached value
			-- if we don't have a cached value, then there's no point in checking dependencies
			-- we also verify that we haven't already captured the dependencies for this inValue
			-- since if we have, then we don't need to recalculate and can skip this step
		elseif not shouldRecalculate and dependenciesCaptured[inValue] == nil then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end

			--[[
                If the dependencies have changed then:
                    1: clean up cached value(s), because they are no longer any good
                    2: Swap the old/new dependencies

                This also makes the cached value 'nil', which fits
            ]]
			if shouldRecalculate then
				-- step 1: clean up cached value(s), because they are no longer any good
				-- this also tells future runs to calculate a fresh output value
				cachedValue = if type(cachedValue) == "table" then cachedValue else {cachedValue}

				for _, outputValue in ipairs(cachedValue) do
					-- clean up the old calculated value
					local oldMetaValue = meta[outputValue]
					local destructOK, err = xpcall(self._destructor, parseError, outputValue, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end

					-- remove stored value data
					meta[outputValue] = nil
				end

				-- step 2: swap the old/new dependencies; clean out the new dependency set so we get a fresh start
				valueData.oldDependencySet, valueData.dependencySet =
					valueData.dependencySet, valueData.oldDependencySet
				table.clear(valueData.dependencySet)

				-- step 3: remove stored cached value
				oldValueCache[inValue] = nil
				cachedValue = nil
			else
				-- inform future runs that we already checked this inValue's dependencies,
				-- and that we don't need to re-capture dependencies
				dependenciesCaptured[inValue] = true
			end
		end

		-- if we still don't need to recalculate, then we can re-use a cached value
		-- if there are no cached values, then set recalculate to true and
		-- calculate a new value
		if not shouldRecalculate then
			-- if we're using a table, then try to pull a value from the cache
			if type(cachedValue) == "table" then
				local cachedValues = cachedValue
				local cachedValuesSize = #cachedValues

				if cachedValuesSize > 0 then
					cachedValue = cachedValues[cachedValuesSize]
					table.remove(cachedValues, cachedValuesSize)
				else
					cachedValue = nil
					shouldRecalculate = true
				end
			end
		end

		-- if we should recalculate the output by this point, do that
		if shouldRecalculate then
			local processOK, newOutValue, newMetaValue

			-- if we already captured the dependencies for this inValue, we don't need to do it again
			if dependenciesCaptured[inValue] then
				processOK, newOutValue, newMetaValue = pcall(self._processor, inValue)

				-- otherwise, we need to capture the dependencies
			else
				processOK, newOutValue, newMetaValue = captureDependencies(
					valueData.dependencySet,
					self._processor,
					inValue
				)
			end

			if processOK then
				-- prepare the value to be cached
				cachedValue = newOutValue
				-- store meta value, since we don't touch that when reusing values
				meta[newOutValue] = newMetaValue
				-- inform future runs that we already captured the dependencies
				dependenciesCaptured[inValue] = true

				didChange = true
			else
				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end

		-- if we successfully created a new value or found a value to reuse,
		-- cache it and update the stored data
		if cachedValue ~= nil then
			-- we store tables and objects in an array of cached objects, since they need to be unique
			if type(cachedValue) == "userdata" or type(cachedValue) == "table" then
				local cachedValues = newValueCache[inValue]
				if not cachedValues then
					cachedValues = {}
					newValueCache[inValue] = cachedValues
				end

				table.insert(cachedValues, cachedValue)
			else
				newValueCache[inValue] = cachedValue
			end

			-- store the value in the output with the same key
			outputValues[_key] = cachedValue
		end
	end

	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for oldInValue, oldCachedValue in pairs(oldValueCache) do
		if type(oldCachedValue) == "table" then
			-- clean up any remaining cached values
			for _, cachedValue in ipairs(oldCachedValue) do
				local oldMetaValue = meta[cachedValue]
				local destructOK, err = xpcall(self._destructor, parseError, cachedValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forValuesDestructorError", err)
				end

				-- remove stored value data
				meta[cachedValue] = nil

				-- if we removed a value, then we did change
				didChange = true
			end
		elseif newValueCache[oldInValue] ~= oldCachedValue then
			-- clean up the old calculated value
			local oldMetaValue = meta[oldCachedValue]
			local destructOK, err = xpcall(self._destructor, parseError, oldCachedValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			-- remove stored value data
			meta[oldCachedValue] = nil

			-- if we removed a value, then we did change
			didChange = true
		end
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues<VI, VO, M>(
	inputTable: PubTypes.CanBeState<{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues<VI, VO, M>
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = forValuesCleanup :: (VO, M?) -> ()
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
		_valueData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="82">
                  <Properties>
                    <string name="Name">Observer</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set&lt;T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set&lt;Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value&lt;any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="83">
                  <Properties>
                    <string name="Name">Value</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	-- if the value hasn't changed, no need to perform extra work here
	if isSimilar(self.value, newValue) and not force then
		return
	end

	self._value = newValue

	-- update any derived state objects if necessary
	updateAll(self)
end

local function Value&lt;T>(initialValue: T): Types.State&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="84">
                  <Properties>
                    <string name="Name">unwrap</string>
                    <string name="Source">--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap&lt;T>(item: PubTypes.CanBeState&lt;T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject&lt;T>):get(useDependency) else (item :: T)
end

return unwrap</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="85">
                <Properties>
                  <string name="Name">Types</string>
                  <string name="Source">--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol &amp; {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State&lt;T> = PubTypes.Value&lt;T> &amp; {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = PubTypes.Computed&lt;T> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KI, VI, KO, VO, M> = PubTypes.ForPairs&lt;KO, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KI, KO, M> = PubTypes.ForKeys&lt;KO, any> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;VI, VO, M> = PubTypes.ForValues&lt;any, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = PubTypes.Tween&lt;T> &amp; {
	_goalState: State&lt;T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = PubTypes.Spring&lt;T> &amp; {
	_speed: PubTypes.CanBeState&lt;number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState&lt;number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State&lt;T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer &amp; {
	_changeListeners: Set&lt;() -> ()>,
	_numChangeListeners: number
}

return nil</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="86">
                <Properties>
                  <string name="Name">Utility</string>
                </Properties>
                <Item class="ModuleScript" referent="87">
                  <Properties>
                    <string name="Name">None</string>
                    <string name="Source">--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="88">
                  <Properties>
                    <string name="Name">cleanup</string>
                    <string name="Source">--!strict

--[[
	Cleans up the task passed in as the argument.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanup(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanup(subtask)
			end
		end
	end
end

return cleanup</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="89">
                  <Properties>
                    <string name="Name">isSimilar</string>
                    <string name="Source">--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="90">
                  <Properties>
                    <string name="Name">restrictRead</string>
                    <string name="Source">--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="91">
                  <Properties>
                    <string name="Name">xtypeof</string>
                    <string name="Source">--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof</string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="92">
            <Properties>
              <string name="Name">lightning-beams</string>
            </Properties>
            <Item class="Folder" referent="93">
              <Properties>
                <string name="Name">src</string>
              </Properties>
              <Item class="ModuleScript" referent="94">
                <Properties>
                  <string name="Name">LightningBolt</string>
                  <string name="Source"><![CDATA[--[[
	Procedural Lightning Effect Module. By Quasiduck
	License: https://github.com/SamyBlue/Lightning-Beams/blob/main/LICENSE
	See README for guide on how to use or scroll down to see all properties in LightningBolt.new
	All properties update in real-time except PartCount which requires a new LightningBolt to change
	i.e. You can change a property at any time after a LightningBolt instance is created and it will still update the look of the bolt
--]]

local PARTS_IN_CACHE = 1000 --Recommend setting higher if you intend to use LightningSparks
local clock = os.clock
local workspace, RunService = game:GetService("Workspace"), game:GetService("RunService")
local parent = workspace.Terrain

--*Part Cache Setup
--New parts automatically get added to cache if more parts are requested for use where a warning is thrown

local BoltPart = Instance.new("Part") --Template primitive that will make up the entire bolt
BoltPart.TopSurface, BoltPart.BottomSurface = 0, 0
BoltPart.Anchored, BoltPart.CanCollide = true, false
BoltPart.Locked, BoltPart.CastShadow = true, false
BoltPart.CanTouch, BoltPart.CanQuery = false, false
BoltPart.Shape = "Cylinder"
BoltPart.Name = "BoltPart"
BoltPart.Material = Enum.Material.Neon
BoltPart.Color = Color3.new(1, 1, 1)
BoltPart.Transparency = 1

local PartCache = require(script.Parent.PartCache:WaitForChild("PartCache"))
local LightningCache = PartCache.new(BoltPart, PARTS_IN_CACHE)
LightningCache:SetCacheParent(parent)

--*

local function CubicBezier(PercentAlongBolt, p0, p1, p2, p3)
	return p0 * (1 - PercentAlongBolt) ^ 3
		+ p1 * 3 * PercentAlongBolt * (1 - PercentAlongBolt) ^ 2
		+ p2 * 3 * (1 - PercentAlongBolt) * PercentAlongBolt ^ 2
		+ p3 * PercentAlongBolt ^ 3
end

local function DiscretePulse(PercentAlongBolt, TimePassed, s, k, f, min, max) --See https://www.desmos.com/calculator/hg5h4fpfim for demonstration
	return math.clamp(k / (2 * f) - math.abs((PercentAlongBolt - TimePassed * s + 0.5 * k) / f), min, max)
end

local function ExtrudeCenter(PercentAlongBolt)
	return math.exp(-5000 * (PercentAlongBolt - 0.5) ^ 10)
end

local function NoiseBetween(x, y, z, min, max)
	return min + (max - min) * (math.noise(x, y, z) + 0.5)
end

local xInverse = CFrame.lookAt(Vector3.new(), Vector3.new(1, 0, 0)):inverse()
local offsetAngle = math.cos(math.rad(90))

local ActiveBranches = {} --Contains all LightningBolt instances

local LightningBolt = {} --Define new class
LightningBolt.__type = "LightningBolt"
LightningBolt.__index = LightningBolt

--Small tip: You don't need to use actual Roblox Attachments below. You can also create "fake" ones as follows:
--[[
	local A1, A2 = {}, {}
	A1.WorldPosition, A1.WorldAxis = chosenPos1, chosenAxis1
	A2.WorldPosition, A2.WorldAxis = chosenPos2, chosenAxis2
	local NewBolt = LightningBolt.new(A1, A2, 40)
--]]

function LightningBolt.new(Attachment0, Attachment1, PartCount)
	local self = setmetatable({}, LightningBolt)
	PartCount = PartCount or 30

	--*Main (default) Properties--

	--Bolt Appearance Properties

	self.Enabled = true --Hides bolt without removing any parts when false
	self.Attachment0, self.Attachment1 = Attachment0, Attachment1 --Bolt originates from Attachment0 and ends at Attachment1
	self.CurveSize0, self.CurveSize1 = 0, 0 --Works similarly to roblox beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png
	self.MinRadius, self.MaxRadius = 0, 2.4 --Governs the amplitude of fluctuations throughout the bolt
	self.Frequency = 1 --Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning
	self.AnimationSpeed = 7 --Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)
	self.Thickness = 1 --The thickness of the bolt
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = 0.2, 1 --Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt

	--Bolt Kinetic Properties

	--[[
		Allows for fading in (or out) of the bolt with time. Can also create a "projectile" bolt
		Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)
		Works by passing a "wave" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)
		See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties
	--]]
	self.MinTransparency, self.MaxTransparency = 0, 1
	self.PulseSpeed = 2 --Bolt arrives at Attachment1 1/PulseSpeed seconds later
	self.PulseLength = 1000000
	self.FadeLength = 0.2
	self.ContractFrom = 0.5 --Parts shorten or grow once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441

	--Bolt Color Properties

	self.Color = Color3.new(1, 1, 1) --Can be a Color3 or ColorSequence
	self.ColorOffsetSpeed = 3 --Sets speed at which ColorSequence travels along Bolt

	--*

	--*Advanced Properties--

	--[[
		Allows you to pass a custom space curve for the bolt to be defined along
		Constraints: 
			-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
		Example: self.SpaceCurveFunction = VivianiCurve(PercentAlongBolt)
	--]]
	self.SpaceCurveFunction = CubicBezier

	--[[
		Allows you to pass a custom opacity profile which controls the opacity along the bolt
		Constraints: 
			-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
			-Second input passed must be a parameter representing TimePassed since instantiation 
		Example: self.OpacityProfileFunction = MovingSineWave(PercentAlongBolt, TimePassed)
		Note: You may want to set self.ContractFrom to a value above 1 if you pass a custom opacity profile as contraction was designed to work with DiscretePulse
	--]]
	self.OpacityProfileFunction = DiscretePulse

	--[[
		Allows you to pass a custom radial profile which controls the radius of control points along the bolt
		Constraints: 
			-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
	--]]
	self.RadialProfileFunction = ExtrudeCenter
	--*

	--! Private vars are prefixed with an underscore (e.g. self._Parts) and should not be changed manually

	self._Parts = {} --The BoltParts which make up the Bolt

	for i = 1, PartCount do
		self._Parts[i] = LightningCache:GetPart()
	end

	self._PartsHidden = false
	self._DisabledTransparency = 1
	self._StartT = clock()
	self._RanNum = math.random() * 100
	self._RefIndex = #ActiveBranches + 1

	ActiveBranches[self._RefIndex] = self

	return self
end

function LightningBolt:Destroy()
	ActiveBranches[self._RefIndex] = nil

	for i = 1, #self._Parts do
		LightningCache:ReturnPart(self._Parts[i])
	end

	self = nil
end

--Calls Destroy() after TimeLength seconds where a dissipating effect takes place in the meantime
function LightningBolt:DestroyDissipate(TimeLength, Strength)
	TimeLength = TimeLength or 0.2
	Strength = Strength or 0.5
	local DissipateStartT = clock()
	local start, mid, goal = self.MinTransparency, self.ContractFrom, self.ContractFrom
		+ 1 / (#self._Parts * self.FadeLength)
	local StartRadius = self.MaxRadius
	local StartMinThick = self.MinThicknessMultiplier
	local DissipateLoop

	DissipateLoop = RunService.Heartbeat:Connect(function()
		local TimeSinceDissipate = clock() - DissipateStartT
		self.MinThicknessMultiplier = StartMinThick + (-2 - StartMinThick) * TimeSinceDissipate / TimeLength

		if TimeSinceDissipate < TimeLength * 0.4 then
			local interp = (TimeSinceDissipate / (TimeLength * 0.4))
			self.MinTransparency = start + (mid - start) * interp
		elseif TimeSinceDissipate < TimeLength then
			local interp = ((TimeSinceDissipate - TimeLength * 0.4) / (TimeLength * 0.6))
			self.MinTransparency = mid + (goal - mid) * interp
			self.MaxRadius = StartRadius * (1 + Strength * interp)
			self.MinRadius = self.MinRadius + (self.MaxRadius - self.MinRadius) * interp
		else
			--Destroy Bolt
			local TimePassed = clock() - self._StartT
			local Lifetime = (self.PulseLength + 1) / self.PulseSpeed

			if TimePassed < Lifetime then --prevents Destroy()ing twice
				self:Destroy()
			end

			--Disconnect Loop
			DissipateLoop:Disconnect()
			DissipateLoop = nil
		end
	end)
end

function LightningBolt:_UpdateGeometry(
	BPart,
	PercentAlongBolt,
	TimePassed,
	ThicknessNoiseMultiplier,
	PrevPoint,
	NextPoint
)
	--Compute opacity for this particular section
	local MinOpa, MaxOpa = 1 - self.MaxTransparency, 1 - self.MinTransparency
	local Opacity = self.OpacityProfileFunction(
		PercentAlongBolt,
		TimePassed,
		self.PulseSpeed,
		self.PulseLength,
		self.FadeLength,
		MinOpa,
		MaxOpa
	)

	--Compute thickness for this particular section
	local Thickness = self.Thickness * ThicknessNoiseMultiplier * Opacity
	Opacity = Thickness > 0 and Opacity or 0

	--Compute + update sizing and orientation of this particular section
	local contractf = 1 - self.ContractFrom
	local PartsN = #self._Parts
	if Opacity > contractf then
		BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, Thickness, Thickness)
		BPart.CFrame = CFrame.lookAt((PrevPoint + NextPoint) * 0.5, NextPoint) * xInverse
		BPart.Transparency = 1 - Opacity
	elseif Opacity > contractf - 1 / (PartsN * self.FadeLength) then
		local interp = (1 - (Opacity - (contractf - 1 / (PartsN * self.FadeLength))) * PartsN * self.FadeLength)
			* (PercentAlongBolt < TimePassed * self.PulseSpeed - 0.5 * self.PulseLength and 1 or -1)
		BPart.Size = Vector3.new((1 - math.abs(interp)) * (NextPoint - PrevPoint).Magnitude, Thickness, Thickness)
		BPart.CFrame = CFrame.lookAt(
				PrevPoint + (NextPoint - PrevPoint) * (math.max(0, interp) + 0.5 * (1 - math.abs(interp))),
				NextPoint
			)
			* xInverse
		BPart.Transparency = 1 - Opacity
	else
		BPart.Transparency = 1
	end
end

function LightningBolt:_UpdateColor(BPart, PercentAlongBolt, TimePassed)
	if typeof(self.Color) == "Color3" then
		BPart.Color = self.Color
	else --ColorSequence
		local t1 = (self._RanNum + PercentAlongBolt - TimePassed * self.ColorOffsetSpeed) % 1
		local keypoints = self.Color.Keypoints
		for i = 1, #keypoints - 1 do
			if keypoints[i].Time < t1 and t1 < keypoints[i + 1].Time then
				BPart.Color = keypoints[i].Value:lerp(
					keypoints[i + 1].Value,
					(t1 - keypoints[i].Time) / (keypoints[i + 1].Time - keypoints[i].Time)
				)
				break
			end
		end
	end
end

function LightningBolt:_Disable()
	self.Enabled = false
	for _, BPart in ipairs(self._Parts) do
		BPart.Transparency = self._DisabledTransparency
	end
end

RunService.Heartbeat:Connect(function()
	debug.profilebegin("LightningBolt") --Create performance profile

	for _, ThisBranch in pairs(ActiveBranches) do
		if ThisBranch.Enabled == true then
			ThisBranch._PartsHidden = false

			--Extract important variables
			local MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius
			local Parts = ThisBranch._Parts
			local PartsN = #Parts
			local RanNum = ThisBranch._RanNum
			local spd = ThisBranch.AnimationSpeed
			local freq = ThisBranch.Frequency
			local MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier
			local TimePassed = clock() - ThisBranch._StartT
			local SpaceCurveFunction, RadialProfileFunction =
				ThisBranch.SpaceCurveFunction, ThisBranch.RadialProfileFunction
			local Lifetime = (ThisBranch.PulseLength + 1) / ThisBranch.PulseSpeed

			--Extract control points
			local a0, a1, CurveSize0, CurveSize1 =
				ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1
			local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition
				+ a0.WorldAxis * CurveSize0, a1.WorldPosition
				- a1.WorldAxis * CurveSize1, a1.WorldPosition

			--Initialise iterative scheme for generating points along space curve
			local init = SpaceCurveFunction(0, p0, p1, p2, p3)
			local PrevPoint, bezier0 = init, init

			--Update
			if TimePassed < Lifetime then
				for i = 1, PartsN do
					local BPart = Parts[i]
					local PercentAlongBolt = i / PartsN

					--Compute noisy inputs
					local input, input2 = (spd * -TimePassed)
						+ freq * 10 * PercentAlongBolt
						- 0.2
						+ RanNum * 4, 5 * ((spd * 0.01 * -TimePassed) / 10 + freq * PercentAlongBolt)
						+ RanNum * 4
					local noise0 = NoiseBetween(5 * input, 1.5, 5 * 0.2 * input2, 0, 0.1 * 2 * math.pi)
						+ NoiseBetween(0.5 * input, 1.5, 0.5 * 0.2 * input2, 0, 0.9 * 2 * math.pi)
					local noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)
						* RadialProfileFunction(PercentAlongBolt)
					local thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)

					--Find next point along space curve
					local bezier1 = SpaceCurveFunction(PercentAlongBolt, p0, p1, p2, p3)

					--Find next point along bolt
					local NextPoint = i ~= PartsN
							and (CFrame.new(bezier0, bezier1) * CFrame.Angles(0, 0, noise0) * CFrame.Angles(
							math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)),
							0,
							0
						) * CFrame.new(0, 0, -noise1)).Position
						or bezier1

					ThisBranch:_UpdateGeometry(BPart, PercentAlongBolt, TimePassed, thicknessNoise, PrevPoint, NextPoint)

					ThisBranch:_UpdateColor(BPart, PercentAlongBolt, TimePassed)

					PrevPoint, bezier0 = NextPoint, bezier1
				end
			else
				ThisBranch:Destroy()
			end
		else --Enabled = false
			if ThisBranch._PartsHidden == false then
				ThisBranch._PartsHidden = true
				ThisBranch:_Disable()
			end
		end
	end

	debug.profileend()
end)

return LightningBolt
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="95">
                <Properties>
                  <string name="Name">PartCache</string>
                </Properties>
                <Item class="ModuleScript" referent="96">
                  <Properties>
                    <string name="Name">PartCache</string>
                    <string name="Source"><![CDATA[

--[[
	PartCache V4.0 by Xan the Dragon // Eti the Spirit -- RBX 18406183
	Update V4.0 has added Luau Strong Type Enforcement.
	
	Creating parts is laggy, especially if they are supposed to be there for a split second and/or need to be made frequently.
	This module aims to resolve this lag by pre-creating the parts and CFraming them to a location far away and out of sight.
	When necessary, the user can get one of these parts and CFrame it to where they need, then return it to the cache when they are done with it.
	
	According to someone instrumental in Roblox's backend technology, zeuxcg (https://devforum.roblox.com/u/zeuxcg/summary)...
		>> CFrame is currently the only "fast" property in that you can change it every frame without really heavy code kicking in. Everything else is expensive.
		
		- https://devforum.roblox.com/t/event-that-fires-when-rendering-finishes/32954/19
	
	This alone should ensure the speed granted by this module.
		
		
	HOW TO USE THIS MODULE:
	
	Look at the bottom of my thread for an API! https://devforum.roblox.com/t/partcache-for-all-your-quick-part-creation-needs/246641
--]]
local table = require(script.Parent:WaitForChild("Table"))

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local PartCacheStatic = {}
PartCacheStatic.__index = PartCacheStatic
PartCacheStatic.__type = "PartCache" -- For compatibility with TypeMarshaller

-- TYPE DEFINITION: Part Cache Instance
export type PartCache = {
	Open: {[number]: BasePart},
	InUse: {[number]: BasePart},
	CurrentCacheParent: Instance,
	Template: BasePart,
	ExpansionSize: number
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------					

-- A CFrame that's really far away. Ideally. You are free to change this as needed.
local CF_REALLY_FAR_AWAY = CFrame.new(0, 10e8, 0)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
--local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

--Similar to assert but warns instead of errors.
local function assertwarn(requirement: boolean, messageIfNotMet: string)
	if requirement == false then
		warn(messageIfNotMet)
	end
end

--Dupes a part from the template.
local function MakeFromTemplate(template: BasePart, currentCacheParent: Instance): BasePart
	local part: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.
	
	part.CFrame = CF_REALLY_FAR_AWAY
	part.Anchored = true
	part.Parent = currentCacheParent
	return part
end

function PartCacheStatic.new(template: BasePart, numPrecreatedParts: number?, currentCacheParent: Instance?): PartCache
	local newNumPrecreatedParts: number = numPrecreatedParts or 5
	local newCurrentCacheParent: Instance = currentCacheParent or workspace
	
	--PrecreatedParts value.
	--Same thing. Ensure it's a number, ensure it's not negative, warn if it's really huge or 0.
	assert(numPrecreatedParts > 0, "PrecreatedParts can not be negative!")
	assertwarn(numPrecreatedParts ~= 0, "PrecreatedParts is 0! This may have adverse effects when initially using the cache.")
	assertwarn(template.Archivable, "The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true.")
	
	local oldArchivable = template.Archivable
	template.Archivable = true
	local newTemplate: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.
	
	template.Archivable = oldArchivable
	template = newTemplate
	
	local object: PartCache = {
		Open = {},
		InUse = {},
		CurrentCacheParent = newCurrentCacheParent,
		Template = template,
		ExpansionSize = 10
	}
	setmetatable(object, PartCacheStatic)
	
	-- Below: Ignore type mismatch nil | number and the nil | Instance mismatch on the table.insert line.
	for _ = 1, newNumPrecreatedParts do
		table.insert(object.Open, MakeFromTemplate(template, object.CurrentCacheParent))
	end
	object.Template.Parent = nil
	
	return object
	-- ^ Ignore mismatch here too
end

-- Gets a part from the cache, or creates one if no more are available.
function PartCacheStatic:GetPart(): BasePart
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("GetPart", "PartCache.new"))
	
	if #self.Open == 0 then
		warn("No parts available in the cache! Creating [" .. self.ExpansionSize .. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of " .. tostring(#self.Open + #self.InUse + self.ExpansionSize) .. " parts.)")
		for _ = 1, self.ExpansionSize, 1 do
			table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
		end
	end
	local part = self.Open[#self.Open]
	self.Open[#self.Open] = nil
	table.insert(self.InUse, part)
	return part
end

-- Returns a part to the cache.
function PartCacheStatic:ReturnPart(part: BasePart)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("ReturnPart", "PartCache.new"))
	
	local index = table.indexOf(self.InUse, part)
	if index ~= nil then
		table.remove(self.InUse, index)
		table.insert(self.Open, part)
		part.CFrame = CF_REALLY_FAR_AWAY
		part.Anchored = true
	else
		error("Attempted to return part \"" .. part.Name .. "\" (" .. part:GetFullName() .. ") to the cache, but it's not in-use! Did you call this on the wrong part?")
	end
end

-- Sets the parent of all cached parts.
function PartCacheStatic:SetCacheParent(newParent: Instance)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("SetCacheParent", "PartCache.new"))
	assert(newParent:IsDescendantOf(workspace) or newParent == workspace, "Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world.")
	
	self.CurrentCacheParent = newParent
	for i = 1, #self.Open do
		self.Open[i].Parent = newParent
	end
	for i = 1, #self.InUse do
		self.InUse[i].Parent = newParent
	end
end

-- Adds numParts more parts to the cache.
function PartCacheStatic:Expand(numParts: number): ()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Expand", "PartCache.new"))
	if numParts == nil then
		numParts = self.ExpansionSize
	end
	
	for _ = 1, numParts do
		table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
	end
end

-- Destroys this cache entirely. Use this when you don't need this cache object anymore.
function PartCacheStatic:Dispose()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Dispose", "PartCache.new"))
	for i = 1, #self.Open do
		self.Open[i]:Destroy()
	end
	for i = 1, #self.InUse do
		self.InUse[i]:Destroy()
	end
	self.Template:Destroy()
	self.Open = {}
	self.InUse = {}
	self.CurrentCacheParent = nil
	
	self.GetPart = nil
	self.ReturnPart = nil
	self.SetCacheParent = nil
	self.Expand = nil
	self.Dispose = nil
end

return PartCacheStatic]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="97">
                  <Properties>
                    <string name="Name">Table</string>
                    <string name="Source">--!nocheck
--^ It works. Just get the type checker to shut up so that people don't send bug reports :P

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local Table = {}

for index, value in pairs(table) do
	Table[index] = value
end

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	--local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Allocates a new table by getting the length of the current table and increasing its capacity by the specified amount.
-- This uses Roblox's table.create function.
Table.expand = function (tbl, byAmount)
	if byAmount &lt; 0 then
		error("Cannot expand a table by a negative amount of objects.")
	end
	
	local newtbl = table.create(#tbl + byAmount)
	for i = 1, #tbl do
		newtbl[i] = tbl[i]
	end
	return newtbl
end

return Table</string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="98">
            <Properties>
              <string name="Name">maid</string>
            </Properties>
            <Item class="ModuleScript" referent="99">
              <Properties>
                <string name="Name">Maid</string>
                <string name="Source">---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = {}

	self._tasks = {}

	return setmetatable(self, Maid)
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if typeof(task) == "RBXScriptConnection" then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		if type(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif task.Destroy then
			task:Destroy()
		end
		index, task = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="100">
            <Properties>
              <string name="Name">matter</string>
            </Properties>
            <Item class="ModuleScript" referent="101">
              <Properties>
                <string name="Name">lib</string>
                <string name="Source"><![CDATA[--[=[
	@class Matter

	Matter. It's what everything is made out of.
]=]

--[=[
	@within Matter
	@prop World World
]=]

--[=[
	@within Matter
	@prop Loop Loop
]=]

--[=[
	@within Matter
	@prop Debugger Debugger
]=]

--[=[
	@within Matter
	@prop None None

	A value should be interpreted as nil when merging dictionaries.

	`Matter.None` is used by [`Component:patch`](/api/Component#patch).
]=]

--[=[
	@within Matter
	@function component
	@param name? string -- Optional name for debugging purposes
	@param defaultData? {} -- Default data that will be merged with data passed to the component when created
	@return Component -- Your new type of component

	Creates a new type of component. Call the component as a function to create an instance of that component.

	If `defaultData` is specified, it will be merged with data passed to the component when the component instance is
	created. Note that this is not *fallback* data: if you later remove a field from a component instance that is
	specified in the default data, it won't fall back to the value specified in default data.

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})
	```
]=]

local immutable = require(script.immutable)
local World = require(script.World)
local Loop = require(script.Loop)
local newComponent = require(script.component).newComponent
local topoRuntime = require(script.topoRuntime)

export type World = typeof(World.new())
export type Loop = typeof(Loop.new())

return {
	World = World,
	Loop = Loop,

	component = newComponent,

	useEvent = require(script.hooks.useEvent),
	useDeltaTime = require(script.hooks.useDeltaTime),
	useThrottle = require(script.hooks.useThrottle),
	log = require(script.hooks.log),
	useHookState = topoRuntime.useHookState,
	useCurrentSystem = topoRuntime.useCurrentSystem,

	merge = immutable.merge,
	None = immutable.None,

	Debugger = require(script.debugger.debugger),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="102">
                <Properties>
                  <string name="Name">Loop</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local topoRuntime = require(script.Parent.topoRuntime)
local rollingAverage = require(script.Parent.rollingAverage)

local recentErrors = {}
local recentErrorLastTime = 0

local function systemFn(system: System)
	if type(system) == "table" then
		return system.system
	end

	return system
end

local function systemName(system: System)
	local fn = systemFn(system)
	return debug.info(fn, "s") .. "->" .. debug.info(fn, "n")
end

local function systemPriority(system: System)
	if type(system) == "table" then
		return system.priority or 0
	end

	return 0
end

--[=[
	@class Loop

	The Loop class handles scheduling and *looping* (who would have guessed) over all of your game systems.

	:::caution Yielding
	Yielding is not allowed in systems. Doing so will result in the system thread being closed early, but it will not
	affect other systems.
	:::
]=]
local Loop = {}
Loop.__index = Loop

--[=[
	Creates a new loop. `Loop.new` accepts as arguments the values that will be passed to all of your systems.

	So typically, you want to pass the World in here, as well as maybe a table of global game state.

	```lua
	local world = World.new()
	local gameState = {}

	local loop = Loop.new(world, gameState)
	```

	@param ... ...any -- Values that will be passed to all of your systems
	@return Loop
]=]
function Loop.new(...)
	return setmetatable({
		_systems = {},
		_skipSystems = {},
		_orderedSystemsByEvent = {},
		_state = { ... },
		_stateLength = select("#", ...),
		_systemState = {},
		_middlewares = {},
		_systemErrors = {},
		_systemLogs = {},
		profiling = nil,
		trackErrors = false,
	}, Loop)
end

--[=[
	@within Loop
	@type System SystemTable | (...any) -> ()

	Either a plain function or a table defining the system.
]=]

--[=[
	@within Loop
	@interface SystemTable
	.system (...any) -> () -- The system function
	.event? string -- The event the system runs on. A string, a key from the table you pass to `Loop:begin`.
	.priority? number -- Priority influences the position in the frame the system is scheduled to run at.
	.after? {System} -- A list of systems that this system must run after.

	A table defining a system with possible options.

	Systems are scheduled in order of `priority`, meaning lower `priority` runs first.
	The default priority is `0`.
]=]

type System = (...any) -> () | { system: (...any) -> (), event: string?, priority: number?, after: nil | {} }

--[=[
	Schedules a set of systems based on the constraints they define.

	Systems may optionally declare:
	- The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat)
	- A numerical priority value
	- Other systems that they must run *after*

	If systems do not specify an event, they will run on the `default` event.

	Systems that share an event will run in order of their priority, which means that systems with a lower `priority`
	value run first. The default priority is `0`.

	Systems that have defined what systems they run `after` can only be scheduled after all systems they depend on have
	already been scheduled.

	All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems
	will always run in the same order across machines.

	:::info
	It is possible for your systems to be in an unresolvable state. In which case, `scheduleSystems` will error.
	This can happen when your systems have circular or unresolvable dependency chains.

	If a system has both a `priority` and defines systems it runs `after`, the system can only be scheduled if all of
	the systems it depends on have a lower or equal priority.

	Systems can never depend on systems that run on other events, because it is not guaranteed or required that events
	will fire every frame or will always fire in the same order.
	:::

	:::caution
	`scheduleSystems` has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple
	times if possible.
	:::

	@param systems { System } -- Array of systems to schedule.
]=]
function Loop:scheduleSystems(systems: { System })
	for _, system in ipairs(systems) do
		self._systems[system] = system
		self._systemState[system] = {}

		if RunService:IsStudio() then
			-- In Studio, we start logging immediately.
			self._systemLogs[system] = {}
		end
	end

	self:_sortSystems()
end

--[=[
	Schedules a single system. This is an expensive function to call multiple times. Instead, try batch scheduling
	systems with [Loop:scheduleSystems] if possible.

	@param system System
]=]
function Loop:scheduleSystem(system: System)
	return self:scheduleSystems({ system })
end

--[=[
	Removes a previously-scheduled system from the Loop. Evicting a system also cleans up any storage from hooks.
	This is intended to be used for hot reloading. Dynamically loading and unloading systems for gameplay logic
	is not recommended.

	@param system System
]=]
function Loop:evictSystem(system: System)
	if self._systems[system] == nil then
		error("Can't evict system because it doesn't exist")
	end

	self._systems[system] = nil
	self._systemErrors[system] = nil

	topoRuntime.start({
		system = self._systemState[system],
	}, function() end)

	self._systemState[system] = nil
	self._systemLogs[system] = nil

	self:_sortSystems()
end

--[=[
	Replaces an older version of a system with a newer version of the system. Internal system storage (which is used
	by hooks) will be moved to be associated with the new system. This is intended to be used for hot reloading.

	@param old System
	@param new System
]=]
function Loop:replaceSystem(old: System, new: System)
	if not self._systems[old] then
		error("Before system does not exist!")
	end

	self._systems[new] = new
	self._systems[old] = nil
	self._systemState[new] = self._systemState[old] or {}
	self._systemState[old] = nil

	if self._skipSystems[old] then
		self._skipSystems[old] = nil
		self._skipSystems[new] = true
	end

	for system in self._systems do
		if type(system) == "table" and system.after then
			local index = table.find(system.after, old)

			if index then
				system.after[index] = new
			end
		end
	end

	self:_sortSystems()
end

local function orderSystemsByDependencies(unscheduledSystems: { System })
	table.sort(unscheduledSystems, function(a, b)
		local priorityA = systemPriority(a)
		local priorityB = systemPriority(b)

		if priorityA == priorityB then
			return systemName(a) < systemName(b)
		end

		return priorityA < priorityB
	end)

	local scheduledSystemsSet = {}
	local scheduledSystems = {}
	local tombstone = {}

	while #scheduledSystems < #unscheduledSystems do
		local atLeastOneScheduled = false

		local index = 1
		local priority
		while index <= #unscheduledSystems do
			local system = unscheduledSystems[index]

			-- If the system has already been scheduled it will have been replaced with this value
			if system == tombstone then
				index += 1
				continue
			end

			if priority == nil then
				priority = systemPriority(system)
			elseif systemPriority(system) ~= priority then
				break
			end

			local allScheduled = true

			if type(system) == "table" and system.after then
				for _, dependency in ipairs(system.after) do
					if scheduledSystemsSet[dependency] == nil then
						allScheduled = false
						break
					end
				end
			end

			if allScheduled then
				atLeastOneScheduled = true

				unscheduledSystems[index] = tombstone

				scheduledSystemsSet[system] = system
				table.insert(scheduledSystems, system)
			end

			index += 1
		end

		if not atLeastOneScheduled then
			error("Unable to schedule systems given current requirements")
		end
	end

	return scheduledSystems
end

function Loop:_sortSystems()
	local systemsByEvent = {}

	for system in pairs(self._systems) do
		local eventName = "default"

		if type(system) == "table" and system.event then
			eventName = system.event
		end

		if not systemsByEvent[eventName] then
			systemsByEvent[eventName] = {}
		end

		table.insert(systemsByEvent[eventName], system)
	end

	self._orderedSystemsByEvent = {}

	for eventName, systems in pairs(systemsByEvent) do
		self._orderedSystemsByEvent[eventName] = orderSystemsByDependencies(systems)
	end
end

--[=[
	Connects to frame events and starts invoking your systems.

	Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names
	to define what event they run on. By default, systems run on an event named `"default"`. Custom events may be used
	if they have a `Connect` function.

	```lua
	loop:begin({
		default = RunService.Heartbeat,
		Heartbeat = RunService.Heartbeat,
		RenderStepped = RunService.RenderStepped,
		Stepped = RunService.Stepped,
	})
	```

	&nbsp;

	Returns a table similar to the one you passed in, but the values are `RBXScriptConnection` values (or whatever is
	returned by `:Connect` if you passed in a synthetic event).

	@param events {[string]: RBXScriptSignal} -- A map from event name to event objects.
	@return {[string]: RBXScriptConnection} -- A map from your event names to connection objects.
]=]
function Loop:begin(events)
	local connections = {}

	for eventName, event in pairs(events) do
		local lastTime = os.clock()
		local generation = false

		local function stepSystems()
			if not self._orderedSystemsByEvent[eventName] then
				-- Skip events that have no systems
				return
			end

			local currentTime = os.clock()
			local deltaTime = currentTime - lastTime
			lastTime = currentTime

			generation = not generation

			local dirtyWorlds = {}
			local profiling = self.profiling

			for _, system in ipairs(self._orderedSystemsByEvent[eventName]) do
				topoRuntime.start({
					system = self._systemState[system],
					frame = {
						generation = generation,
						deltaTime = deltaTime,
						dirtyWorlds = dirtyWorlds,
						logs = self._systemLogs[system],
					},
					currentSystem = system,
				}, function()
					if self._skipSystems[system] then
						if profiling then
							profiling[system] = nil
						end
						return
					end

					local fn = systemFn(system)
					debug.profilebegin("system: " .. systemName(system))

					local thread = coroutine.create(fn)

					local startTime = os.clock()
					local success, errorValue = coroutine.resume(thread, unpack(self._state, 1, self._stateLength))

					if profiling ~= nil then
						local duration = os.clock() - startTime

						if profiling[system] == nil then
							profiling[system] = {}
						end

						rollingAverage.addSample(profiling[system], duration)
					end

					if coroutine.status(thread) ~= "dead" then
						coroutine.close(thread)

						task.spawn(
							error,
							(
								"Matter: System %s yielded! Its thread has been closed. "
								.. "Yielding in systems is not allowed."
							):format(systemName(system))
						)
					end

					for world in dirtyWorlds do
						world:optimizeQueries()
					end
					table.clear(dirtyWorlds)

					if not success then
						if os.clock() - recentErrorLastTime > 10 then
							recentErrorLastTime = os.clock()
							recentErrors = {}
						end

						local errorString = systemName(system)
							.. ": "
							.. tostring(errorValue)
							.. "\n"
							.. debug.traceback(thread)

						if not recentErrors[errorString] then
							task.spawn(error, errorString)
							warn("Matter: The above error will be suppressed for the next 10 seconds")
							recentErrors[errorString] = true
						end

						if self.trackErrors then
							if self._systemErrors[system] == nil then
								self._systemErrors[system] = {}
							end

							local errorStorage = self._systemErrors[system]
							local lastError = errorStorage[#errorStorage]

							if lastError and lastError.error == errorString then
								lastError.when = os.time()
							else
								table.insert(errorStorage, {
									error = errorString,
									when = os.time(),
								})

								if #errorStorage > 100 then
									table.remove(errorStorage, 1)
								end
							end
						end
					end

					debug.profileend()
				end)
			end
		end

		for _, middleware in ipairs(self._middlewares) do
			stepSystems = middleware(stepSystems, eventName)

			if type(stepSystems) ~= "function" then
				error(
					("Middleware function %s:%s returned %s instead of a function"):format(
						debug.info(middleware, "s"),
						debug.info(middleware, "l"),
						typeof(stepSystems)
					)
				)
			end
		end

		connections[eventName] = event:Connect(stepSystems)
	end

	return connections
end

--[=[
	Adds a user-defined middleware function that is called during each frame.

	This allows you to run code before and after each frame, to perform initialization and cleanup work.

	```lua
	loop:addMiddleware(function(nextFn)
		return function()
			Plasma.start(plasmaNode, nextFn)
		end
	end)
	```

	You must pass `addMiddleware` a function that itself returns a function that invokes `nextFn` at some point.

	The outer function is invoked only once. The inner function is invoked during each frame event.

	:::info
	Middleware added later "wraps" middleware that was added earlier. The innermost middleware function is the internal
	function that actually calls your systems.
	:::
	@param middleware (nextFn: () -> (), eventName: string) -> () -> ()
]=]
function Loop:addMiddleware(middleware: (nextFn: () -> ()) -> () -> ())
	table.insert(self._middlewares, middleware)
end

return Loop
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="103">
                <Properties>
                  <string name="Name">Loop.spec</string>
                  <string name="Source"><![CDATA[local Loop = require(script.Parent.Loop)
local useHookState = require(script.Parent.topoRuntime).useHookState
local World = require(script.Parent.World)
local component = require(script.Parent).component
local BindableEvent = require(script.Parent.mock.BindableEvent)

local bindable = BindableEvent.new()

return function()
	describe("Loop", function()
		it("should call systems", function()
			local loop = Loop.new(1, 2, 3)

			local callCount = 0
			loop:scheduleSystem(function(a, b, c)
				callCount += 1

				expect(a).to.equal(1)
				expect(b).to.equal(2)
				expect(c).to.equal(3)
			end)

			local connection = loop:begin({ default = bindable.Event })

			expect(callCount).to.equal(0)
			bindable:Fire()
			expect(callCount).to.equal(1)
			connection.default:Disconnect()
			expect(callCount).to.equal(1)
		end)

		it("should allow evicting systems", function()
			local loop = Loop.new()

			local cleanedUp = false
			local function customHook()
				useHookState(nil, function()
					cleanedUp = true
				end)
			end

			local counts = {}
			local function system1()
				customHook()
				counts[1] = (counts[1] or 0) + 1
			end

			local function system2()
				counts[2] = (counts[2] or 0) + 1
			end

			loop:scheduleSystems({ system1, system2 })

			local bindable = BindableEvent.new()

			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(cleanedUp).to.equal(false)
			expect(counts[1]).to.equal(1)
			expect(counts[2]).to.equal(1)

			loop:evictSystem(system1)

			expect(cleanedUp).to.equal(true)

			bindable:Fire()

			expect(counts[1]).to.equal(1)
			expect(counts[2]).to.equal(2)
		end)

		it("should allow replacing systems", function()
			local state = {}
			local loop = Loop.new(state)

			local function sampleHook(value)
				local storage = useHookState()

				if value then
					storage.value = value
				end

				return storage.value
			end

			local function makeSystem(isFirst)
				return function(state)
					local param = if isFirst then "sample text" else nil
					local returnValue = sampleHook(param)

					if isFirst then
						state.foo = "one"
					else
						state.foo = returnValue
					end
				end
			end

			local system1 = makeSystem(true)
			local system2 = makeSystem(false)

			loop:scheduleSystem(system1)

			local bindable = BindableEvent.new()

			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(state.foo).to.equal("one")

			loop:replaceSystem(system1, system2)

			bindable:Fire()

			expect(state.foo).to.equal("sample text")
		end)

		it("should call systems in order", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
				after = {},
			}
			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
				after = { systemA },
			}
			local systemC = {
				system = function()
					table.insert(order, "c")
				end,
				after = { systemA, systemB },
			}

			loop:scheduleSystems({
				systemC,
				systemB,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(3)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")
			expect(order[3]).to.equal("c")

			connection.default:Disconnect()
		end)

		it("should call systems with priority in order", function()
			local loop = Loop.new()

			local order = {}

			local function cleanupStartReplication()
				table.insert(order, "e")
			end

			local function replicateEnemies()
				table.insert(order, "d")
			end

			local function spawnSwords()
				table.insert(order, "c")
			end

			local function spawnEnemies()
				table.insert(order, "b")
			end

			local function neutral()
				table.insert(order, "a")
			end

			loop:scheduleSystems({
				{
					system = spawnEnemies,
					priority = 0,
				},
				neutral,
				{
					system = replicateEnemies,
					priority = 100,
				},
				{
					system = spawnSwords,
					priority = 1,
				},
				{
					system = cleanupStartReplication,
					priority = 5000,
				},
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(5)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")
			expect(order[3]).to.equal("c")
			expect(order[4]).to.equal("d")
			expect(order[5]).to.equal("e")

			connection.default:Disconnect()
		end)

		it("should call middleware", function()
			local loop = Loop.new(1, 2, 3)

			local called = {}
			loop:addMiddleware(function(nextFn)
				return function()
					table.insert(called, 2)
					nextFn()
				end
			end)
			loop:addMiddleware(function(nextFn)
				return function()
					table.insert(called, 1)
					nextFn()
				end
			end)

			loop:scheduleSystem(function()
				table.insert(called, 3)
			end)

			loop:begin({ default = bindable.Event })

			expect(#called).to.equal(0)
			bindable:Fire()
			expect(#called).to.equal(3)
			expect(called[1]).to.equal(1)
			expect(called[2]).to.equal(2)
			expect(called[3]).to.equal(3)
		end)

		it("should optimize queries of worlds used inside it", function()
			local world = World.new()
			local loop = Loop.new(world)

			local A = component()

			world:spawn(A())

			loop:scheduleSystem(function(world)
				world:query(A)
			end)

			local bindable = BindableEvent.new()
			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(#world._storages).to.equal(1)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="104">
                <Properties>
                  <string name="Name">Queue</string>
                  <string name="Source"><![CDATA[local Queue = {}
Queue.__index = Queue

function Queue.new()
	return setmetatable({
		_head = nil,
		_tail = nil,
	}, Queue)
end

function Queue:pushBack(value)
	local entry = {
		value = value,
		next = nil,
	}

	if self._tail ~= nil then
		self._tail.next = entry
	end

	self._tail = entry

	if self._head == nil then
		self._head = entry
	end
end

function Queue:popFront()
	if self._head == nil then
		return nil
	end

	local value = self._head.value
	self._head = self._head.next

	return value
end

return Queue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="105">
                <Properties>
                  <string name="Name">World</string>
                  <string name="Source"><![CDATA[local archetypeModule = require(script.Parent.archetype)
local topoRuntime = require(script.Parent.topoRuntime)
local Component = require(script.Parent.component)

local assertValidComponentInstance = Component.assertValidComponentInstance
local assertValidComponent = Component.assertValidComponent
local archetypeOf = archetypeModule.archetypeOf
local areArchetypesCompatible = archetypeModule.areArchetypesCompatible

local ERROR_NO_ENTITY = "Entity doesn't exist, use world:contains to check if needed"

--[=[
	@class World

	A World contains entities which have components.
	The World is queryable and can be used to get entities with a specific set of components.
	Entities are simply ever-increasing integers.
]=]
local World = {}
World.__index = World

--[=[
	Creates a new World.
]=]
function World.new()
	local firstStorage = {}

	return setmetatable({
		-- List of maps from archetype string --> entity ID --> entity data
		_storages = { firstStorage },
		-- The most recent storage that has not been dirtied by an iterator
		_pristineStorage = firstStorage,

		-- Map from entity ID -> archetype string
		_entityArchetypes = {},

		-- Cache of the component metatables on each entity. Used for generating archetype.
		-- Map of entity ID -> array
		_entityMetatablesCache = {},

		-- Cache of what query archetypes are compatible with what component archetypes
		_queryCache = {},

		-- Cache of what entity archetypes have ever existed in the game. This is used for knowing
		-- when to update the queryCache.
		_entityArchetypeCache = {},

		-- The next ID that will be assigned with World:spawn
		_nextId = 1,

		-- The total number of active entities in the world
		_size = 0,

		-- Storage for `queryChanged`
		_changedStorage = {},
	}, World)
end

-- Searches all archetype storages for the entity with the given archetype
-- If found, returns the entity data followed by the storage index the entity was in
function World:_getStorageWithEntity(archetype, id)
	for _, storage in self._storages do
		local archetypeStorage = storage[archetype]
		if archetypeStorage then
			if archetypeStorage[id] then
				return storage
			end
		end
	end
end

function World:_markStorageDirty()
	local newStorage = {}
	table.insert(self._storages, newStorage)
	self._pristineStorage = newStorage

	if topoRuntime.withinTopoContext() then
		local frameState = topoRuntime.useFrameState()

		frameState.dirtyWorlds[self] = true
	end
end

function World:_getEntity(id)
	local archetype = self._entityArchetypes[id]
	local storage = self:_getStorageWithEntity(archetype, id)

	return storage[archetype][id]
end

function World:_next(last)
	local entityId, archetype = next(self._entityArchetypes, last)

	if entityId == nil then
		return nil
	end

	local storage = self:_getStorageWithEntity(archetype, entityId)

	return entityId, storage[archetype][entityId]
end

--[=[
	Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping
	Component to Component Instance.

	**Usage:**

	```lua
	for entityId, entityData in world do
		print(entityId, entityData[Components.Example])
	end
	```

	@return number
	@return {[Component]: ComponentInstance}
]=]
function World:__iter()
	return World._next, self
end

--[=[
	Spawns a new entity in the world with the given components.

	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The new entity ID.
]=]
function World:spawn(...)
	return self:spawnAt(self._nextId, ...)
end

--[=[
	Spawns a new entity in the world with a specific entity ID and given components.

	The next ID generated from [World:spawn] will be increased as needed to never collide with a manually specified ID.

	@param id number -- The entity ID to spawn with
	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The same entity ID that was passed in
]=]
function World:spawnAt(id, ...)
	if self:contains(id) then
		error(
			string.format(
				"The world already contains an entity with ID %d. Use World:replace instead if this is intentional.",
				id
			),
			2
		)
	end

	self._size += 1

	if id >= self._nextId then
		self._nextId = id + 1
	end

	local components = {}
	local metatables = {}

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, nil, newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)

	return id
end

function World:_newQueryArchetype(queryArchetype)
	if self._queryCache[queryArchetype] == nil then
		self._queryCache[queryArchetype] = {}
	else
		return -- Archetype isn't actually new
	end

	for _, storage in self._storages do
		for entityArchetype in storage do
			if areArchetypesCompatible(queryArchetype, entityArchetype) then
				self._queryCache[queryArchetype][entityArchetype] = true
			end
		end
	end
end

function World:_updateQueryCache(entityArchetype)
	for queryArchetype, compatibleArchetypes in pairs(self._queryCache) do
		if areArchetypesCompatible(queryArchetype, entityArchetype) then
			compatibleArchetypes[entityArchetype] = true
		end
	end
end

function World:_transitionArchetype(id, components)
	debug.profilebegin("transitionArchetype")
	local newArchetype = nil
	local oldArchetype = self._entityArchetypes[id]
	local oldStorage

	if oldArchetype then
		oldStorage = self:_getStorageWithEntity(oldArchetype, id)

		if not components then
			oldStorage[oldArchetype][id] = nil
		end
	end

	if components then
		newArchetype = archetypeOf(unpack(self._entityMetatablesCache[id]))

		if oldArchetype ~= newArchetype then
			if oldStorage then
				oldStorage[oldArchetype][id] = nil
			end

			if self._pristineStorage[newArchetype] == nil then
				self._pristineStorage[newArchetype] = {}
			end

			if self._entityArchetypeCache[newArchetype] == nil then
				debug.profilebegin("update query cache")
				self._entityArchetypeCache[newArchetype] = true
				self:_updateQueryCache(newArchetype)
				debug.profileend()
			end
			self._pristineStorage[newArchetype][id] = components
		else
			oldStorage[newArchetype][id] = components
		end
	end

	self._entityArchetypes[id] = newArchetype

	debug.profileend()
end

--[=[
	Replaces a given entity by ID with an entirely new set of components.
	Equivalent to removing all components from an entity, and then adding these ones.

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to spawn the entity with.
]=]
function World:replace(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local components = {}
	local metatables = {}
	local entity = self:_getEntity(id)

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, entity[metatable], newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	for metatable, component in pairs(entity) do
		if not components[metatable] then
			self:_trackChanged(metatable, id, component, nil)
		end
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)
end

--[=[
	Despawns a given entity by ID, removing it and all its components from the world entirely.

	@param id number -- The entity ID
]=]
function World:despawn(id)
	local entity = self:_getEntity(id)

	for metatable, component in pairs(entity) do
		self:_trackChanged(metatable, id, component, nil)
	end

	self._entityMetatablesCache[id] = nil
	self:_transitionArchetype(id, nil)

	self._size -= 1
end

--[=[
	Removes all entities from the world.

	:::caution
	Removing entities in this way is not reported by `queryChanged`.
	:::
]=]
function World:clear()
	local firstStorage = {}
	self._storages = { firstStorage }
	self._pristineStorage = firstStorage
	self._entityArchetypes = {}
	self._entityMetatablesCache = {}
	self._size = 0
	self._changedStorage = {}
end

--[=[
	Checks if the given entity ID is currently spawned in this world.

	@param id number -- The entity ID
	@return bool -- `true` if the entity exists
]=]
function World:contains(id)
	return self._entityArchetypes[id] ~= nil
end

--[=[
	Gets a specific component (or set of components) from a specific entity in this world.

	@param id number -- The entity ID
	@param ... Component -- The components to fetch
	@return ... -- Returns the component values in the same order they were passed in
]=]
function World:get(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local length = select("#", ...)

	if length == 1 then
		assertValidComponent((...), 1)
		return entity[...]
	end

	local components = {}
	for i = 1, length do
		local metatable = select(i, ...)
		assertValidComponent(metatable, i)
		components[i] = entity[metatable]
	end

	return unpack(components, 1, length)
end

--[=[
	@class QueryResult

	A result from the [`World:query`](/api/World#query) function.

	Calling the table or the `next` method allows iteration over the results. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```
]=]
local QueryResult = {}
QueryResult.__index = QueryResult

function QueryResult:__call()
	return self._expand(self._next())
end

function QueryResult:__iter()
	return function()
		return self._expand(self._next())
	end
end

--[=[
	Returns the next set of values from the query result. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	:::info
	This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly
	done by the language itself.
	:::

	```lua
	-- Using world:query in this position will make Lua invoke the table as a function. This is conventional.
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```

	If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call `next` directly
	instead of calling the QueryResult as a function.
	```lua
	local id, enemy, charge, model = world:query(Enemy, Charge, Model):next()
	local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional
	```

	@return id -- Entity ID
	@return ...ComponentInstance -- The requested component values
]=]
function QueryResult:next()
	return self._expand(self._next())
end

local snapshot = {
	__iter = function(self)
		local i = 0
		return function()
			i += 1

			local data = self[i]

			if data then
				return unpack(data, 1, data.n)
			end
		end
	end,
}

--[=[
	Creates a "snapshot" of this query, draining this QueryResult and returning a list containing all of its results.

	By default, iterating over a QueryResult happens in "real time": it iterates over the actual data in the ECS, so
	changes that occur during the iteration will affect future results.

	By contrast, `QueryResult:snapshot()` creates a list of all of the results of this query at the moment it is called,
	so changes made while iterating over the result of `QueryResult:snapshot` do not affect future results of the
	iteration.

	Of course, this comes with a cost: we must allocate a new list and iterate over everything returned from the
	QueryResult in advance, so using this method is slower than iterating over a QueryResult directly.

	The table returned from this method has a custom `__iter` method, which lets you use it as you would use QueryResult
	directly:

	```lua
		for entityId, health, player in world:query(Health, Player):snapshot() do

		end
	```

	However, the table itself is just a list of sub-tables structured like `{entityId, component1, component2, ...etc}`.

	@return {{entityId: number, component: ComponentInstance, component: ComponentInstance, component: ComponentInstance, ...}}
]=]
function QueryResult:snapshot()
	local list = setmetatable({}, snapshot)

	local function iter()
		return self._next()
	end

	for entityId, entityData in iter do
		if entityId then
			table.insert(list, table.pack(self._expand(entityId, entityData)))
		end
	end

	return list
end

--[=[
	Returns an iterator that will skip any entities that also have the given components.

	:::tip
	This is essentially equivalent to querying normally, using `World:get` to check if a component is present,
	and using Lua's `continue` keyword to skip this iteration (though, using `:without` is faster).

	This means that you should avoid queries that return a very large amount of results only to filter them down
	to a few with `:without`. If you can, always prefer adding components and making your query more specific.
	:::

	@param ... Component -- The component types to filter against.
	@return () -> (id, ...ComponentInstance) -- Iterator of entity ID followed by the requested component values

	```lua
	for id in world:query(Target):without(Model) do
		-- Do something
	end
	```
]=]
function QueryResult:without(...)
	local metatables = { ... }
	return function()
		while true do
			local entityId, entityData = self._next()

			if not entityId then
				break
			end

			local skip = false
			for _, metatable in ipairs(metatables) do
				if entityData[metatable] then
					skip = true
					break
				end
			end

			if skip then
				continue
			end

			return self._expand(entityId, entityData)
		end
	end
end

--[=[
	Performs a query against the entities in this World. Returns a [QueryResult](/api/QueryResult), which iterates over
	the results of the query.

	Order of iteration is not guaranteed.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end

	for id in world:query(Target):without(Model) do
		-- Again, with feeling
	end
	```

	@param ... Component -- The component types to query. Only entities with *all* of these components will be returned.
	@return QueryResult -- See [QueryResult](/api/QueryResult) docs.
]=]
function World:query(...)
	debug.profilebegin("World:query")
	assertValidComponent((...), 1)

	local metatables = { ... }
	local queryLength = select("#", ...)

	local archetype = archetypeOf(...)

	if self._queryCache[archetype] == nil then
		self:_newQueryArchetype(archetype)
	end

	local compatibleArchetypes = self._queryCache[archetype]

	debug.profileend()

	if next(compatibleArchetypes) == nil then
		-- If there are no compatible storages avoid creating our complicated iterator
		return setmetatable({
			_expand = function() end,
			_next = function() end,
		}, QueryResult)
	end

	local queryOutput = table.create(queryLength)

	local function expand(entityId, entityData)
		if not entityId then
			return
		end

		for i, metatable in ipairs(metatables) do
			queryOutput[i] = entityData[metatable]
		end

		return entityId, unpack(queryOutput, 1, queryLength)
	end

	local currentCompatibleArchetype = next(compatibleArchetypes)
	local lastEntityId
	local storageIndex = 1

	if self._pristineStorage == self._storages[1] then
		self:_markStorageDirty()
	end

	local seenEntities = {}

	local function nextItem()
		local entityId, entityData

		repeat
			if self._storages[storageIndex][currentCompatibleArchetype] then
				entityId, entityData = next(self._storages[storageIndex][currentCompatibleArchetype], lastEntityId)
			end

			while entityId == nil do
				currentCompatibleArchetype = next(compatibleArchetypes, currentCompatibleArchetype)

				if currentCompatibleArchetype == nil then
					storageIndex += 1

					local nextStorage = self._storages[storageIndex]

					if nextStorage == nil or next(nextStorage) == nil then
						return
					end

					currentCompatibleArchetype = nil

					if self._pristineStorage == nextStorage then
						self:_markStorageDirty()
					end

					continue
				elseif self._storages[storageIndex][currentCompatibleArchetype] == nil then
					continue
				end

				entityId, entityData = next(self._storages[storageIndex][currentCompatibleArchetype])
			end
			lastEntityId = entityId

		until seenEntities[entityId] == nil

		seenEntities[entityId] = true
		return entityId, entityData
	end

	return setmetatable({
		_expand = expand,
		_next = nextItem,
	}, QueryResult)
end

local function cleanupQueryChanged(hookState)
	local world = hookState.world
	local componentToTrack = hookState.componentToTrack

	for index, object in world._changedStorage[componentToTrack] do
		if object == hookState.storage then
			table.remove(world._changedStorage[componentToTrack], index)
			break
		end
	end

	if next(world._changedStorage[componentToTrack]) == nil then
		world._changedStorage[componentToTrack] = nil
	end
end

--[=[
	@interface ChangeRecord
	@within World
	.new? ComponentInstance -- The new value of the component. Nil if just removed.
	.old? ComponentInstance -- The former value of the component. Nil if just added.
]=]

--[=[
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Queries for components that have changed **since the last time your system ran `queryChanged`**.

	Only one changed record is returned per entity, even if the same entity changed multiple times. The order
	in which changed records are returned is not guaranteed to be the order that the changes occurred in.

	It should be noted that `queryChanged` does not have the same iterator invalidation concerns as `World:query`.

	:::tip
	The first time your system runs (i.e., on the first frame), all existing entities in the world that match your query
	are returned as "new" change records.
	:::

	:::info
	Calling this function from your system creates storage internally for your system. Then, changes meeting your
	criteria are pushed into your storage. Calling `queryChanged` again each frame drains this storage.

	If your system isn't called every frame, the storage will continually fill up and does not empty unless you drain
	it.

	If you stop calling `queryChanged` in your system, changes will stop being tracked.
	:::

	### Returns
	`queryChanged` returns an iterator function, so you call it in a for loop just like `World:query`.

	The iterator returns the entity ID, followed by a [`ChangeRecord`](#ChangeRecord).

	The `ChangeRecord` type is a table that contains two fields, `new` and `old`, respectively containing the new
	component instance, and the old component instance. `new` and `old` will never be the same value.

	`new` will be nil if the component was removed (or the entity was despawned), and `old` will be nil if the
	component was just added.

	The `old` field will be the value of the component the last time this system observed it, not
	necessarily the value it changed from most recently.

	The `ChangeRecord` table is potentially shared with multiple systems tracking changes for this component, so it
	cannot be modified.

	```lua
	for id, record in world:queryChanged(Model) do
		if record.new == nil then
			-- Model was removed

			if enemy.type == "this is a made up example" then
				world:remove(id, Enemy)
			end
		end
	end
	```

	@param componentToTrack Component -- The component you want to listen to changes for.
	@return () -> (id, ChangeRecord) -- Iterator of entity ID and change record
]=]
function World:queryChanged(componentToTrack, ...: nil)
	if ... then
		error("World:queryChanged does not take any additional parameters", 2)
	end

	local hookState = topoRuntime.useHookState(componentToTrack, cleanupQueryChanged)

	if hookState.storage then
		return function()
			local entityId, record = next(hookState.storage)

			if entityId then
				hookState.storage[entityId] = nil

				return entityId, record
			end
		end
	end

	if not self._changedStorage[componentToTrack] then
		self._changedStorage[componentToTrack] = {}
	end

	local storage = {}
	hookState.storage = storage
	hookState.world = self
	hookState.componentToTrack = componentToTrack

	table.insert(self._changedStorage[componentToTrack], storage)

	local queryResult = self:query(componentToTrack)

	return function()
		local entityId, component = queryResult:next()

		if entityId then
			return entityId, table.freeze({ new = component })
		end
	end
end

function World:_trackChanged(metatable, id, old, new)
	if not self._changedStorage[metatable] then
		return
	end

	if old == new then
		return
	end

	local record = table.freeze({
		old = old,
		new = new,
	})

	for _, storage in ipairs(self._changedStorage[metatable]) do
		-- If this entity has changed since the last time this system read it,
		-- we ensure that the "old" value is whatever the system saw it as last, instead of the
		-- "old" value we have here.
		if storage[id] then
			storage[id] = table.freeze({ old = storage[id].old, new = new })
		else
			storage[id] = record
		end
	end
end

--[=[
	Inserts a component (or set of components) into an existing entity.

	If another instance of a given component already exists on this entity, it is replaced.

	```lua
	world:insert(
		entityId,
		ComponentA({
			foo = "bar"
		}),
		ComponentB({
			baz = "qux"
		})
	)
	```

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to insert
]=]
function World:insert(id, ...)
	debug.profilebegin("insert")
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local wasNew = false
	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		local oldComponent = entity[metatable]

		if not oldComponent then
			wasNew = true

			table.insert(self._entityMetatablesCache[id], metatable)
		end

		self:_trackChanged(metatable, id, oldComponent, newComponent)

		entity[metatable] = newComponent
	end

	if wasNew then -- wasNew
		self:_transitionArchetype(id, entity)
	end

	debug.profileend()
end

--[=[
	Removes a component (or set of components) from an existing entity.

	```lua
	local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)
	```

	@param id number -- The entity ID
	@param ... Component -- The components to remove
	@return ...ComponentInstance -- Returns the component instance values that were removed in the order they were passed.
]=]
function World:remove(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local length = select("#", ...)
	local removed = {}

	for i = 1, length do
		local metatable = select(i, ...)

		assertValidComponent(metatable, i)

		local oldComponent = entity[metatable]

		removed[i] = oldComponent

		self:_trackChanged(metatable, id, oldComponent, nil)

		entity[metatable] = nil
	end

	-- Rebuild entity metatable cache
	local metatables = {}

	for metatable in pairs(entity) do
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, entity)

	return unpack(removed, 1, length)
end

--[=[
	Returns the number of entities currently spawned in the world.
]=]
function World:size()
	return self._size
end

--[=[
	:::tip
	[Loop] automatically calls this function on your World(s), so there is no need to call it yourself if you're using
	a Loop.
	:::

	If you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize
	the internal storage for queries.

	This is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query from
	[World:query]. While inside a query, any changes to the World are stored in a separate location from the rest of
	the World. Calling this function combines the separate storage back into the main storage, which speeds things up
	again.
]=]
function World:optimizeQueries()
	if #self._storages == 1 then
		return
	end

	local firstStorage = self._storages[1]

	for i = 2, #self._storages do
		local storage = self._storages[i]

		for archetype, entities in storage do
			if firstStorage[archetype] == nil then
				firstStorage[archetype] = entities
			else
				for entityId, entityData in entities do
					if firstStorage[archetype][entityId] then
						error("Entity ID already exists in first storage...")
					end
					firstStorage[archetype][entityId] = entityData
				end
			end
		end
	end

	table.clear(self._storages)

	self._storages[1] = firstStorage
	self._pristineStorage = firstStorage
end

return World
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="106">
                <Properties>
                  <string name="Name">World.spec</string>
                  <string name="Source"><![CDATA[local World = require(script.Parent.World)
local Loop = require(script.Parent.Loop)
local component = require(script.Parent).component
local BindableEvent = require(script.Parent.mock.BindableEvent)

local function deepEquals(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

local function assertDeepEqual(a, b)
	if not deepEquals(a, b) then
		print("EXPECTED:", b)
		print("GOT:", a)
		error("Tables were not deep-equal")
	end
end

return function()
	describe("World", function()
		it("should be iterable", function()
			local world = World.new()
			local A = component()
			local B = component()

			local eA = world:spawn(A())
			local eB = world:spawn(B())
			local eAB = world:spawn(A(), B())

			local count = 0
			for id, data in world do
				count += 1
				if id == eA then
					expect(data[A]).to.be.ok()
					expect(data[B]).to.never.be.ok()
				elseif id == eB then
					expect(data[B]).to.be.ok()
					expect(data[A]).to.never.be.ok()
				elseif id == eAB then
					expect(data[A]).to.be.ok()
					expect(data[B]).to.be.ok()
				else
					error("unknown entity", id)
				end
			end

			expect(count).to.equal(3)
		end)

		it("should have correct size", function()
			local world = World.new()
			world:spawn()
			world:spawn()
			world:spawn()

			local id = world:spawn()
			world:despawn(id)

			expect(world:size()).to.equal(3)

			world:clear()

			expect(world:size()).to.equal(0)
		end)

		it("should report contains correctly", function()
			local world = World.new()
			local id = world:spawn()

			expect(world:contains(id)).to.equal(true)
			expect(world:contains(1234124124124124124124)).to.equal(false)
		end)

		it("should allow spawning entities at a specific ID", function()
			local world = World.new()

			local A = component()
			local id = world:spawnAt(5, A())

			expect(function()
				world:spawnAt(5, A())
			end).to.throw()

			expect(id).to.equal(5)

			local nextId = world:spawn(A())
			expect(nextId).to.equal(6)
		end)

		it("should allow inserting and removing components from existing entities", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local id = world:spawn(Player(), Poison())

			expect(world:query(Player):next()).to.be.ok()
			expect(world:query(Health):next()).to.never.be.ok()

			world:insert(id, Health())

			expect(world:query(Player):next()).to.be.ok()
			expect(world:query(Health):next()).to.be.ok()
			expect(world:size()).to.equal(1)

			local player, poison = world:remove(id, Player, Poison)

			expect(getmetatable(player)).to.equal(Player)
			expect(getmetatable(poison)).to.equal(Poison)

			expect(world:query(Player):next()).to.never.be.ok()
			expect(world:query(Health):next()).to.be.ok()
			expect(world:size()).to.equal(1)
		end)

		it("should be queryable", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local one = world:spawn(
				Player({
					name = "alice",
				}),
				Health({
					value = 100,
				}),
				Poison()
			)

			world:spawn( -- Spawn something we don't want to get back
				component()(),
				component()()
			)

			local two = world:spawn(
				Player({
					name = "bob",
				}),
				Health({
					value = 99,
				})
			)

			local found = {}
			local foundCount = 0

			for entityId, player, health in world:query(Player, Health) do
				foundCount += 1
				found[entityId] = {
					[Player] = player,
					[Health] = health,
				}
			end

			expect(foundCount).to.equal(2)

			expect(found[one]).to.be.ok()
			expect(found[one][Player].name).to.equal("alice")
			expect(found[one][Health].value).to.equal(100)

			expect(found[two]).to.be.ok()
			expect(found[two][Player].name).to.equal("bob")
			expect(found[two][Health].value).to.equal(99)

			local count = 0
			for id, player in world:query(Player) do
				expect(type(player.name)).to.equal("string")
				expect(type(id)).to.equal("number")
				count += 1
			end
			expect(count).to.equal(2)

			local withoutCount = 0
			for _id, _player in world:query(Player):without(Poison) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(1)
		end)

		it("should allow getting single components", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Other = component()

			local id = world:spawn(Other({ a = 1 }), Player({ b = 2 }), Health({ c = 3 }))

			expect(world:get(id, Player).b).to.equal(2)
			expect(world:get(id, Health).c).to.equal(3)

			local one, two = world:get(id, Health, Player)

			expect(one.c).to.equal(3)
			expect(two.b).to.equal(2)
		end)

		it("should return existing entities when creating queryChanged", function()
			local world = World.new()

			local loop = Loop.new(world)

			local A = component()

			local initial = {
				world:spawn(A({
					a = 1,
				})),
				world:spawn(A({
					b = 2,
				})),
			}

			local third

			local runCount = 0
			loop:scheduleSystem(function(world)
				runCount += 1

				local map = {}
				local count = 0

				for entityId, record in world:queryChanged(A) do
					count += 1
					map[entityId] = record
				end

				if runCount == 1 then
					expect(count).to.equal(2)
					expect(map[initial[1]].new.a).to.equal(1)
					expect(map[initial[1]].old).to.equal(nil)
					expect(map[initial[2]].new.b).to.equal(2)
				else
					expect(count).to.equal(1)
					expect(map[third].new.c).to.equal(3)
				end
			end)

			local defaultBindable = BindableEvent.new()

			loop:begin({ default = defaultBindable.Event })

			defaultBindable:Fire()

			expect(runCount).to.equal(1)

			third = world:spawn(A({
				c = 3,
			}))

			defaultBindable:Fire()
			expect(runCount).to.equal(2)
		end)

		it("should track changes", function()
			local world = World.new()

			local loop = Loop.new(world)

			local A = component()
			local B = component()
			local C = component()

			local expectedResults = {
				nil,
				{
					1,
					{
						new = {
							generation = 1,
						},
					},
				},
				{
					1,
					{
						new = {
							generation = 2,
						},
						old = {
							generation = 1,
						},
					},
				},
				{
					2,
					{
						new = {
							generation = 1,
						},
					},
				},
				nil,
				{
					1,
					{
						old = {
							generation = 2,
						},
					},
				},
				{
					2,
					{
						old = {
							generation = 1,
						},
					},
				},
			}

			local resultIndex = 0

			local additionalQuery = C
			loop:scheduleSystem(function(w)
				local ran = false

				for entityId, record in w:queryChanged(A) do
					if additionalQuery then
						if w:get(entityId, additionalQuery) == nil then
							continue
						end
					end

					ran = true
					resultIndex += 1

					expect(entityId).to.equal(expectedResults[resultIndex][1])

					assertDeepEqual(record, expectedResults[resultIndex][2])
				end

				if not ran then
					resultIndex += 1
					expect(expectedResults[resultIndex]).to.equal(nil)
				end
			end)

			local infrequentCount = 0
			loop:scheduleSystem({
				system = function(w)
					infrequentCount += 1

					local count = 0
					local results = {}
					for entityId, record in w:queryChanged(A) do
						count += 1
						results[entityId - 1] = record
					end

					if count == 0 then
						expect(infrequentCount).to.equal(1)
					else
						if infrequentCount == 2 then
							expect(count).to.equal(2)

							expect(results[0].old).to.equal(nil)
							expect(results[0].new.generation).to.equal(2)
							expect(results[1].old).to.equal(nil)
							expect(results[1].new).to.equal(nil)
						elseif infrequentCount == 3 then
							expect(results[0].old.generation).to.equal(2)
							expect(results[0].new).to.equal(nil)
							expect(count).to.equal(1)
						else
							error("infrequentCount too high")
						end
					end
				end,
				event = "infrequent",
			})

			local defaultBindable = BindableEvent.new()
			local infrequentBindable = BindableEvent.new()

			loop:begin({ default = defaultBindable.Event, infrequent = infrequentBindable.Event })

			defaultBindable:Fire()
			infrequentBindable:Fire()

			local entityId = world:spawn(
				A({
					generation = 1,
				}),
				C()
			)

			defaultBindable:Fire()

			additionalQuery = nil

			world:insert(
				entityId,
				A({
					generation = 2,
				})
			)

			world:insert(
				entityId,
				B({
					foo = "bar",
				})
			)

			local secondEntityId = world:spawn(
				A({
					generation = 1,
				}),
				C()
			)

			defaultBindable:Fire()
			defaultBindable:Fire()

			world:replace(secondEntityId, B())

			infrequentBindable:Fire()

			world:despawn(entityId)

			defaultBindable:Fire()

			infrequentBindable:Fire()
		end)

		it("should error when passing nil to query", function()
			expect(function()
				World.new():query(nil)
			end).to.throw()
		end)

		it("should error when passing an invalid table", function()
			local world = World.new()
			local id = world:spawn()

			expect(function()
				world:insert(id, {})
			end).to.throw()
		end)

		it("should error when passing a Component instead of Component instance", function()
			expect(function()
				World.new():spawn(component())
			end).to.throw()
		end)

		it("should allow snapshotting a query", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local one = world:spawn(
				Player({
					name = "alice",
				}),
				Health({
					value = 100,
				}),
				Poison()
			)

			world:spawn( -- Spawn something we don't want to get back
				component()(),
				component()()
			)

			local two = world:spawn(
				Player({
					name = "bob",
				}),
				Health({
					value = 99,
				})
			)

			local snapshot = world:query(Health, Player):snapshot()

			for entityId, health, player in world:query(Health, Player):snapshot() do
				expect(type(entityId)).to.equal("number")
				expect(type(player.name)).to.equal("string")
				expect(type(health.value)).to.equal("number")
			end

			world:remove(two, Health)
			world:despawn(one)

			if snapshot[2][1] == 3 then
				expect(snapshot[1][1]).to.equal(1)
			else
				expect(snapshot[2][1]).to.equal(1)
			end
		end)

		it("should not invalidate iterators", function()
			local world = World.new()
			local A = component()
			local B = component()
			local C = component()

			for _ = 1, 10 do
				world:spawn(A(), B())
			end

			local count = 0
			for id in world:query(A) do
				count += 1
				world:insert(id, C())
				world:remove(id, B)
			end
			expect(count).to.equal(10)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="107">
                <Properties>
                  <string name="Name">archetype</string>
                  <string name="Source"><![CDATA[local toSet = require(script.Parent.immutable).toSet

local valueIds = {}
local nextValueId = 0
local compatibilityCache = {}
local archetypeCache = {}

local function getValueId(value)
	local valueId = valueIds[value]
	if valueId == nil then
		valueIds[value] = nextValueId
		valueId = nextValueId
		nextValueId += 1
	end

	return valueId
end

function archetypeOf(...)
	debug.profilebegin("archetypeOf")

	local length = select("#", ...)

	local currentNode = archetypeCache

	for i = 1, length do
		local nextNode = currentNode[select(i, ...)]

		if not nextNode then
			nextNode = {}
			currentNode[select(i, ...)] = nextNode
		end

		currentNode = nextNode
	end

	if currentNode._archetype then
		debug.profileend()
		return currentNode._archetype
	end

	local list = table.create(length)

	for i = 1, length do
		list[i] = getValueId(select(i, ...))
	end

	table.sort(list)

	local archetype = table.concat(list, "_")

	currentNode._archetype = archetype

	debug.profileend()

	return archetype
end

function areArchetypesCompatible(queryArchetype, targetArchetype)
	local cachedCompatibility = compatibilityCache[queryArchetype .. "-" .. targetArchetype]
	if cachedCompatibility ~= nil then
		return cachedCompatibility
	end
	debug.profilebegin("areArchetypesCompatible")

	local queryIds = string.split(queryArchetype, "_")
	local targetIds = toSet(string.split(targetArchetype, "_"))

	for _, queryId in ipairs(queryIds) do
		if targetIds[queryId] == nil then
			compatibilityCache[queryArchetype .. "-" .. targetArchetype] = false
			debug.profileend()
			return false
		end
	end

	compatibilityCache[queryArchetype .. "-" .. targetArchetype] = true

	debug.profileend()
	return true
end

return {
	archetypeOf = archetypeOf,
	areArchetypesCompatible = areArchetypesCompatible,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="108">
                <Properties>
                  <string name="Name">archetype.spec</string>
                  <string name="Source"><![CDATA[local archetype = require(script.Parent.archetype)
local component = require(script.Parent).component

return function()
	describe("archetype", function()
		it("should report same sets as same archetype", function()
			local a = component()
			local b = component()
			expect(archetype.archetypeOf(a, b)).to.equal(archetype.archetypeOf(b, a))
		end)
		it("should identify compatible archetypes", function()
			local a = component()
			local b = component()
			local c = component()

			local archetypeA = archetype.archetypeOf(a, b, c)
			local archetypeB = archetype.archetypeOf(a, b)
			local archetypeC = archetype.archetypeOf(b, c)

			expect(archetype.areArchetypesCompatible(archetypeA, archetypeB)).to.equal(false)
			expect(archetype.areArchetypesCompatible(archetypeB, archetypeA)).to.equal(true)

			expect(archetype.areArchetypesCompatible(archetypeC, archetypeA)).to.equal(true)
			expect(archetype.areArchetypesCompatible(archetypeB, archetypeC)).to.equal(false)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="109">
                <Properties>
                  <string name="Name">component</string>
                  <string name="Source"><![CDATA[local merge = require(script.Parent.immutable).merge

--[=[
	@class Component

	A component is a named piece of data that exists on an entity.
	Components are created and removed in the [World](/api/World).

	In the docs, the terms "Component" and "ComponentInstance" are used:
	- **"Component"** refers to the base class of a specific type of component you've created.
		This is what [`Matter.component`](/api/Matter#component) returns.
	- **"Component Instance"** refers to an actual piece of data that can exist on an entity.
		The metatable of a component instance table is its respective Component table.

	Component instances are *plain-old data*: they do not contain behaviors or methods.

	Since component instances are immutable, one helper function exists on all component instances, `patch`,
	which allows reusing data from an existing component instance to make up for the ergonomic loss of mutations.
]=]

--[=[
	@within Component
	@type ComponentInstance {}

	The `ComponentInstance` type refers to an actual piece of data that can exist on an entity.
	The metatable of the component instance table is set to its particular Component table.

	A component instance can be created by calling the Component table:

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})

	print(getmetatable(myComponentInstance) == MyComponent) --> true
	```
]=]

-- This is a special value we set inside the component's metatable that will allow us to detect when
-- a Component is accidentally inserted as a Component Instance.
-- It should not be accessible through indexing into a component instance directly.
local DIAGNOSTIC_COMPONENT_MARKER = {}

local function newComponent(name, defaultData)
	name = name or debug.info(2, "s") .. "@" .. debug.info(2, "l")

	assert(
		defaultData == nil or type(defaultData) == "table",
		"if component default data is specified, it must be a table"
	)

	local component = {}
	component.__index = component

	function component.new(data)
		data = data or {}

		if defaultData then
			data = merge(defaultData, data)
		end

		return table.freeze(setmetatable(data, component))
	end

	--[=[
	@within Component

	```lua
	for id, target in world:query(Target) do
		if shouldChangeTarget(target) then
			world:insert(id, target:patch({ -- modify the existing component
				currentTarget = getNewTarget()
			}))
		end
	end
	```

	A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table
	will override those of the existing component instance.

	As all components are immutable and frozen, it is not possible to modify the existing component directly.

	You can use the `Matter.None` constant to remove a value from the component instance:

	```lua
	target:patch({
		currentTarget = Matter.None -- sets currentTarget to nil
	})
	```

	@param partialNewData {} -- The table to be merged with the existing component data.
	@return ComponentInstance -- A copy of the component instance with values from `partialNewData` overriding existing values.
	]=]
	function component:patch(partialNewData)
		debug.profilebegin("patch")
		local patch = getmetatable(self).new(merge(self, partialNewData))
		debug.profileend()
		return patch
	end

	setmetatable(component, {
		__call = function(_, ...)
			return component.new(...)
		end,
		__tostring = function()
			return name
		end,
		[DIAGNOSTIC_COMPONENT_MARKER] = true,
	})

	return component
end

local function assertValidComponent(value, position)
	if typeof(value) ~= "table" then
		error(string.format("Component #%d is invalid: not a table", position), 3)
	end

	local metatable = getmetatable(value)

	if metatable == nil then
		error(string.format("Component #%d is invalid: has no metatable", position), 3)
	end
end

local function assertValidComponentInstance(value, position)
	assertValidComponent(value, position)

	if getmetatable(value)[DIAGNOSTIC_COMPONENT_MARKER] ~= nil then
		error(
			string.format(
				"Component #%d is invalid: passed a Component instead of a Component instance; "
					.. "did you forget to call it as a function?",
				position
			),
			3
		)
	end
end

return {
	newComponent = newComponent,
	assertValidComponentInstance = assertValidComponentInstance,
	assertValidComponent = assertValidComponent,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="110">
                <Properties>
                  <string name="Name">component.spec</string>
                  <string name="Source"><![CDATA[local Component = require(script.Parent.component)
local None = require(script.Parent.immutable).None
local component = Component.newComponent
local assertValidComponentInstance = Component.assertValidComponentInstance

return function()
	describe("Component", function()
		it("should create components", function()
			local a = component()
			local b = component()

			expect(getmetatable(a)).to.be.ok()

			expect(getmetatable(a)).to.never.equal(getmetatable(b))

			expect(typeof(a.new)).to.equal("function")
		end)

		it("should allow calling the table to construct", function()
			local a = component()

			expect(getmetatable(a())).to.equal(getmetatable(a.new()))
		end)

		it("should allow patching into a new component", function()
			local A = component()

			local a = A({
				foo = "bar",
				unset = true,
			})

			local a2 = a:patch({
				baz = "qux",
				unset = None,
			})

			expect(a2.foo).to.equal("bar")
			expect(a2.unset).to.equal(nil)
			expect(a2.baz).to.equal("qux")
		end)

		it("should allow specifying default data", function()
			local Foo = component("Foo", {
				a = 53,
			})

			local foo = Foo()

			expect(foo.a).to.equal(53)

			local bar = Foo({
				a = 42,
				b = 54,
			})

			expect(bar.a).to.equal(42)
			expect(bar.b).to.equal(54)

			local baz = Foo({
				b = 100,
			})

			expect(baz.a).to.equal(53)
			expect(baz.b).to.equal(100)
		end)
	end)

	describe("assertValidComponentInstance", function()
		it("should throw on invalid components", function()
			expect(function()
				assertValidComponentInstance({})
			end).to.throw()

			expect(function()
				assertValidComponentInstance(55)
			end).to.throw()

			expect(function()
				assertValidComponentInstance(component())
			end).to.throw()

			expect(function()
				assertValidComponentInstance(component().new())
			end).never.to.throw()
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="111">
                <Properties>
                  <string name="Name">debugger</string>
                </Properties>
                <Item class="ModuleScript" referent="112">
                  <Properties>
                    <string name="Name">EventBridge</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local EventBridge = {}
EventBridge.__index = EventBridge

local debouncedEvents = {
	InputChanged = true,
}

local debounce = {}

local function serialize(...)
	local first = ...

	if first and typeof(first) == "Instance" and first:IsA("InputObject") then
		return {
			Delta = first.Delta,
			KeyCode = first.KeyCode,
			Position = first.Position,
			UserInputState = first.UserInputState,
			UserInputType = first.UserInputType,
		}
	end

	return ...
end

local clientConnections = {}
EventBridge.clientActions = {
	connect = function(fire, instance, event)
		local instanceFromServer = instance

		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] == nil then
			clientConnections[instance] = {}
		end

		clientConnections[instance][event] = instance[event]:Connect(function(...)
			if debouncedEvents[event] and not RunService:IsStudio() then
				local args = table.pack(serialize(...))

				if debounce[instance] and debounce[instance][event] then
					debounce[instance][event] = args
				else
					if debounce[instance] == nil then
						debounce[instance] = {}
					end

					debounce[instance][event] = args

					task.delay(0.25, function()
						local args = debounce[instance][event]

						fire("event", instanceFromServer, event, unpack(args, 1, args.n))

						debounce[instance][event] = nil

						if next(debounce[instance]) == nil then
							debounce[instance] = nil
						end
					end)
				end

				return
			end

			fire("event", instanceFromServer, event, serialize(...))
		end)
	end,

	disconnect = function(_fire, instance, event)
		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] and clientConnections[instance][event] then
			clientConnections[instance][event]:Disconnect()
			clientConnections[instance][event] = nil
		end
	end,
}

function EventBridge.new(fire)
	return setmetatable({
		_fire = fire,
		_storage = {},
		players = {},
	}, EventBridge)
end

function EventBridge:connect(instance, event, handler)
	if RunService:IsClient() then
		return instance[event]:Connect(handler)
	end

	if not game:IsAncestorOf(instance) then
		local connection

		connection = instance.AncestryChanged:Connect(function()
			if connection == nil then
				return
			end

			if game:IsAncestorOf(instance) then
				connection:Disconnect()
				connection = nil
				self:connect(instance, event, handler)
			end
		end)

		return
	end

	if self._storage[instance] == nil then
		self._storage[instance] = {}

		instance.Destroying:Connect(function()
			for event in self._storage[instance] do
				self:_disconnect(instance, event)
			end
		end)
	end

	self._storage[instance][event] = handler

	for _, player in self.players do
		self:_connectPlayerEvent(player, instance, event)
	end

	return {
		Disconnect = function()
			self:_disconnect(instance, event)
		end,
	}
end

function EventBridge:_connectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "connect", instance, event)
end

function EventBridge:_disconnectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "disconnect", instance, event)
end

function EventBridge:connectPlayer(player)
	for instance, events in self._storage do
		for event in events do
			self:_connectPlayerEvent(player, instance, event)
		end
	end

	table.insert(self.players, player)
end

function EventBridge:disconnectPlayer(player)
	local index = table.find(self.players, player)

	if not index then
		return
	end

	table.remove(self.players, index)

	for instance, events in self._storage do
		for event in events do
			self:_disconnectPlayerEvent(player, instance, event)
		end
	end
end

function EventBridge:_disconnect(instance, event)
	self._storage[instance][event] = nil

	for _, player in self.players do
		self:_disconnectPlayerEvent(player, instance, event)
	end
end

function EventBridge:fireEventFromPlayer(player, instance, event, ...)
	if not table.find(self.players, player) then
		warn(player, "fired a debugger event but they aren't authorized")
		return
	end

	if type(instance) == "string" then
		instance = game:GetService(instance)
	end

	if not self._storage[instance] or not self._storage[instance][event] then
		-- warn(player, "fired a debugger event but the instance has no connections")
		return
	end

	self._storage[instance][event](...)
end

return EventBridge
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="113">
                  <Properties>
                    <string name="Name">clientBindings</string>
                    <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local function clientBindings(debugger)
	local connections = {}

	table.insert(
		connections,
		CollectionService:GetInstanceAddedSignal("MatterDebuggerSwitchToClientView"):Connect(function(instance)
			instance.Activated:Connect(function()
				debugger:switchToClientView()
			end)
		end)
	)

	table.insert(
		connections,
		UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseMovement then
				return
			end

			local mousePosition = UserInputService:GetMouseLocation()

			for _, gui in CollectionService:GetTagged("MatterDebuggerTooltip") do
				gui.Position = UDim2.new(0, mousePosition.X + 20, 0, mousePosition.Y)
			end
		end)
	)

	table.insert(
		connections,
		CollectionService:GetInstanceAddedSignal("MatterDebuggerTooltip"):Connect(function(gui)
			local mousePosition = UserInputService:GetMouseLocation()

			gui.Position = UDim2.new(0, mousePosition.X + 20, 0, mousePosition.Y)
		end)
	)

	return connections
end

return clientBindings
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="114">
                  <Properties>
                    <string name="Name">debugger</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local hookWidgets = require(script.Parent.hookWidgets)
local World = require(script.Parent.Parent.World)
local EventBridge = require(script.Parent.EventBridge)
local ui = require(script.Parent.ui)
local mouseHighlight = require(script.Parent.mouseHighlight)
local clientBindings = require(script.Parent.clientBindings)
local hookWorld = require(script.Parent.hookWorld)

local customWidgetConstructors = {
	panel = require(script.Parent.widgets.panel),
	selectionList = require(script.Parent.widgets.selectionList),
	container = require(script.Parent.widgets.container),
	frame = require(script.Parent.widgets.frame),
	link = require(script.Parent.widgets.link),
	realmSwitch = require(script.Parent.widgets.realmSwitch),
	valueInspect = require(script.Parent.widgets.valueInspect),
	worldInspect = require(script.Parent.widgets.worldInspect),
	entityInspect = require(script.Parent.widgets.entityInspect),
	tooltip = require(script.Parent.widgets.tooltip),
	hoverInspect = require(script.Parent.widgets.hoverInspect),
	queryInspect = require(script.Parent.widgets.queryInspect),
	codeText = require(script.Parent.widgets.codeText),
	errorInspect = require(script.Parent.widgets.errorInspect),
}

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()

local remoteEvent, clientBindingConnections

-- Assert plasma is compatible via feature detection
local function assertCompatiblePlasma(plasma)
	if not plasma.highlight then
		error("Plasma passed to Matter debugger is out of date, please update it to use the debugger.")
	end
end

--[=[
	@class Debugger

	Attaches a Debugger to the Matter instance, allowing you to create debug widgets in your systems.

	```lua
	local debugger = Matter.Debugger.new(Plasma)

	local widgets = debugger:getWidgets()
	local loop = Matter.Loop.new(world, widgets) -- pass the widgets to your systems

	debugger:autoInitialize(loop)

	if IS_CLIENT then
		debugger:show()
	end
	```

	When the debugger is not open, the widgets do not render.
]=]
local Debugger = {}
Debugger.__index = Debugger

--[=[
	@prop authorize (player: Player) -> boolean
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine if a player should be
	allowed to connect to the server-side debugger.

	If not specified, the default behavior is to allow anyone in Studio and disallow everyone in a live game.

	```lua
	debugger.authorize = function(player)
		if player:GetRankInGroup(372) > 250 then -- etc
			return true
		end
	end
	```
]=]

--[=[
	@prop findInstanceFromEntity (entityId: number) -> Instance?
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine what Instance is associated
	with an entity. This is used for the in-world highlight in the World inspector.

	If not specified, the in-world highlight will not work.

	```lua
	debugger.findInstanceFromEntity = function(id)
		if not world:contains(id) then
			return
		end

		local model = world:get(id, components.Model)

		return model and model.model or nil
	end
	```
]=]

--[=[
	Creates a new Debugger.

	You need to depend on [Plasma](https://eryn.io/plasma/) in your project and pass a handle to it here.

	@param plasma Plasma -- The instance of Plasma used in your game.
	@return Debugger
]=]
function Debugger.new(plasma)
	assertCompatiblePlasma(plasma)

	if not remoteEvent then
		if IS_SERVER then
			remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = "MatterDebuggerRemote"
			remoteEvent.Parent = ReplicatedStorage
		else
			remoteEvent = ReplicatedStorage:WaitForChild("MatterDebuggerRemote")

			remoteEvent.OnClientEvent:Connect(function(action, ...)
				if not EventBridge.clientActions[action] then
					return
				end

				EventBridge.clientActions[action](function(...)
					remoteEvent:FireServer(...)
				end, ...)
			end)
		end
	end

	local self = setmetatable({
		plasma = plasma,
		loop = nil,
		enabled = false,
		_windowCount = 0,
		_queries = {},
		_seenEvents = {},
		_eventOrder = {},
		_eventBridge = EventBridge.new(function(...)
			remoteEvent:FireClient(...)
		end),
		_customWidgets = {},
	}, Debugger)

	for name, create in customWidgetConstructors do
		self._customWidgets[name] = create(plasma)
	end

	if IS_SERVER then
		self:_connectRemoteEvent()
	else
		if not clientBindingConnections then
			clientBindingConnections = clientBindings(self)
		end
	end

	return self
end

function Debugger:_connectRemoteEvent()
	remoteEvent.OnServerEvent:Connect(function(player, action, instance, event, ...)
		if action == "event" then
			self._eventBridge:fireEventFromPlayer(player, instance, event, ...)
		elseif action == "start" then
			if not RunService:IsStudio() then
				if self.authorize then
					if not self.authorize(player) then
						return
					end
				else
					warn("Player attempted to connect to matter debugger but no authorize function is configured.")
					return
				end
			end
			self:connectPlayer(player)
		elseif action == "stop" then
			self:disconnectPlayer(player)
		elseif action == "inspect" then
			self.debugEntity = instance
		elseif action == "hover" then
			self.hoverEntity = instance
		end
	end)
end

--[=[
	@client

	Shows the debugger panel
]=]
function Debugger:show()
	if not IS_CLIENT then
		error("show can only be called from the client")
	end

	self:_enable()
end

--[=[
	@client

	Hides the debugger panel
]=]
function Debugger:hide()
	if not IS_CLIENT then
		error("hide can only be called from the client")
	end

	self:_disable()

	if self:_isServerView() then
		self:switchToClientView()
	end
end

--[=[
	@client

	Toggles visibility of the debugger panel
]=]
function Debugger:toggle()
	if not IS_CLIENT then
		error("toggle can only be called from the client")
	end

	if self.enabled then
		self:_disable()
	else
		self:_enable()
	end
end

function Debugger:_enable()
	if self.enabled then
		return
	end

	-- TODO: Find a better way for the user to specify the world.
	if not self.debugWorld then
		for _, object in self.loop._state do
			if getmetatable(object) == World then
				self.debugWorld = object
				break
			end
		end
	end

	self.enabled = true
	self.loop.profiling = self.loop.profiling or {}

	hookWorld.hookWorld(self)
end

function Debugger:_disable()
	self.enabled = false
	self.debugSystem = nil
	self.loop.profiling = nil
	hookWorld.unhookWorld()

	if self.plasmaNode then
		self.plasma.start(self.plasmaNode, function() end)
	end
end

function Debugger:connectPlayer(player)
	if not IS_SERVER then
		error("connectClient can only be called from the server")
	end

	if not self.enabled then
		print("Matter server debugger started")
		self:_enable()
	end

	self._eventBridge:connectPlayer(player)
end

function Debugger:disconnectPlayer(player)
	if not IS_SERVER then
		error("disconnectClient can only be called from the server")
	end

	self._eventBridge:disconnectPlayer(player)

	if #self._eventBridge.players == 0 then
		self:_disable()
		self.debugSystem = nil
		print("Matter server debugger stopped")
	end
end

--[=[
	Adds middleware to your Loop to set up the debugger every frame.

	:::tip
	The debugger must also be shown on a client with [Debugger:show] or [Debugger:toggle] to be used.
	:::

	:::caution
	[Debugger:autoInitialize] should be called before [Loop:begin] to function as expected.
	:::

	If you also want to use Plasma for more than just the debugger, you can opt to not call this function and instead
	do what it does yourself.

	@param loop Loop
]=]
function Debugger:autoInitialize(loop)
	self.loop = loop

	self.loop.trackErrors = true

	local parent = Instance.new("ScreenGui")
	parent.Name = "MatterDebugger"
	parent.ResetOnSpawn = false
	parent.IgnoreGuiInset = true

	if IS_CLIENT then
		parent.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	else
		parent.Parent = ReplicatedStorage
	end

	local plasmaNode = self.plasma.new(parent)
	self.plasmaNode = plasmaNode

	self.loop:addMiddleware(function(nextFn, eventName)
		return function()
			if not self._seenEvents[eventName] then
				self._seenEvents[eventName] = true
				table.insert(self._eventOrder, eventName)
			end

			if not self.enabled then
				nextFn()
				return
			end

			if eventName == self._eventOrder[1] then
				self._continueHandle = self.plasma.beginFrame(plasmaNode, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					self:update()

					nextFn()
				end)
			elseif self._continueHandle then
				self.plasma.continueFrame(self._continueHandle, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					nextFn()
				end)
			end

			if eventName == self._eventOrder[#self._eventOrder] then
				self.plasma.finishFrame(plasmaNode)
			end
		end
	end)

	if IS_CLIENT then
		self.plasma.hydrateAutomaticSize()
	end
end

--[=[
	Alert the debugger when a system is hot reloaded.

	@param old System
	@param new System
]=]
function Debugger:replaceSystem(old, new)
	if self.debugSystem == old then
		self.debugSystem = new
	end
end

--[=[
	@client

	Switch the client to server view. This starts the server debugger if it isn't already started.
]=]
function Debugger:switchToServerView()
	if not IS_CLIENT then
		error("switchToServerView may only be called from the client.")
	end

	self.debugSystem = nil

	if not self.serverGui then
		self.serverGui = ReplicatedStorage:WaitForChild("MatterDebugger")

		self.serverGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	end

	remoteEvent:FireServer("start")

	self.serverGui.Enabled = true
end

--[=[
	Switch the client to client view. This stops the server debugger if there are no other players connected.
]=]
function Debugger:switchToClientView()
	if not IS_CLIENT then
		error("switchToClientView may only be called from the client.")
	end

	if not self.serverGui then
		return
	end

	remoteEvent:FireServer("stop")

	self.serverGui.Enabled = false
end

function Debugger:_isServerView()
	return self.serverGui and self.serverGui.Enabled
end

--[=[
	This should be called to draw the debugger UI.

	This is automatically set up when you call [Debugger:autoInitialize], so you don't need to call this yourself unless
	you didn't call `autoInitialize`.
]=]
function Debugger:update()
	ui(self, self.loop)

	table.clear(self._queries)

	if IS_CLIENT then
		mouseHighlight(self, remoteEvent)
	end
end

--[=[
	Returns a handle to the debug widgets you can pass to your systems.

	All [plasma widgets](https://eryn.io/plasma/api/Plasma#arrow) are available under this namespace.

	```lua
	-- ...
	local debugger = Debugger.new(Plasma)

	local loop = Loop.new(world, state, debugger:getWidgets())
	```

	When the Debugger is not open, calls to widgets are no-ops.

	If the widget normally returns a handle (e.g., button returns a table with `clicked`), it returns a static dummy
	handle that always returns a default value:

	- `checkbox`
		- `clicked`: false
		- `checked`: false
	- `button`
		- `clicked`: false
	- `slider`: 0

	@return {[string]: Widget}
]=]
function Debugger:getWidgets()
	return hookWidgets(self)
end

return Debugger
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="115">
                  <Properties>
                    <string name="Name">formatTable</string>
                    <string name="Source"><![CDATA[local FormatMode = {
	Short = "Short",
	Long = "Long",
}
local function formatTable(object, mode, _padLength, _depth)
	mode = mode or FormatMode.Short
	_padLength = _padLength or 0
	_depth = _depth or 1

	local max = if mode == FormatMode.Short then 7 else 1000

	local str = ""

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "{"
	end

	local values = {}

	for key, value in pairs(object) do
		table.insert(values, {
			key = key,
			value = value,
		})
	end

	table.sort(values, function(a, b)
		return tostring(a.key) < tostring(b.key)
	end)

	local count = 0
	for _, entry in values do
		local key = entry.key
		local value = entry.value

		local part = ""

		if count > 0 then
			part ..= ", "
		end

		if mode == FormatMode.Long then
			part ..= "\n" .. string.rep("  ", _depth - 1)
		end

		count += 1
		if type(key) == "string" then
			part ..= key .. (if mode == FormatMode.Short then "=" else " = ")
		elseif type(key) == "table" then
			if mode == FormatMode.Short then
				part ..= "[{..}]="
			else
				part ..= "["
				part ..= formatTable(key, FormatMode.Short, #str + #part + _padLength, _depth + 1)
				part ..= "] = "
			end
		end

		if type(value) == "string" then
			part ..= '"' .. value:sub(1, max) .. '"'
		elseif type(value) == "table" then
			if mode == FormatMode.Short then
				part ..= "{..}"
			else
				part ..= formatTable(value, FormatMode.Long, #str + #part + _padLength, _depth + 1)
			end
		elseif mode == FormatMode.Long and (type(value) == "userdata" or type(value) == "vector") then
			if typeof(value) == "CFrame" then
				part ..= string.format("CFrame(%.1f, %.1f, %.1f, ..)", value:components())
			else
				part ..= typeof(value) .. "(" .. tostring(value) .. ")"
			end
		else
			part ..= tostring(value):sub(1, max)
		end

		if mode == FormatMode.Short and #str + #part + _padLength > 30 then
			if count > 1 then
				str ..= ", "
			end

			str ..= ".."

			break
		else
			str ..= part
		end

		if mode == FormatMode.Short and #part + _padLength > 30 then
			part ..= ", .."
			break
		end
	end

	if mode == FormatMode.Long then
		str ..= "\n" .. string.rep("  ", _depth - 2)
	end

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "}"
	end

	return str
end

return {
	formatTable = formatTable,
	FormatMode = FormatMode,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="116">
                  <Properties>
                    <string name="Name">hookWidgets</string>
                    <string name="Source"><![CDATA[local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem

local widgets = {
	"arrow",
	"blur",
	"button",
	"checkbox",
	"error",
	"portal",
	"row",
	"slider",
	"spinner",
	"window",
	"label",
	"heading",
	"space",
	"table",
}

local dummyHandles = {
	checkbox = {
		clicked = function()
			return false
		end,
		checked = function()
			return false
		end,
	},

	button = {
		clicked = function()
			return false
		end,
	},

	slider = 0,

	window = {
		closed = function()
			return false
		end,
	},

	table = {
		selected = function() end,
		hovered = function() end,
	},
}

local function hookWidgets(debugger)
	local hookedWidgets = {}

	for _, name in widgets do
		local widget = debugger.plasma[name]

		hookedWidgets[name] = function(...)
			local debugSystem = debugger.debugSystem

			if debugSystem == nil or debugSystem ~= useCurrentSystem() then
				return dummyHandles[name]
			end

			if debugger._windowCount > 0 then
				return widget(...)
			end

			local args = table.pack(...)

			local parent = if name == "window" then debugger.parent else debugger.frame

			local returnValue
			debugger.plasma.portal(parent, function()
				returnValue = widget(unpack(args, 1, args.n))
			end)

			return returnValue
		end
	end

	local window = hookedWidgets.window
	hookedWidgets.window = function(title, fn)
		return window(title, function()
			debugger._windowCount += 1
			fn()
			debugger._windowCount -= 1
		end)
	end

	return hookedWidgets
end

return hookWidgets
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="117">
                  <Properties>
                    <string name="Name">hookWorld</string>
                    <string name="Source"><![CDATA[local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem
local World = require(script.Parent.Parent.World)

local originalQuery = World.query
local originalQueryChanged = World.queryChanged

local function hookWorld(debugger)
	World.query = function(world, ...)
		if useCurrentSystem() == debugger.debugSystem then
			table.insert(debugger._queries, {
				components = { ... },
				result = originalQuery(world, ...),
			})
		end

		return originalQuery(world, ...)
	end

	World.queryChanged = function(world, componentToTrack)
		if useCurrentSystem() == debugger.debugSystem then
			table.insert(debugger._queries, {
				changedComponent = componentToTrack,
			})
		end

		return originalQueryChanged(world, componentToTrack)
	end
end

local function unhookWorld()
	World.query = originalQuery
	World.queryChanged = originalQueryChanged
end

return {
	hookWorld = hookWorld,
	unhookWorld = unhookWorld,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="118">
                  <Properties>
                    <string name="Name">mouseHighlight</string>
                    <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local function mouseHighlight(debugger, remoteEvent)
	if not RunService:IsClient() then
		error("Hovering can only be checked on the client")
	end

	local lastSent, setLastSent = debugger.plasma.useState()

	if UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
		local mouse = Players.LocalPlayer:GetMouse()
		local instance = mouse.Target

		if mouse.Target then
			local id
			while instance.Parent do
				id = instance:GetAttribute(debugger:_isServerView() and "serverEntityId" or "clientEntityId")

				if id then
					break
				end

				instance = instance.Parent
			end

			if id then
				if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
					if debugger:_isServerView() then
						remoteEvent:FireServer("inspect", id)
					else
						debugger.debugEntity = id
					end
				else
					debugger.plasma.highlight(instance, {
						fillColor = Color3.fromRGB(218, 62, 62),
					})

					if debugger:_isServerView() then
						if lastSent ~= id then
							setLastSent(id)
							remoteEvent:FireServer("hover", id)
						end
					else
						debugger.hoverEntity = id
					end
				end

				return
			end
		end
	end

	if debugger:_isServerView() then
		if lastSent ~= nil then
			remoteEvent:FireServer("hover", nil)
			setLastSent(nil)
		end
	else
		debugger.hoverEntity = nil
	end
end

return mouseHighlight
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="119">
                  <Properties>
                    <string name="Name">ui</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local World = require(script.Parent.Parent.World)
local rollingAverage = require(script.Parent.Parent.rollingAverage)

local function systemName(system)
	local systemFn = if type(system) == "table" then system.system else system
	local name = debug.info(systemFn, "n")

	if name ~= "" and name ~= "system" then
		return name
	end

	local source = debug.info(systemFn, "s")
	local segments = string.split(source, ".")

	return segments[#segments]
end

local timeUnits = { "s", "ms", "μs", "ns" }
local function formatDuration(duration)
	local unit = 1
	while duration < 1 and unit < #timeUnits do
		duration *= 1000
		unit += 1
	end

	return duration, timeUnits[unit]
end

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()

local function ui(debugger, loop)
	local plasma = debugger.plasma
	local custom = debugger._customWidgets

	plasma.setStyle({
		primaryColor = Color3.fromHex("bd515c"),
	})

	local objectStack = plasma.useState({})
	local worldViewOpen, setWorldViewOpen = plasma.useState(false)

	if debugger.hoverEntity then
		custom.hoverInspect(debugger.debugWorld, debugger.hoverEntity, custom)
	end

	custom.container(function()
		if debugger:_isServerView() then
			return
		end

		custom.panel(function()
			if
				custom.realmSwitch({
					left = "client",
					right = "server",
					isRight = IS_SERVER,
					tag = if IS_SERVER then "MatterDebuggerSwitchToClientView" else nil,
				}):clicked()
			then
				if IS_CLIENT then
					debugger:switchToServerView()
				end
			end

			plasma.space(30)

			plasma.heading("STATE")
			plasma.space(10)

			local items = {}

			for index, object in loop._state do
				if type(object) ~= "table" then
					continue
				end

				local isWorld = getmetatable(object) == World

				local selected = (#objectStack > 0 and object == objectStack[#objectStack].value)
					or (debugger.debugWorld == object and worldViewOpen)

				table.insert(items, {
					text = (if isWorld then "World" else "table") .. " " .. index,
					icon = if isWorld then "🌐" else "{}",
					object = object,
					selected = selected,
					isWorld = isWorld,
				})
			end

			local selectedState = custom.selectionList(items):selected()

			if selectedState then
				if selectedState.isWorld then
					debugger.debugWorld = selectedState.object
					setWorldViewOpen(true)
				else
					table.clear(objectStack)

					objectStack[1] = {
						key = selectedState.text,
						icon = selectedState.icon,
						value = selectedState.object,
					}
				end
			end

			plasma.space(30)
			plasma.heading("SYSTEMS")
			plasma.space(10)

			for _, eventName in debugger._eventOrder do
				local systems = loop._orderedSystemsByEvent[eventName]

				if not systems then
					continue
				end

				plasma.heading(eventName, {
					font = Enum.Font.Gotham,
				})
				plasma.space(10)
				local items = {}

				for _, system in systems do
					local samples = loop.profiling[system]
					local averageFrameTime = ""
					local icon

					if samples then
						local duration = rollingAverage.getAverage(samples)

						if duration > 0.004 then -- 4ms
							icon = "\xe2\x9a\xa0\xef\xb8\x8f"
						end

						if loop._systemErrors[system] then
							icon = "\xf0\x9f\x92\xa5"
						end

						local humanDuration, unit = formatDuration(duration)

						averageFrameTime = string.format("%.0f%s", humanDuration, unit)
					end

					table.insert(items, {
						text = systemName(system),
						sideText = averageFrameTime,
						selected = debugger.debugSystem == system,
						system = system,
						icon = icon,
					})
				end

				local selected = custom.selectionList(items):selected()

				if selected then
					if selected.system == debugger.debugSystem then
						debugger.debugSystem = nil
					else
						debugger.debugSystem = selected.system
					end
				end

				plasma.space(20)
			end
		end)

		debugger.parent = custom.container(function()
			if debugger.debugWorld and worldViewOpen then
				local closed = custom.worldInspect(debugger, objectStack)

				if closed then
					setWorldViewOpen(false)
				end
			end

			if debugger.debugWorld and debugger.debugEntity then
				custom.entityInspect(debugger)
			end

			if #objectStack > 0 then
				custom.valueInspect(objectStack, custom)
			end

			if debugger.debugSystem then
				local queriesOpen, setQueriesOpen = plasma.useState(false)
				local logsOpen, setLogsOpen = plasma.useState(true)

				if loop._systemLogs[debugger.debugSystem] == nil then
					loop._systemLogs[debugger.debugSystem] = {}
				end

				local numLogs = #loop._systemLogs[debugger.debugSystem]

				local name = systemName(debugger.debugSystem)

				local closed = plasma.window({
					title = "System",
					closable = true,
				}, function()
					plasma.useKey(name)
					plasma.heading(name)
					plasma.space(0)

					plasma.row(function()
						if plasma.button(string.format("View queries (%d)", #debugger._queries)):clicked() then
							setQueriesOpen(true)
						end

						if numLogs > 0 then
							if plasma.button(string.format("View logs (%d)", numLogs)):clicked() then
								setLogsOpen(true)
							end
						end
					end)

					local currentlyDisabled = loop._skipSystems[debugger.debugSystem]

					if plasma.checkbox("Disable system", {
						checked = currentlyDisabled,
					}):clicked() then
						loop._skipSystems[debugger.debugSystem] = not currentlyDisabled
					end
				end):closed()

				if queriesOpen then
					local closed = custom.queryInspect(debugger)

					if closed then
						setQueriesOpen(false)
					end
				end

				if loop._systemErrors[debugger.debugSystem] then
					custom.errorInspect(debugger, custom)
				end

				plasma.useKey(name)

				if numLogs > 0 and logsOpen then
					local closed = plasma.window({
						closable = true,
						title = "Logs",
					}, function()
						local items = {}
						for i = numLogs, 1, -1 do
							table.insert(items, { loop._systemLogs[debugger.debugSystem][i] })
						end
						plasma.table(items, {
							font = Enum.Font.Code,
						})
					end):closed()

					if closed then
						setLogsOpen(false)
					end
				end

				if closed then
					debugger.debugSystem = nil
				end
			end

			debugger.frame = custom.frame()
		end, {
			marginTop = 46,
			marginLeft = 10,
			direction = Enum.FillDirection.Horizontal,
		})
	end, {
		direction = Enum.FillDirection.Horizontal,
		padding = 0,
	})
end

return ui
]]></string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="120">
                  <Properties>
                    <string name="Name">widgets</string>
                  </Properties>
                  <Item class="ModuleScript" referent="121">
                    <Properties>
                      <string name="Name">codeText</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local refs = Plasma.useInstance(function(ref)
			
			return create("TextButton", {
				[ref] = "label",
				BackgroundTransparency = 1,
				Text = "",
				AutomaticSize = Enum.AutomaticSize.Y,
				Font = Enum.Font.Code,
				TextSize = 22,
				TextStrokeTransparency = 0.5,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				TextColor3 = Color3.new(1, 1, 1),
				Size = UDim2.new(0, 800, 0, 0),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 8),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 8),
				}),
			})
		end)

		refs.label.Text = text
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="122">
                    <Properties>
                      <string name="Name">container</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(fn, options)
		options = options or {}

		local padding = options.padding or 10

		local refs = Plasma.useInstance(function(ref)
			return create("Frame", {
				[ref] = "frame",
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),

				create("UIPadding", {
					PaddingTop = UDim.new(0, options.marginTop or 0),
					PaddingLeft = UDim.new(0, options.marginLeft or 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = options.direction or Enum.FillDirection.Vertical,
					Padding = UDim.new(0, padding),
				}),
			})
		end)

		Plasma.scope(fn)

		return refs.frame
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="123">
                    <Properties>
                      <string name="Name">entityInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(debugger)
		local closed = plasma.window({
			title = string.format("Entity %d", debugger.debugEntity),
			closable = true,
		}, function()
			if not debugger.debugWorld:contains(debugger.debugEntity) then
				debugger.debugEntity = nil
				return
			end

			if debugger.findInstanceFromEntity then
				local model = debugger.findInstanceFromEntity(debugger.debugEntity)

				if model then
					plasma.highlight(model)
				end
			end

			plasma.row(function()
				if plasma.button("despawn"):clicked() then
					debugger.debugWorld:despawn(debugger.debugEntity)
					debugger.debugEntity = nil
				end
			end)

			if not debugger.debugEntity then
				return
			end

			local items = { { "Component", "Data" } }

			for component, data in debugger.debugWorld:_getEntity(debugger.debugEntity) do
				table.insert(items, {
					tostring(component),
					formatTable(data, FormatMode.Long),
				})
			end

			plasma.useKey(debugger.debugEntity)
			plasma.table(items, {
				headings = true,
				font = Enum.Font.Code,
			})
		end):closed()

		if closed then
			debugger.debugEntity = nil
		end
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="124">
                    <Properties>
                      <string name="Name">errorInspect</string>
                      <string name="Source"><![CDATA[return function(plasma)
	return plasma.widget(function(debugger, custom)
		local loop = debugger.loop

		plasma.window("\xf0\x9f\x92\xa5 Errors", function()
			local text, setText = plasma.useState("")

			custom.codeText(text)

			local items = {}
			for index, errorData in loop._systemErrors[debugger.debugSystem] do
				local preview = errorData.error
					:gsub("^(.-):", "")
					:gsub("^%s?[%w%.]+%.(%w+:)", "%1")
					:gsub("\n", " ")
					:sub(1, 60)

				items[index] = {
					DateTime.fromUnixTimestamp(errorData.when):ToIsoDate(),
					preview,

					errorData = errorData,
					selected = errorData.error == text,
				}
			end

			plasma.row(function()
				local selected = plasma.table(items, {
					selectable = true,
				}):selected()

				if selected then
					setText(selected.errorData.error)
				end

				if plasma.button("Clear"):clicked() then
					loop._systemErrors[debugger.debugSystem] = nil
				end
			end)
		end)
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="125">
                    <Properties>
                      <string name="Name">frame</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	return Plasma.widget(function()
		local refs = Plasma.useInstance(function(ref)
			local style = Plasma.useStyle()

			local Frame = Instance.new("Frame")
			Frame.BackgroundColor3 = style.bg2
			Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
			Frame.AnchorPoint = Vector2.new(0.5, 0.5)
			Frame.Size = UDim2.new(0, 50, 0, 40)
			Frame.Visible = false

			local UICorner = Instance.new("UICorner")
			UICorner.Parent = Frame

			local UIPadding = Instance.new("UIPadding")
			UIPadding.PaddingBottom = UDim.new(0, 20)
			UIPadding.PaddingLeft = UDim.new(0, 20)
			UIPadding.PaddingRight = UDim.new(0, 20)
			UIPadding.PaddingTop = UDim.new(0, 20)
			UIPadding.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Parent = Frame

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Padding = UDim.new(0, 10)
			UIListLayout.Parent = Frame

			local numChildren = #Frame:GetChildren()

			Plasma.automaticSize(Frame)

			local function updateVisibility()
				Frame.Visible = #Frame:GetChildren() > numChildren
			end

			Frame.ChildAdded:Connect(updateVisibility)
			Frame.ChildRemoved:Connect(updateVisibility)

			ref.frame = Frame

			return Frame
		end)

		return refs.frame
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="126">
                    <Properties>
                      <string name="Name">hoverInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(world, id, custom)
		local entityData = world:_getEntity(id)

		local str = "Entity " .. id .. "\n\n"

		for component, componentData in pairs(entityData) do
			str ..= tostring(component) .. " "

			if next(componentData) == nil then
				str ..= "{ }"
			else
				str ..= formatTable(componentData, FormatMode.Long, 0, 2)
			end
			str ..= "\n"
		end

		custom.tooltip(str)
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="127">
                    <Properties>
                      <string name="Name">link</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local clicked, setClicked = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local colorHover = style.textColor

			local darker = colorHover.R * 255 * 0.8 -- 20% darker
			local color = Color3.fromRGB(darker, darker, darker)

			local button = create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Text = "",
				Size = UDim2.new(0, 0, 0, 40),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					Name = "Icon",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 30, 1, 0),
					Text = options.icon,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 23,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamBold,
				}),

				create("TextLabel", {
					[ref] = "mainText",
					Name = "MainText",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 0, 1, 0),
					Text = text,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextColor3 = color,
					TextSize = 19,
				}),

				Activated = function()
					if options.disabled then
						return
					end

					setClicked(true)
				end,

				MouseEnter = function()
					if options.disabled then
						return
					end

					ref.button.MainText.TextColor3 = colorHover
				end,

				MouseLeave = function()
					ref.button.MainText.TextColor3 = color
				end,
			})

			Plasma.automaticSize(button)
			Plasma.automaticSize(ref.mainText, {
				axis = Enum.AutomaticSize.X,
			})

			return button
		end)

		refs.button.MainText.Text = text

		refs.button.Icon.Text = options.icon or ""
		refs.button.Icon.Visible = not not options.icon

		refs.mainText.Font = options.font or Enum.Font.SourceSans

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="128">
                    <Properties>
                      <string name="Name">panel</string>
                      <string name="Source"><![CDATA[local GuiService = game:GetService("GuiService")

return function(Plasma)
	local create = Plasma.create
	return Plasma.widget(function(children, options)
		options = options or {}

		Plasma.useInstance(function()
			local style = Plasma.useStyle()

			local frame = create("Frame", {
				Name = "Panel",
				BackgroundColor3 = style.bg2,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, 250, 1, 0),

				create("Frame", {
					-- Account for GUI inset
					-- GuiService:GetGuiInset returns wrong info on the server :(
					Size = UDim2.new(1, 0, 0, 46),
					BackgroundColor3 = Color3.new(0, 0, 0),
					BackgroundTransparency = 0.5,

					create("ImageLabel", {
						Position = UDim2.new(1, -20, 0.5, 0),
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 120, 0, 26),
						Image = "rbxassetid://10111567777",
					}),
				}),

				create("UIStroke", {}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
				}),

				create("ScrollingFrame", {
					BackgroundTransparency = 1,
					Name = "Container",
					VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					BorderSizePixel = 0,
					ScrollBarThickness = 6,
					Size = UDim2.new(1, -40, 0, 0),

					create("UIPadding", {
						PaddingTop = UDim.new(0, 20),
					}),

					create("UIListLayout", {
						SortOrder = Enum.SortOrder.LayoutOrder,
					}),
				}),
			})

			Plasma.automaticSize(frame.Container, {
				axis = Enum.AutomaticSize.Y,
				maxSize = UDim2.new(1, 0, 1, -46),
			})

			return frame, frame.Container
		end)

		Plasma.scope(children)
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="129">
                    <Properties>
                      <string name="Name">queryInspect</string>
                      <string name="Source"><![CDATA[local format = require(script.Parent.Parent.formatTable)

return function(plasma)
	return plasma.widget(function(debugger)
		return plasma.window({
			title = "Queries",
			closable = true,
		}, function()
			if #debugger._queries == 0 then
				return plasma.label("No queries.")
			end

			for i, query in debugger._queries do
				if query.changedComponent then
					plasma.heading(string.format("Query Changed %d", i))

					plasma.label(tostring(query.changedComponent))

					continue
				end

				plasma.heading(string.format("Query %d", i))

				local componentNames = {}

				for _, component in query.components do
					table.insert(componentNames, tostring(component))
				end

				plasma.label(table.concat(componentNames, ", "))

				local items = { { "ID", unpack(componentNames) } }

				while #items <= 10 do
					local data = { query.result:next() }

					if #data == 0 then
						break
					end

					for index, value in data do
						if type(value) == "table" then
							data[index] = format.formatTable(value)
						else
							data[index] = tostring(value)
						end
					end

					table.insert(items, data)
				end

				plasma.table(items, {
					headings = true,
				})

				if #items > 10 and query.result:next() then
					plasma.label("(further results truncated)")
				end
			end
		end):closed()
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="130">
                    <Properties>
                      <string name="Name">realmSwitch</string>
                      <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(options)
		local style = Plasma.useStyle()

		options = options or {}
		local left = options.left
		local right = options.right
		local isRight = options.isRight

		local clicked, setClicked = Plasma.useState(false)
		local refs = Plasma.useInstance(function(ref)
			ref.corner = create("UICorner")

			local style = Plasma.useStyle()

			create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 0, 30),
				Text = "",

				create("UICorner"),

				create("UIListLayout", {
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					[ref] = "left",
					Text = left,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.primaryColor,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 15,
				}),

				create("TextLabel", {
					[ref] = "right",
					Text = right,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.bg1,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 15,
				}),

				MouseEnter = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0.5
				end,

				MouseLeave = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0
				end,

				Activated = function()
					setClicked(true)
				end,
			})

			if options.tag then
				CollectionService:AddTag(ref.button, options.tag)
			end

			return ref.button
		end)

		refs.left.BackgroundColor3 = isRight and style.bg1 or style.primaryColor
		refs.right.BackgroundColor3 = isRight and style.primaryColor or style.bg1

		refs.corner.Parent = isRight and refs.right or refs.left

		local handle = {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}

		return handle
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="131">
                    <Properties>
                      <string name="Name">selectionList</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	local Item = Plasma.widget(function(text, selected, icon, sideText, width)
		local clicked, setClicked = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local button = create("TextButton", {
				[ref] = "button",
				Size = UDim2.new(1, 0, 0, 40),
				Text = "",

				create("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = Enum.FillDirection.Horizontal,
					Padding = UDim.new(0, 10),
				}),

				create("TextLabel", {
					Name = "Icon",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 22, 1, 0),
					Text = icon,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 23,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamBold,
				}),

				create("TextLabel", {
					AutomaticSize = Enum.AutomaticSize.X,
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 0, 1, 0),
					Text = text,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 19,
					TextColor3 = style.textColor,
					Font = Enum.Font.SourceSans,
					TextTruncate = Enum.TextTruncate.AtEnd,

					create("UISizeConstraint", {
						MaxSize = Vector2.new(165, math.huge),
					}),
				}),

				create("TextLabel", {
					[ref] = "sideText",
					BackgroundTransparency = 1,
					AutomaticSize = Enum.AutomaticSize.X,
					Size = UDim2.new(0, 0, 1, 0),
					Text = "",
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 15,
					TextColor3 = style.mutedTextColor,
					Font = Enum.Font.SourceSans,
				}),

				Activated = function()
					setClicked(true)
				end,
			})

			return button
		end)

		Plasma.useEffect(function()
			refs.button.TextLabel.Text = text
			refs.button.Icon.Text = icon or ""
			refs.button.Icon.Visible = not not icon
		end, text, icon)

		refs.sideText.Visible = not not sideText
		refs.sideText.Text = sideText or ""
		refs.sideText.TextColor3 = if selected then style.textColor else style.mutedTextColor
		refs.button.TextLabel.TextTruncate = sideText and Enum.TextTruncate.AtEnd or Enum.TextTruncate.None

		Plasma.useEffect(function()
			refs.button.BackgroundColor3 = if selected then style.primaryColor else style.bg2
		end, selected)

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}
	end)

	return Plasma.widget(function(items, options)
		options = options or {}

		Plasma.useInstance(function()
			local frame = create("Frame", {
				BackgroundTransparency = 1,
				Size = options.width and UDim2.new(0, options.width, 0, 0) or UDim2.new(1, 0, 0, 0),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),
			})

			Plasma.automaticSize(frame, {
				axis = Enum.AutomaticSize.Y,
			})

			return frame
		end)

		local selected

		for _, item in items do
			if Item(item.text, item.selected, item.icon, item.sideText, options.width):clicked() then
				selected = item
			end
		end

		return {
			selected = function()
				return selected
			end,
		}
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="132">
                    <Properties>
                      <string name="Name">tooltip</string>
                      <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
return function(plasma)
	local create = plasma.create

	return plasma.widget(function(text)
		local refs = plasma.useInstance(function(ref)
			local style = plasma.useStyle()

			create("TextLabel", {
				[ref] = "label",
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextSize = 20,
				BorderSizePixel = 0,
				Font = Enum.Font.Code,
				TextStrokeTransparency = 0.5,
				TextColor3 = Color3.new(1, 1, 1),
				BackgroundTransparency = 0.5,
				BackgroundColor3 = style.bg1,
				AutomaticSize = Enum.AutomaticSize.XY,

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 8),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 8),
				}),

				create("UICorner"),

				create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				}),
			})

			CollectionService:AddTag(ref.label, "MatterDebuggerTooltip")

			return ref.label
		end)

		refs.label.Text = text
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="133">
                    <Properties>
                      <string name="Name">valueInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

return function(plasma)
	return plasma.widget(function(objectStack, custom)
		local closed = plasma.window({
			title = "Inspect",
			closable = true,
		}, function()
			plasma.row({ padding = 5 }, function()
				for i, object in objectStack do
					if custom.link(object.key, {
						icon = object.icon or "{}",
					}):clicked() then
						local difference = #objectStack - i

						for _ = 1, difference do
							table.remove(objectStack, #objectStack)
						end
					end

					if i < #objectStack then
						custom.link("▶", {
							disabled = true,
						})
					end
				end
			end)

			local items = {}

			for key, value in pairs(objectStack[#objectStack].value) do
				local valueItem

				if type(value) == "table" then
					valueItem = function()
						if custom.link(formatTable(value), {
							font = Enum.Font.Code,
						}):clicked() then
							table.insert(objectStack, {
								key = if type(key) == "table" then formatTable(key) else tostring(key),
								value = value,
							})
						end
					end
				else
					valueItem = tostring(value)
				end

				table.insert(items, {
					tostring(key),
					valueItem,
				})
			end

			plasma.useKey(tostring(objectStack[#objectStack].key) .. ":" .. #objectStack)

			if #items == 0 then
				return plasma.label("(empty table)")
			end

			plasma.table(items)
		end):closed()

		if closed then
			table.clear(objectStack)
		end
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="134">
                    <Properties>
                      <string name="Name">worldInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

return function(plasma)
	return plasma.widget(function(debugger, objectStack)
		local custom = debugger._customWidgets
		local style = plasma.useStyle()

		local world = debugger.debugWorld

		local cache, setCache = plasma.useState()
		local debugComponent, setDebugComponent = plasma.useState()

		local closed = plasma.window({
			title = "World inspect",
			closable = true,
		}, function()
			local skipIntersections

			plasma.row(function()
				plasma.heading("Size")
				plasma.label(world:size())

				plasma.space(30)
				skipIntersections = plasma.checkbox("Hide intersecting components"):checked()

				if plasma.button("view raw"):clicked() then
					table.clear(objectStack)
					objectStack[1] = {
						value = world,
						key = "Raw World",
					}
				end
			end)

			if not cache or os.clock() - cache.createdTime > 3 then
				cache = {
					createdTime = os.clock(),
					uniqueComponents = {},
				}

				setCache(cache)

				for entityId, entityData in world do
					for component in entityData do
						cache.uniqueComponents[component] = (cache.uniqueComponents[component] or 0) + 1
					end
				end
			end

			local items = {}
			for component, count in cache.uniqueComponents do
				table.insert(items, {
					icon = count,
					text = tostring(component),
					component = component,
					selected = debugComponent == component,
				})
			end

			plasma.row({ padding = 30 }, function()
				local selectedItem = custom.selectionList(items, {
					width = 200,
				}):selected()

				if selectedItem then
					setDebugComponent(selectedItem.component)
				end

				if debugComponent then
					local items = { { "Entity ID", tostring(debugComponent) } }
					local intersectingComponents = {}

					local intersectingData = {}

					for entityId, data in world:query(debugComponent) do
						table.insert(items, {
							entityId,
							formatTable(data),

							selected = debugger.debugEntity == entityId,
						})

						intersectingData[entityId] = {}

						if skipIntersections then
							continue
						end

						for component, value in world:_getEntity(entityId) do
							if component == debugComponent then
								continue
							end

							local index = table.find(intersectingComponents, component)

							if not index then
								table.insert(intersectingComponents, component)

								index = #intersectingComponents
							end

							intersectingData[entityId][index] = value
						end
					end

					for i, item in items do
						if i == 1 then
							for _, component in intersectingComponents do
								table.insert(item, tostring(component))
							end

							continue
						end

						for i = 1, #intersectingComponents do
							local data = intersectingData[item[1]][i]

							table.insert(item, if data then formatTable(data) else "")
						end
					end

					plasma.useKey(tostring(debugComponent))

					local tableWidget = plasma.table(items, {
						font = Enum.Font.Code,
						selectable = true,
						headings = true,
					})

					local selectedRow = tableWidget:selected()
					local hovered = tableWidget:hovered()

					if selectedRow then
						debugger.debugEntity = selectedRow[1]
					end

					if hovered then
						local entityId = hovered[1]

						if debugger.debugEntity == entityId or not world:contains(entityId) then
							return
						end

						if debugger.findInstanceFromEntity then
							local model = debugger.findInstanceFromEntity(entityId)

							if model then
								plasma.highlight(model, {
									fillColor = style.primaryColor,
								})
							end
						end
					end
				end
			end)
		end):closed()

		if closed then
			return closed
		end
	end)
end
]]></string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
              <Item class="Folder" referent="135">
                <Properties>
                  <string name="Name">hooks</string>
                </Properties>
                <Item class="ModuleScript" referent="136">
                  <Properties>
                    <string name="Name">log</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local format = require(script.Parent.Parent.debugger.formatTable)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	@param ... any

	Logs some text. Readable in the Matter debugger.
]=]
local function log(...)
	local state = topoRuntime.useFrameState()

	if state.logs == nil then
		return
	end

	local segments = {}

	for i = 1, select("#", ...) do
		local value = select(i, ...)

		if type(value) == "table" then
			segments[i] = format.formatTable(value)
		else
			segments[i] = tostring(value)
		end
	end

	table.insert(state.logs, table.concat(segments, " "))

	if #state.logs > 100 then
		table.remove(state.logs, 1)
	end

	return state.deltaTime
end

return log
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="137">
                  <Properties>
                    <string name="Name">useDeltaTime</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Returns the `os.clock()` time delta between the start of this and last frame.
]=]
local function useDeltaTime(): number
	local state = topoRuntime.useFrameState()

	return state.deltaTime
end

return useDeltaTime
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="138">
                  <Properties>
                    <string name="Name">useEvent</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local Queue = require(script.Parent.Parent.Queue)

local EVENT_CONNECT_METHODS = { "Connect", "on", "connect" }
local CONNECTION_DISCONNECT_METHODS = { "Disconnect", "Destroy", "disconnect", "destroy" }

local function connect(object, callback, event)
	local eventObject = object

	if typeof(event) == "RBXScriptSignal" or type(event) == "table" then
		eventObject = event
	elseif type(event) == "string" then
		eventObject = object[event]
	end

	if type(eventObject) == "function" then
		return eventObject(object)
	elseif typeof(eventObject) == "RBXScriptSignal" then
		return eventObject:Connect(callback)
	end

	if type(eventObject) == "table" then
		for _, method in EVENT_CONNECT_METHODS do
			if type(eventObject[method]) ~= "function" then
				continue
			end

			return eventObject[method](eventObject, callback)
		end
	end

	error(
		"Couldn't connect to event as no valid connect methods were found! Ensure the passed event has a 'Connect' or an 'on' method!"
	)
end

local function disconnect(connection)
	if connection == nil then
		return
	end

	if type(connection) == "function" then
		connection()
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection[method]) ~= "function" then
			continue
		end

		connection[method](connection)
		break
	end
end

local function validateConnection(connection)
	if typeof(connection) == "function" or typeof(connection) == "RBXScriptConnection" then
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection) ~= "table" or connection[method] == nil then
			continue
		end

		return
	end

	error("Ensure passed event returns a cleanup function, or a table with a 'Disconnect' or a 'Destroy' method!")
end

local function cleanup(storage)
	disconnect(storage.connection)
	storage.queue = nil
end

--[=[
	@type ConnectionObject {Disconnect: (() -> ())?, Destroy: (() - >())?, disconnect: (() -> ())?, destroy: (() -> ())?} | () -> ()
	@within Matter

	A connection object returned by a custom event must be either a table with any of the following methods, or a cleanup function.
]=]

--[=[
	@interface CustomEvent
	@within Matter
	.Connect ((...) -> ConnectionObject)?
	.on ((...) -> ConnectionObject)?
	.connect ((...) -> ConnectionObject)?

	A custom event must have any of these 3 methods.
]=]

--[=[
	@within Matter
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Collects events that fire during the frame and allows iteration over event arguments.

	```lua
	for _, player in ipairs(Players:GetPlayers()) do
		for i, character in useEvent(player, "CharacterAdded") do
			world:spawn(
				Components.Target(),
				Components.Model({
					model = character,
				})
			)
		end
	end
	```

	Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments
	from the specified event.

	Events are returned in the order that they were fired.

	:::caution
	`useEvent` keys storage uniquely identified by **the script and line number** `useEvent` was called from, and the
	first parameter (instance). If the second parameter, `event`, is not equal to the event passed in for this unique
	storage last frame, the old event is disconnected from and the new one is connected in its place.

	Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with
	a variable. Dynamically changing the first parameter (instance) is fine.

	```lua
	for _, instance in pairs(someTable) do
		for i, arg1, arg2 in useEvent(instance, "Touched") do -- This is ok
		end
	end

	for _, instance in pairs(someTable) do
		local event = getEventSomehow()
		for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK
		end
	end
	```
	:::

	If `useEvent` ceases to be called on the same line with the same instance and event, the event connection is
	disconnected from automatically.

	You can also pass the actual event object instead of its name as the second parameter:

	```lua
	useEvent(instance, instance.Touched)
	useEvent(instance, instance:GetPropertyChangedSignal("Name"))
	```

	`useEvent` supports custom events as well, so you can pass in an object with a `Connect`, `connect` or `on` method.
	The object returned by any event must either be a cleanup function, or a table with a `Disconnect` or a `Destroy`
	method, so that `useEvent` can later clean it up when needed. See [ConnectionObject] for more information.

	@param instance Instance | CustomEvent -- The instance or a custom event that has the event you want to connect to
	@param event string | RBXScriptSignal -- The name of or actual event that you want to connect to
]=]
local function useEvent(instance, event): () -> (number, ...any)
	assert(instance ~= nil, "Instance is nil")
	assert(event ~= nil, "Event is nil")

	local storage = topoRuntime.useHookState(instance, cleanup)

	if storage.event ~= event then
		if storage.event then
			disconnect(storage.connection)
			warn("useEvent event changed:", storage.event, "->", event)
			table.clear(storage)
		end

		local queue = Queue.new()
		storage.queue = queue
		storage.event = event

		local connection = connect(instance, function(...)
			queue:pushBack(table.pack(...))
		end, event)

		validateConnection(connection)
		storage.connection = connection
	end

	local index = 0
	return function()
		index += 1

		local arguments = storage.queue:popFront()

		if arguments then
			return index, unpack(arguments, 1, arguments.n)
		end
	end
end

return useEvent
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="139">
                  <Properties>
                    <string name="Name">useEvent.spec</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local useEvent = require(script.Parent.useEvent)
local BindableEvent = require(script.Parent.Parent.mock.BindableEvent)

return function()
	describe("useEvent", function()
		it("should queue up events until useEvent is called again", function()
			local node = {
				system = {},
			}

			local event = BindableEvent.new()

			local a, b, c
			local shouldCall = true
			local shouldCount = 0
			local fn = function()
				if shouldCall then
					local count = 0
					for index, fa, fb, fc in useEvent(event, event.Event) do
						expect(index).to.equal(count + 1)
						count += 1
						a = fa
						b = fb
						c = fc
					end
					expect(count).to.equal(shouldCount)
				end
			end

			topoRuntime.start(node, fn)

			event:Fire(3, 4, 5)

			shouldCount = 1
			topoRuntime.start(node, fn)

			expect(a).to.equal(3)
			expect(b).to.equal(4)
			expect(c).to.equal(5)

			shouldCount = 3

			event:Fire()
			event:Fire()
			event:Fire()

			topoRuntime.start(node, fn)

			shouldCount = 0

			topoRuntime.start(node, fn)

			event:Fire()
			event:Fire()

			shouldCall = false

			topoRuntime.start(node, fn)

			shouldCall = true

			-- Count should still be 0 as last frame didn't call useEvent
			topoRuntime.start(node, fn)
		end)

		it("should cleanup if the event changes", function()
			local node = {
				system = {},
			}

			local event1 = BindableEvent.new()
			local event2 = BindableEvent.new()

			local event = event1
			local shouldCount = 0
			local fn = function()
				local count = 0
				for _ in useEvent(event, "Event") do
					count += 1
				end
				expect(count).to.equal(shouldCount)
			end

			topoRuntime.start(node, fn)

			event1:Fire()
			event1:Fire()

			shouldCount = 2
			topoRuntime.start(node, fn)

			event1:Fire()
			event1:Fire()
			event = event2

			shouldCount = 0
			topoRuntime.start(node, fn)

			event2:Fire()

			shouldCount = 1
			topoRuntime.start(node, fn)
		end)

		it("should support custom events", function()
			local disconnected = false
			local eventHandler

			local node = {
				system = {},
			}

			local event = {
				connect = function(self, handler)
					eventHandler = handler

					return {
						destroy = function()
							disconnected = true
						end,
					}
				end,
			}

			local object = {
				event = event,
			}

			local shouldRun = true
			local count = 0
			local function run()
				if shouldRun then
					for _ in useEvent(object, "event") do
						count += 1
					end
				end
			end

			topoRuntime.start(node, run)

			expect(count).to.equal(0)
			expect(eventHandler).to.be.ok()
			expect(disconnected).to.equal(false)

			eventHandler()
			eventHandler()

			topoRuntime.start(node, run)

			expect(count).to.equal(2)
			expect(eventHandler).to.be.ok()
			expect(disconnected).to.equal(false)

			shouldRun = false
			topoRuntime.start(node, run)

			expect(count).to.equal(2)
			expect(disconnected).to.equal(true)
		end)
	end)
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="140">
                  <Properties>
                    <string name="Name">useThrottle</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

local function cleanup(storage)
	return os.clock() < storage.expiry
end

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Utility for easy time-based throttling.

	Accepts a duration, and returns `true` if it has been that long since the last time this function returned `true`.
	Always returns `true` the first time.

	This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a
	unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can
	throttle doing something to each entity individually.

	```lua
	if useThrottle(1) then -- Keyed by script and line number only
		print("only prints every second")
	end

	for id, enemy in world:query(Enemy) do
		if useThrottle(5, id) then -- Keyed by script, line number, and the entity id
			print("Recalculate target...")
		end
	end
	```

	@param seconds number -- The number of seconds to throttle for
	@param discriminator? any -- A unique value to additionally key by
	@return boolean -- returns true every x seconds, otherwise false
]=]
local function useThrottle(seconds, discriminator)
	local storage = topoRuntime.useHookState(discriminator, cleanup)

	if storage.time == nil or os.clock() - storage.time >= seconds then
		storage.time = os.clock()
		storage.expiry = os.clock() + seconds
		return true
	end

	return false
end

return useThrottle
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="141">
                <Properties>
                  <string name="Name">immutable</string>
                  <string name="Source"><![CDATA[local None = {}

local function merge(one, two)
	local new = table.clone(one)

	for key, value in two do
		if value == None then
			new[key] = nil
		else
			new[key] = value
		end
	end

	return new
end

-- https://github.com/freddylist/llama/blob/master/src/List/toSet.lua
local function toSet(list)
	local set = {}

	for _, v in ipairs(list) do
		set[v] = true
	end

	return set
end

-- https://github.com/freddylist/llama/blob/master/src/Dictionary/values.lua
local function values(dictionary)
	local valuesList = {}

	local index = 1

	for _, value in pairs(dictionary) do
		valuesList[index] = value
		index = index + 1
	end

	return valuesList
end

return {
	None = None,
	merge = merge,
	toSet = toSet,
	values = values,
}
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="142">
                <Properties>
                  <string name="Name">mock</string>
                </Properties>
                <Item class="ModuleScript" referent="143">
                  <Properties>
                    <string name="Name">BindableEvent</string>
                    <string name="Source"><![CDATA[local BindableEvent = {}
BindableEvent.__index = BindableEvent

function BindableEvent.new()
	local self = setmetatable({
		_listeners = {},
		_locked = false,
	}, BindableEvent)

	self.Event = self

	return self
end

function BindableEvent:Connect(listener)
	table.insert(self._listeners, listener)

	return {
		Disconnect = function()
			local index = table.find(self._listeners, listener)

			if index then
				table.remove(self._listeners, index)
			end
		end,
	}
end

function BindableEvent:Fire(...)
	if self._locked then
		error("Cannot fire while firing")
	end

	self._locked = true
	for _, listener in self._listeners do
		local ok, errors = pcall(listener, ...)

		if not ok then
			warn(errors)
		end
	end
	self._locked = false
end

return BindableEvent
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="144">
                <Properties>
                  <string name="Name">rollingAverage</string>
                  <string name="Source"><![CDATA[local MAX_SAMPLES = 60

local function addSample(samples, value)
	samples[samples.index or 1] = value
	samples.index = if samples.index then (samples.index % MAX_SAMPLES) + 1 else 1
end

local function getAverage(samples)
	local sum = 0

	for i = 1, #samples do
		sum += samples[i]
	end

	return sum / #samples
end

return {
	addSample = addSample,
	getAverage = getAverage,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="145">
                <Properties>
                  <string name="Name">topoRuntime</string>
                  <string name="Source"><![CDATA[local stack = {}

local function newStackFrame(node)
	return {
		node = node,
		accessedKeys = {},
	}
end

local function cleanup()
	local currentFrame = stack[#stack]

	for baseKey, state in pairs(currentFrame.node.system) do
		for key, value in pairs(state.storage) do
			if not currentFrame.accessedKeys[baseKey] or not currentFrame.accessedKeys[baseKey][key] then
				local cleanupCallback = state.cleanupCallback

				if cleanupCallback then
					local shouldAbortCleanup = cleanupCallback(value)

					if shouldAbortCleanup then
						continue
					end
				end

				state.storage[key] = nil
			end
		end
	end
end

local function start(node, fn)
	table.insert(stack, newStackFrame(node))
	fn()
	cleanup()
	table.remove(stack, #stack)
end

local function withinTopoContext()
	return #stack ~= 0
end

local function useFrameState()
	return stack[#stack].node.frame
end

local function useCurrentSystem()
	if #stack == 0 then
		return
	end

	return stack[#stack].node.currentSystem
end

--[=[
	@within Matter

	:::tip
	**Don't use this function directly in your systems.**

	This function is used for implementing your own topologically-aware functions. It should not be used in your
	systems directly. You should use this function to implement your own utilities, similar to `useEvent` and
	`useThrottle`.
	:::

	`useHookState` does one thing: it returns a table. An empty, pristine table. Here's the cool thing though:
	it always returns the *same* table, based on the script and line where *your function* (the function calling
	`useHookState`) was called.

	### Uniqueness

	If your function is called multiple times from the same line, perhaps within a loop, the default behavior of
	`useHookState` is to uniquely identify these by call count, and will return a unique table for each call.

	However, you can override this behavior: you can choose to key by any other value. This means that in addition to
	script and line number, the storage will also only return the same table if the unique value (otherwise known as the
	"discriminator") is the same.

	### Cleaning up
	As a second optional parameter, you can pass a function that is automatically invoked when your storage is about
	to be cleaned up. This happens when your function (and by extension, `useHookState`) ceases to be called again
	next frame (keyed by script, line number, and discriminator).

	Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work,
	like disconnecting events.

	*Or*, you could return `true`, and abort cleaning up altogether. If you abort cleanup, your storage will stick
	around another frame (even if your function wasn't called again). This can be used when you know that the user will
	(or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for
	a number of seconds).

	If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup,
	or the user actually calls your function again.

	### Example: useThrottle

	This is the entire implementation of the built-in `useThrottle` function:

	```lua
	local function cleanup(storage)
		return os.clock() < storage.expiry
	end

	local function useThrottle(seconds, discriminator)
		local storage = useHookState(discriminator, cleanup)

		if storage.time == nil or os.clock() - storage.time >= seconds then
			storage.time = os.clock()
			storage.expiry = os.clock() + seconds
			return true
		end

		return false
	end
	```

	A lot of talk for something so simple, right?

	@param discriminator? any -- A unique value to additionally key by
	@param cleanupCallback (storage: {}) -> boolean? -- A function to run when the storage for this hook is cleaned up
]=]
local function useHookState(discriminator, cleanupCallback): {}
	local file, line = debug.info(3, "sl")
	local fn = debug.info(2, "f")

	local baseKey = string.format("%s:%s:%d", tostring(fn), file, line)

	local currentFrame = stack[#stack]

	if currentFrame == nil then
		error("Attempt to access topologically-aware storage outside of a Loop-system context.", 3)
	end

	if not currentFrame.accessedKeys[baseKey] then
		currentFrame.accessedKeys[baseKey] = {}
	end

	local accessedKeys = currentFrame.accessedKeys[baseKey]

	local key = #accessedKeys

	if discriminator ~= nil then
		if type(discriminator) == "number" then
			discriminator = tostring(discriminator)
		end

		key = discriminator
	end

	accessedKeys[key] = true

	if not currentFrame.node.system[baseKey] then
		currentFrame.node.system[baseKey] = {
			storage = {},
			cleanupCallback = cleanupCallback,
		}
	end

	local storage = currentFrame.node.system[baseKey].storage

	if not storage[key] then
		storage[key] = {}
	end

	return storage[key]
end

return {
	start = start,
	useHookState = useHookState,
	useFrameState = useFrameState,
	useCurrentSystem = useCurrentSystem,
	withinTopoContext = withinTopoContext,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="146">
                <Properties>
                  <string name="Name">topoRuntime.spec</string>
                  <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.topoRuntime)

return function()
	describe("TopoRuntime", function()
		it("should restore state", function()
			local function useHook()
				local storage = topoRuntime.useHookState()

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local ranCount = 0
			local function fn()
				ranCount += 1
				expect(useHook()).to.equal(ranCount)
			end

			topoRuntime.start(node, fn)

			topoRuntime.start(node, fn)

			expect(ranCount).to.equal(2)
		end)

		it("should cleanup", function()
			local shouldCleanup = false
			local cleanedUpCount = 0
			local function useHook()
				local storage = topoRuntime.useHookState(nil, function()
					if shouldCleanup then
						cleanedUpCount += 1
					else
						return true
					end
				end)

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local shouldRunHook = true
			local function fn()
				if shouldRunHook then
					expect(useHook()).to.equal(1)
				end
			end

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(0)

			shouldRunHook = false

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(0)

			shouldCleanup = true

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(1)

			shouldRunHook = true

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(1)
		end)

		it("should allow keying by unique values", function()
			local function useHook(unique)
				local storage = topoRuntime.useHookState(unique)

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local ranCount = 0
			local function fn()
				ranCount += 1
				expect(useHook("a value")).to.equal(ranCount)
			end

			topoRuntime.start(node, fn)

			topoRuntime.start(node, fn)

			expect(ranCount).to.equal(2)

			topoRuntime.start(node, function()
				fn()
				fn()
			end)

			expect(ranCount).to.equal(4)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="147">
            <Properties>
              <string name="Name">net</string>
            </Properties>
            <Item class="ModuleScript" referent="148">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local NetServerContext = TS.import(script, script, "server")
local NetClientContext = TS.import(script, script, "client")
local NetDefinitions = TS.import(script, script, "definitions").default
local NetMiddleware = TS.import(script, script, "middleware").NetMiddleware
--[[
	*
	* Networking Library for Roblox
	* @version 3.0
]]
local Net = {}
do
	local _container = Net
	--[[
		*
		* Legacy client API for Net
		* @deprecated
	]]
	local Client = NetClientContext
	_container.Client = Client
	--[[
		*
		* Legacy server API for Net
		* @deprecated
	]]
	local Server = NetServerContext
	_container.Server = Server
	--[[
		*
		* The definitions API for Net
	]]
	local Definitions = NetDefinitions
	_container.Definitions = Definitions
	--[[
		*
		* Utility types for Net
	]]
	local DIST = "TS"
	_container.DIST = DIST
	--[[
		*
		* The version of RbxNet
	]]
	local VERSION = "3.0.3"
	_container.VERSION = VERSION
	--[[
		*
		* Built-in middlewares
	]]
	local Middleware = NetMiddleware
	_container.Middleware = Middleware
	--[[
		*
		* Middleware function type for Net
	]]
	--[[
		*
		* Short-hand for `Net.Definitions.Create`
		* @see {@link Definitions.Create}
	]]
	local function CreateDefinitions(declarations, configuration)
		return Definitions.Create(declarations, configuration)
	end
	_container.CreateDefinitions = CreateDefinitions
end
local _ = nil
local _1 = nil
return Net
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="149">
                <Properties>
                  <string name="Name">client</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local Event = TS.import(script, script, "ClientEvent").default
local Function = TS.import(script, script, "ClientFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="150">
                  <Properties>
                    <string name="Name">ClientAsyncFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
--[[
	*
	* An event that behaves like a function
	* @rbxts client
]]
local ClientAsyncFunction
do
	ClientAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ClientAsyncFunction"
		end,
	})
	ClientAsyncFunction.__index = ClientAsyncFunction
	function ClientAsyncFunction.new(...)
		local self = setmetatable({}, ClientAsyncFunction)
		return self:constructor(...) or self
	end
	function ClientAsyncFunction:constructor(name)
		self.name = name
		self.timeout = 60
		self.listeners = {}
		self.instance = getRemoteOrThrow("AsyncRemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientAsyncFunction on the Server!")
	end
	function ClientAsyncFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("AsyncRemoteFunction", name, 60))
			resolve(ClientAsyncFunction.new(name))
		end))
	end
	function ClientAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
	end
	function ClientAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ClientAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnClientEvent:Connect(TS.async(function(...)
			local args = { ... }
			local _binding = args
			local eventId = _binding[1]
			local data = _binding[2]
			if type(eventId) == "string" and type(data) == "table" then
				local result = callback(unpack(data))
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireServer(eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to server: " .. err)
					end)
				else
					self.instance:FireServer(eventId, result)
				end
			else
				warn("Recieved message without eventId")
			end
		end))
	end
	ClientAsyncFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call AsyncFunction '" .. (self.name .. "' - which has no user defined callback"))
		end
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireServer(id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnClientEvent:Connect(function(...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" then
					if eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			local warned = false
			local elapsedTime = 0
			repeat
				do
					elapsedTime += (RunService.Heartbeat:Wait())
					if elapsedTime >= 20 and not warned then
						warned = true
						warn("[rbx-net] CallServerAsync(...) - still waiting for result from remote '" .. (self.name .. "'"))
						print(debug.traceback("", 3))
					end
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to server timed out after " .. tostring(self.timeout) .. " seconds")
			end
		end)
	end)
end
return {
	default = ClientAsyncFunction,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="151">
                  <Properties>
                    <string name="Name">ClientEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
--[[
	*
	* Interface for client listening events
]]
--[[
	*
	* Interface for client sender events
]]
local ClientEvent
do
	ClientEvent = setmetatable({}, {
		__tostring = function()
			return "ClientEvent"
		end,
	})
	ClientEvent.__index = ClientEvent
	function ClientEvent.new(...)
		local self = setmetatable({}, ClientEvent)
		return self:constructor(...) or self
	end
	function ClientEvent:constructor(name)
		self.instance = getRemoteOrThrow("RemoteEvent", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot fetch NetClientEvent on the server!")
	end
	function ClientEvent:GetInstance()
		return self.instance
	end
	function ClientEvent:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteEvent", name, 60))
			resolve(ClientEvent.new(name))
		end))
	end
	function ClientEvent:SendToServer(...)
		local args = { ... }
		self.instance:FireServer(unpack(args))
	end
	function ClientEvent:Connect(callback)
		return self.instance.OnClientEvent:Connect(callback)
	end
end
local default = ClientEvent
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="152">
                  <Properties>
                    <string name="Name">ClientFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local CollectionService = game:GetService("CollectionService")
local ClientFunction
do
	ClientFunction = setmetatable({}, {
		__tostring = function()
			return "ClientFunction"
		end,
	})
	ClientFunction.__index = ClientFunction
	function ClientFunction.new(...)
		local self = setmetatable({}, ClientFunction)
		return self:constructor(...) or self
	end
	function ClientFunction:constructor(name)
		self.name = name
		self.instance = getRemoteOrThrow("RemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientFunction on the Server!")
	end
	function ClientFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteFunction", name, 60))
			resolve(ClientFunction.new(name))
		end))
	end
	function ClientFunction:CallServer(...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call Function '" .. (self.name .. "' - which has no user defined callback"))
		end
		return self.instance:InvokeServer(unpack(args))
	end
	ClientFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		return TS.Promise.defer(function(resolve)
			local result = self.instance:InvokeServer(unpack(args))
			resolve(result)
		end)
	end)
end
return {
	default = ClientFunction,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="153">
                <Properties>
                  <string name="Name">definitions</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- eslint-disable @typescript-eslint/no-explicit-any
local DeclarationTypeCheck = TS.import(script, script, "Types").DeclarationTypeCheck
local ServerDefinitionBuilder = TS.import(script, script, "ServerDefinitionBuilder").ServerDefinitionBuilder
local ClientDefinitionBuilder = TS.import(script, script, "ClientDefinitionBuilder").ClientDefinitionBuilder
local NamespaceBuilder = TS.import(script, script, "NamespaceBuilder").NamespaceBuilder
local NetDefinitions = {}
do
	local _container = NetDefinitions
	--[[
		*
		* Validates the specified declarations to ensure they're valid before usage
		* @param declarations The declarations
	]]
	local function validateDeclarations(declarations)
		for _, declaration in pairs(declarations) do
			local _arg0 = DeclarationTypeCheck.check(declaration.Type)
			local _errorMessage = DeclarationTypeCheck.errorMessage
			assert(_arg0, _errorMessage)
		end
	end
	--[[
		*
		* Creates definitions for Remote instances that can be used on both the client and server.
		* @description https://docs.vorlias.com/rbx-net/docs/3.0/definitions#definitions-oh-my
		* @param declarations
	]]
	local function Create(declarations, configuration)
		if configuration == nil then
			configuration = {}
		end
		validateDeclarations(declarations)
		local _arg0 = {
			Server = ServerDefinitionBuilder.new(declarations, configuration),
			Client = ClientDefinitionBuilder.new(declarations, configuration),
		}
		return _arg0
	end
	_container.Create = Create
	--[[
		*
		* Defines a namespace of remote definitions, which can be retrieved via `GetNamespace(namespaceId)`
		*
		* E.g.
		* ```ts
		* const Remotes = Net.Definitions.Create({
		* 		ExampleGroup: Net.Definitions.Namespace({
		* 			ExampleGroupRemote: Net.Definitions.ServerToClientEvent<[message: string]>(),
		* 		}),
		* });
		* const ExampleGroupRemote = Remotes.Server.GetNamespace("ExampleGroup").Create("ExampleGroupRemote");
		* ```
		*
		* This is useful for categorizing remotes by feature.
	]]
	local function Namespace(declarations, configuration)
		return {
			Type = "Namespace",
			Definitions = NamespaceBuilder.new(declarations, configuration),
		}
	end
	_container.Namespace = Namespace
	--[[
		*
		* Defines a function in which strictly the client can call the server asynchronously
		*
		* `Client` [`Calls`] -> `Server` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Server` [`Responds to Call`] -> `Client` [`Recieves Response`]
	]]
	local function ServerAsyncFunction(mw)
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_container.ServerAsyncFunction = ServerAsyncFunction
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* **_Note_: Unlike other definitions in Net, this is only available on the server.**
		*
		* Defines an event in which allows broadcasting messages between servers in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`]
		*
		* or at a target {@link DataModel.JobId JobId}
		*
		* `Source Server [`Broadcasts`] -> `Target Server` [`Recieves Broadcast`]
		*
	]]
	local function ExperienceBroadcastEvent()
		return {
			Type = "Messaging",
		}
	end
	_container.ExperienceBroadcastEvent = ExperienceBroadcastEvent
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* Defines an event that allows a server to broadcast to all or specified _clients_ in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`] -> `Client` [`Recieves Forwarded Broadcast`]
		*
		* @hidden Experimental API
		* @deprecated Not yet official API, could be changed or removed.
		* @internal
	]]
	local function EXPERIMENTAL_ExperienceReplicatedEvent()
		return {
			Type = "ExperienceEvent",
		}
	end
	_container.EXPERIMENTAL_ExperienceReplicatedEvent = EXPERIMENTAL_ExperienceReplicatedEvent
	--[[
		*
		* Defines a function in which strictly the server can call the client asynchronously
		*
		* `Server` [`Calls`] -> `Client` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Client` [`Responds to Call`] -> `Server` [`Recieves Response`]
	]]
	local function ClientAsyncFunction()
		return {
			Type = "AsyncFunction",
		}
	end
	_container.ClientAsyncFunction = ClientAsyncFunction
	--[[
		*
		* Defines a regular function in which strictly the client can call the server synchronously
		*
		* (Synchronous) `Client` [`Calls`, `Recieves Response`] <- (yields for response) -> `Server` [`Recieves Call`, `Responds`]
	]]
	local function ServerFunction(mw)
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_container.ServerFunction = ServerFunction
	--[[
		*
		* Defines an event in which strictly the server fires an event that is recieved by clients
		*
		* `Server` [`Sends`] => `Client(s)` [`Recieves`]
		*
		* On the client, this will give an event that can use `Connect`.
		*
		* On the server, this will give an event that can use `SendToPlayer`, `SendToAllPlayers`, `SendToAllPlayersExcept`
		*
	]]
	local function ServerToClientEvent()
		return {
			ServerMiddleware = {},
			Type = "Event",
		}
	end
	_container.ServerToClientEvent = ServerToClientEvent
	--[[
		*
		* Defines an event in which strictly clients fire an event that's recieved by the server
		*
		* `Client(s)` [`Sends`] => `Server` [`Recieves`]
		*
		* On the client, this will give an event that can use `SendToServer`.
		*
		* On the server, this will give an event that can use `Connect`.
		*
		* @param mw The middleware of this event.
	]]
	local function ClientToServerEvent(mw)
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_container.ClientToServerEvent = ClientToServerEvent
	--[[
		*
		* Defines a remote event that can be fired both from the client and server
		*
		* This should only be required in rare use cases where `ClientToServerEvent` or `ServerToClientEvent` is not sufficient.
		*
		* Check to see if {@link ServerAsyncFunction} is more sufficient for your use case.
	]]
	local function BidirectionalEvent()
		return {
			Type = "Event",
			ServerMiddleware = {},
		}
	end
	_container.BidirectionalEvent = BidirectionalEvent
end
local default = NetDefinitions
return {
	default = default,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="154">
                  <Properties>
                    <string name="Name">ClientDefinitionBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientAsyncFunction = TS.import(script, script.Parent.Parent, "client", "ClientAsyncFunction").default
local ClientEvent = TS.import(script, script.Parent.Parent, "client", "ClientEvent").default
local ClientFunction = TS.import(script, script.Parent.Parent, "client", "ClientFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local shouldYield = setmetatable({}, {
	__mode = "k",
})
local ClientDefinitionBuilder
do
	ClientDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ClientDefinitionBuilder"
		end,
	})
	ClientDefinitionBuilder.__index = ClientDefinitionBuilder
	function ClientDefinitionBuilder.new(...)
		local self = setmetatable({}, ClientDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ClientDefinitionBuilder:constructor(declarations, configuration, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.configuration = configuration
		self.namespace = namespace
		local _self = self
		declarationMap[_self] = declarations
		local _exp = self
		local _result = configuration
		if _result ~= nil then
			_result = _result.ClientGetShouldYield
		end
		local _condition = _result
		if _condition == nil then
			_condition = true
		end
		shouldYield[_exp] = _condition
	end
	function ClientDefinitionBuilder:toString()
		return "[" .. ("ClientDefinitionBuilder" .. "]")
	end
	function ClientDefinitionBuilder:Get(remoteId)
		local _self = self
		if shouldYield[_self] then
			return self:WaitFor(remoteId):expect()
		else
			return self:GetOrThrow(remoteId)
		end
	end
	function ClientDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.configuration or {})
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildClientDefinition(_exp, _result)
	end
	function ClientDefinitionBuilder:GetOrThrow(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		if item.Type == "Function" then
			return ClientFunction.new(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent.new(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction.new(remoteId)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent.new(getGlobalRemote(remoteId))
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end
	ClientDefinitionBuilder.WaitFor = TS.async(function(self, remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		if item.Type == "Function" then
			return ClientFunction:Wait(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent:Wait(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction:Wait(remoteId)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent:Wait(getGlobalRemote(remoteId))
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end)
	ClientDefinitionBuilder.OnEvent = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		return result:Connect(fn)
	end)
	ClientDefinitionBuilder.OnFunction = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		result:SetCallback(fn)
	end)
	function ClientDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ClientDefinitionBuilder = ClientDefinitionBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="155">
                  <Properties>
                    <string name="Name">NamespaceBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientDefinitionBuilder = TS.import(script, script.Parent, "ClientDefinitionBuilder").ClientDefinitionBuilder
local ServerDefinitionBuilder = TS.import(script, script.Parent, "ServerDefinitionBuilder").ServerDefinitionBuilder
local RunService = game:GetService("RunService")
-- Isolate the definitions since we don't need to access them anywhere else.
local declarationMap = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	* A namespace builder. Internally used to construct definition builders
]]
local NamespaceBuilder
do
	NamespaceBuilder = setmetatable({}, {
		__tostring = function()
			return "NamespaceBuilder"
		end,
	})
	NamespaceBuilder.__index = NamespaceBuilder
	function NamespaceBuilder.new(...)
		local self = setmetatable({}, NamespaceBuilder)
		return self:constructor(...) or self
	end
	function NamespaceBuilder:constructor(declarations, config)
		self.config = config
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
	end
	function NamespaceBuilder:_CombineConfigurations(parentConfig)
		local _object = {}
		for _k, _v in pairs(parentConfig) do
			_object[_k] = _v
		end
		local _spread = self.config
		if type(_spread) == "table" then
			for _k, _v in pairs(_spread) do
				_object[_k] = _v
			end
		end
		local newConfig = _object
		return newConfig
	end
	function NamespaceBuilder:_BuildServerDefinition(configuration, namespace)
		local _arg0 = RunService:IsServer()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ServerDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
	function NamespaceBuilder:_BuildClientDefinition(configuration, namespace)
		local _arg0 = RunService:IsClient()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ClientDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
end
return {
	NamespaceBuilder = NamespaceBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="156">
                  <Properties>
                    <string name="Name">ServerDefinitionBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerAsyncFunction = TS.import(script, script.Parent.Parent, "server", "ServerAsyncFunction").default
local ServerEvent = TS.import(script, script.Parent.Parent, "server", "ServerEvent").default
local ServerFunction = TS.import(script, script.Parent.Parent, "server", "ServerFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
local ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent").default
local ServerMessagingEvent = TS.import(script, script.Parent.Parent, "server", "ServerMessagingEvent").default
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
-- Tidy up all the types here.
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local remoteEventCache = {}
local remoteAsyncFunctionCache = {}
local remoteFunctionCache = {}
local messagingEventCache = {}
local messagingServerEventCache = {}
local ServerDefinitionBuilder
do
	ServerDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ServerDefinitionBuilder"
		end,
	})
	ServerDefinitionBuilder.__index = ServerDefinitionBuilder
	function ServerDefinitionBuilder.new(...)
		local self = setmetatable({}, ServerDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ServerDefinitionBuilder:constructor(declarations, config, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.config = config
		self.namespace = namespace
		local _binding = config
		local AutoGenerateServerRemotes = _binding.ServerAutoGenerateRemotes
		if AutoGenerateServerRemotes == nil then
			AutoGenerateServerRemotes = true
		end
		local GlobalMiddleware = _binding.ServerGlobalMiddleware
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
		-- We only run remote creation on the server
		if RunService:IsServer() and AutoGenerateServerRemotes then
			self:_InitServer()
		end
		self.globalMiddleware = GlobalMiddleware
	end
	function ServerDefinitionBuilder:_CreateOrGetInstance(id, declaration)
		local _arg0 = RunService:IsServer()
		assert(_arg0, "Can only create server instances on the server")
		--[[
			*
			* This is used to generate or fetch the specified remote from a declaration
			*
			* The generated remote id is based off the current namespace.
		]]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, id }, _nAMESPACE_SEPARATOR)
		else
			_result = id
		end
		local namespacedId = _result
		if declaration.Type == "Function" then
			local func
			if remoteFunctionCache[namespacedId] ~= nil then
				return remoteFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					func = ServerFunction.new(namespacedId, declaration.ServerMiddleware)
				else
					func = ServerFunction.new(namespacedId)
				end
				CollectionService:AddTag(func:GetInstance(), "NetDefinitionManaged")
				local _func = func
				remoteFunctionCache[namespacedId] = _func
				local _result_1 = self.globalMiddleware
				if _result_1 ~= nil then
					local _arg0_1 = function(mw)
						return func:_use(mw)
					end
					for _k, _v in ipairs(_result_1) do
						_arg0_1(_v, _k - 1, _result_1)
					end
				end
				return func
			end
		elseif declaration.Type == "AsyncFunction" then
			local asyncFunction
			-- This should make certain use cases cheaper
			if remoteAsyncFunctionCache[namespacedId] ~= nil then
				return remoteAsyncFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					asyncFunction = ServerAsyncFunction.new(namespacedId, declaration.ServerMiddleware)
				else
					asyncFunction = ServerAsyncFunction.new(namespacedId)
				end
				CollectionService:AddTag(asyncFunction:GetInstance(), "NetDefinitionManaged")
				local _asyncFunction = asyncFunction
				remoteAsyncFunctionCache[namespacedId] = _asyncFunction
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return asyncFunction:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return asyncFunction
		elseif declaration.Type == "Event" then
			local event
			-- This should make certain use cases cheaper
			if remoteEventCache[namespacedId] ~= nil then
				return remoteEventCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					event = ServerEvent.new(namespacedId, declaration.ServerMiddleware)
				else
					event = ServerEvent.new(namespacedId)
				end
				CollectionService:AddTag(event:GetInstance(), "NetDefinitionManaged")
				local _event = event
				remoteEventCache[namespacedId] = _event
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return event:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return event
		elseif declaration.Type == "Messaging" then
			local event
			if messagingEventCache[namespacedId] ~= nil then
				return messagingEventCache[namespacedId]
			else
				event = ExperienceBroadcastEvent.new(namespacedId)
				local _event = event
				messagingEventCache[namespacedId] = _event
			end
			return event
		elseif declaration.Type == "ExperienceEvent" then
			local event
			if messagingServerEventCache[namespacedId] ~= nil then
				return messagingServerEventCache[namespacedId]
			else
				event = ServerMessagingEvent.new(namespacedId)
				local _event = event
				messagingServerEventCache[namespacedId] = _event
			end
			return event
		else
			error("Unhandled type")
		end
	end
	function ServerDefinitionBuilder:_InitServer()
		--[[
			*
			* Used to generate all the remotes on the server-side straight away.
			*
			* So long as the remote declaration file is imported, and it's the server this _should_ run.
			*
			* This will fix https://github.com/roblox-aurora/rbx-net/issues/57, which is a long standing race-condition issue
			* I, as well as many other users have run into from time to time.
		]]
		local _ = nil
		local _1 = nil
		local _self = self
		local declarations = declarationMap[_self]
		for id, declaration in pairs(declarations) do
			local _exp = declaration.Type
			repeat
				local _fallthrough = false
				if _exp == "Event" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "AsyncFunction" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Function" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Messaging" then
					self:_CreateOrGetInstance(id, declaration)
					break
				end
				if _exp == "Namespace" then
					self:GetNamespace(id)
					break
				end
			until true
		end
	end
	function ServerDefinitionBuilder:toString()
		return "[" .. ("ServerDefinitionBuilder" .. "]")
	end
	function ServerDefinitionBuilder:OnEvent(name, fn)
		local result = self:Get(name)
		return result:Connect(fn)
	end
	function ServerDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.config)
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildServerDefinition(_exp, _result)
	end
	function ServerDefinitionBuilder:Get(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		if item.Type == "Function" or (item.Type == "AsyncFunction" or (item.Type == "Event" or item.Type == "Messaging")) then
			if remoteAsyncFunctionCache[remoteId] ~= nil then
				local _ = nil
				local _1 = nil
				return remoteAsyncFunctionCache[remoteId]
			else
				return self:_CreateOrGetInstance(remoteId, item)
			end
		else
			error("Invalid type for " .. remoteId)
		end
	end
	function ServerDefinitionBuilder:Create(remoteId)
		return self:Get(remoteId)
	end
	function ServerDefinitionBuilder:OnFunction(name, fn)
		local result = self:Get(name)
		result:SetCallback(fn)
	end
	function ServerDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ServerDefinitionBuilder = ServerDefinitionBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="157">
                  <Properties>
                    <string name="Name">Types</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* Types
	*
	* I will admit, this is a lot of type spaghetti. It makes the definitions work good though. :D
]]
local oneOf = TS.import(script, script.Parent.Parent, "internal", "validator").oneOf
--[[
	*
	* The DefinitionBuilders type
]]
--[[
	*
	* @deprecated
]]
--[[
	*
	* A declaration for an async client function
]]
--[[
	*
	* A declaration for an async server function
]]
-- * @deprecated
--[[
	*
	* A declaration for a client -> server event
]]
--[[
	*
	* A declaration for a server -> client event
]]
--[[
	*
	* A declaration for a server -> server event
]]
--[[
	*
	* A declaration for a server -> server event, that replicates to clients
]]
--[[
	*
	* A declaration for a Bidirectional event
]]
--[[
	*
	* A declaration group
]]
-- //////////////////////////////
-- * Inference Magic
-- /////////////////////////////
--[[
	*
	* This infers the client remote type based on the given value
]]
--[[
	*
	* This infers the server remote type based on the given value
]]
-- ///////////////////////////////////////
-- * Results
-- ///////////////////////////////////////
local DeclarationTypeCheck = oneOf("Event", "Function", "AsyncFunction", "Namespace", "Messaging", "ExperienceEvent")
return {
	DeclarationTypeCheck = DeclarationTypeCheck,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="158">
                <Properties>
                  <string name="Name">internal</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local HttpService = game:GetService("HttpService")
local runService = game:GetService("RunService")
local collectionService = game:GetService("CollectionService")
-- * @internal
local NAMESPACE_SEPARATOR = "/"
-- * @internal
local NAMESPACE_ROOT = "@"
-- * @internal
local IS_SERVER = not runService:IsRunning() or runService:IsServer()
-- * @internal
local IS_CLIENT = runService:IsRunning() and runService:IsClient()
local IS_RUNNING = runService:IsRunning()
-- * @internal
local MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10
-- * @internal
local function getGlobalRemote(name)
	return ":\\" .. name
end
-- * @internal
local function isLuaTable(value)
	return type(value) == "table"
end
-- * @internal
local NetMiddlewareEvent
do
	NetMiddlewareEvent = setmetatable({}, {
		__tostring = function()
			return "NetMiddlewareEvent"
		end,
	})
	NetMiddlewareEvent.__index = NetMiddlewareEvent
	function NetMiddlewareEvent.new(...)
		local self = setmetatable({}, NetMiddlewareEvent)
		return self:constructor(...) or self
	end
	function NetMiddlewareEvent:constructor(netInstance)
		self.netInstance = netInstance
	end
	function NetMiddlewareEvent:GetInstance()
		return self.netInstance:GetInstance()
	end
end
local REMOTES_FOLDER_NAME = "_NetManaged"
-- * @internal
-- * @internal
local ServerTickFunctions = {}
-- * @internal
local function findOrCreateFolder(parent, name)
	local folder = parent:FindFirstChild(name)
	if folder then
		return folder
	else
		folder = Instance.new("Folder", parent)
		folder.Name = name
		return folder
	end
end
-- const dist = $env<"TS" | "Luau" | "TestTS">("TYPE", "TS");
local location = script.Parent
local _ = nil
local _1 = nil
local remoteFolder = findOrCreateFolder(location, REMOTES_FOLDER_NAME)
--[[
	*
	* Errors with variables formatted in a message
	* @param message The message
	* @param vars variables to pass to the error message
]]
local function errorft(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	error(message, 2)
end
local traceSet = {}
local function warnOnce(message)
	local trace = debug.traceback()
	if traceSet[trace] ~= nil then
		return nil
	end
	traceSet[trace] = true
	warn("[rbx-net] " .. message)
end
local function format(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	return message
end
-- * @internal
local findRemote
local function waitForRemote(remoteType, name, timeout)
	return TS.Promise.defer(function(resolve, reject)
		local i = 0
		local result
		repeat
			do
				local step = runService.Heartbeat:Wait()
				i += step
				result = findRemote(remoteType, name)
			end
		until not (i < timeout and not result)
		if result then
			resolve(result)
		else
			reject("Timed out while waiting for " .. (remoteType .. (" '" .. (name .. ("' after " .. (tostring(timeout) .. " seconds."))))))
		end
	end)
end
-- * @internal
function findRemote(remoteType, name)
	if remoteType == "AsyncRemoteFunction" then
		local _exp = collectionService:GetTagged("NetManagedAsyncFunction")
		local _arg0 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _result
		for _i, _v in ipairs(_exp) do
			if _arg0(_v, _i - 1, _exp) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _result
	elseif remoteType == "RemoteEvent" then
		local _exp = collectionService:GetTagged("NetManagedEvent")
		local _arg0 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _result
		for _i, _v in ipairs(_exp) do
			if _arg0(_v, _i - 1, _exp) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _result
	elseif remoteType == "RemoteFunction" then
		local _exp = collectionService:GetTagged("NetManagedLegacyFunction")
		local _arg0 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _result
		for _i, _v in ipairs(_exp) do
			if _arg0(_v, _i - 1, _exp) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _result
	end
	error("Invalid Remote Access")
end
-- * @internal
local function getRemoteOrThrow(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		return existing
	else
		error("Could not find Remote of type " .. (remoteType .. (' called "' .. (name .. '"'))))
	end
end
-- * @internal
local function findOrCreateRemote(remoteType, name, onCreate)
	local existing = findRemote(remoteType, name)
	if existing then
		if collectionService:HasTag(existing, "NetDefinitionManaged") then
			warnOnce("Fetching " .. (remoteType .. (" '" .. (name .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe."))))
		end
		return existing
	else
		if not IS_SERVER then
			error("Creation of Events or Functions must be done on server!")
		end
		local remote
		if remoteType == "RemoteEvent" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedEvent")
		elseif remoteType == "AsyncRemoteFunction" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedAsyncFunction")
		elseif remoteType == "RemoteFunction" then
			remote = Instance.new("RemoteFunction")
			collectionService:AddTag(remote, "NetManagedLegacyFunction")
		else
			error("Invalid Remote Type: " .. remoteType)
		end
		remote.Name = name
		remote.Parent = remoteFolder
		local _2 = nil
		local _3 = nil
		local _result = onCreate
		if _result ~= nil then
			_result(remote)
		end
		return remote
	end
end
-- * @internal
local function checkArguments(types, args)
	if args == nil then
		warn("[net-types] Argument length is zero")
		return false
	end
	do
		local i = 0
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i < #types) then
				break
			end
			local typeCheck = types[i + 1]
			local value = args[i + 1]
			if not typeCheck(value) then
				warn("[net-types] Argument at index " .. (tostring(i) .. " was invalid type."))
				return false
			end
		end
	end
	return true
end
if IS_SERVER then
	game:GetService("RunService").Stepped:Connect(function(time, step)
		for _2, f in ipairs(ServerTickFunctions) do
			f()
		end
	end)
end
return {
	getGlobalRemote = getGlobalRemote,
	isLuaTable = isLuaTable,
	findOrCreateFolder = findOrCreateFolder,
	errorft = errorft,
	warnOnce = warnOnce,
	format = format,
	waitForRemote = waitForRemote,
	findRemote = findRemote,
	getRemoteOrThrow = getRemoteOrThrow,
	findOrCreateRemote = findOrCreateRemote,
	checkArguments = checkArguments,
	NAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR,
	NAMESPACE_ROOT = NAMESPACE_ROOT,
	IS_SERVER = IS_SERVER,
	IS_CLIENT = IS_CLIENT,
	IS_RUNNING = IS_RUNNING,
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = MAX_CLIENT_WAITFORCHILD_TIMEOUT,
	NetMiddlewareEvent = NetMiddlewareEvent,
	ServerTickFunctions = ServerTickFunctions,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="159">
                  <Properties>
                    <string name="Name">tables</string>
                    <string name="Source">local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

return {
	mixed = isMixed
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="160">
                  <Properties>
                    <string name="Name">validator</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local isMixed = TS.import(script, script.Parent, "tables").isMixed
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- * @internal
local isSerializable
local function validateArguments(...)
	local args = { ... }
	for index, value in ipairs(args) do
		if not isSerializable.check(value) then
			error(string.format(isSerializable.errorMessage, index), 2)
		end
		if typeof(value) == "Instance" then
			if value:IsDescendantOf(ServerStorage) or value:IsDescendantOf(ServerScriptService) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is inside a server-only container and cannot be sent via remotes."))
			end
			if not value:IsDescendantOf(game) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is not a valid descendant of game, and wont replicate"))
			end
		end
	end
end
-- * @internal
isSerializable = {
	errorMessage = "Argument #%d is not serializable. - see http://docs.vorlias.com/rbx-net/docs/2.0/serialization",
	check = function(value)
		-- Can't allow functions or threads
		if type(value) == "function" or type(value) == "thread" then
			return false
		end
		-- Can't allow metatabled objects
		if type(value) == "table" and getmetatable(value) ~= nil then
			return false
		end
		-- Ensure not a mixed table type
		if type(value) == "table" then
			return not isMixed(value)
		end
		return true
	end,
}
-- * @internal
local function oneOf(...)
	local values = { ... }
	return {
		errorMessage = "Expected one of: " .. table.concat(values, ", "),
		check = function(value)
			if not (type(value) == "string") then
				return false
			end
			for _, cmpValue in ipairs(values) do
				if value == cmpValue then
					return true
				end
			end
			return false
		end,
	}
end
return {
	validateArguments = validateArguments,
	oneOf = oneOf,
	isSerializable = isSerializable,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="161">
                <Properties>
                  <string name="Name">messaging</string>
                </Properties>
                <Item class="ModuleScript" referent="162">
                  <Properties>
                    <string name="Name">ExperienceBroadcastEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local isLuaTable = _internal.isLuaTable
local ServerTickFunctions = _internal.ServerTickFunctions
-- const MessagingService = game.GetService("MessagingService");
local MessagingService = TS.import(script, script.Parent, "MessagingService")
local Players = game:GetService("Players")
local IS_STUDIO = game:GetService("RunService"):IsStudio()
--[[
	*
	* Checks if a value matches that of a subscription message
	* @param value The value
]]
local function isSubscriptionMessage(value)
	if isLuaTable(value) then
		local hasData = value.Data ~= nil
		return hasData
	else
		return false
	end
end
local function isJobTargetMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.jobId ~= nil
		end
	end
	return false
end
local globalMessageQueue = {}
local lastQueueTick = 0
local globalEventMessageCounter = 0
local globalSubscriptionCounter = 0
local ExperienceBroadcastEvent
local function processMessageQueue()
	if tick() >= lastQueueTick + 60 then
		globalEventMessageCounter = 0
		globalSubscriptionCounter = 0
		lastQueueTick = tick()
		while #globalMessageQueue > 0 do
			-- ▼ Array.pop ▼
			local _length = #globalMessageQueue
			local _result = globalMessageQueue[_length]
			globalMessageQueue[_length] = nil
			-- ▲ Array.pop ▲
			local message = _result
			MessagingService:PublishAsync(message.Name, message.Data)
			globalEventMessageCounter += 1
		end
		if globalEventMessageCounter >= ExperienceBroadcastEvent:GetMessageLimit() then
			warn("[rbx-net] Too many messages are being sent, any further messages will be queued!")
		end
	end
end
--[[
	*
	* Message Size: 1kB
	* MessagesPerMin: 150 + 60 * NUMPLAYERS
	* MessagesPerTopicMin: 30M
	* MessagesPerUniversePerMin: 30M
	* SubsPerServer: 5 + 2 * numPlayers
	* SubsPerUniverse: 10K
]]
--[[
	*
	* An event that works across all servers
	* @see https://developer.roblox.com/api-reference/class/MessagingService for limits, etc.
]]
do
	ExperienceBroadcastEvent = setmetatable({}, {
		__tostring = function()
			return "ExperienceBroadcastEvent"
		end,
	})
	ExperienceBroadcastEvent.__index = ExperienceBroadcastEvent
	function ExperienceBroadcastEvent.new(...)
		local self = setmetatable({}, ExperienceBroadcastEvent)
		return self:constructor(...) or self
	end
	function ExperienceBroadcastEvent:constructor(name)
		self.name = name
	end
	function ExperienceBroadcastEvent:GetMessageLimit()
		return 150 + 60 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:GetSubscriptionLimit()
		return 5 + 2 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:sendToAllServersOrQueue(data)
		local limit = ExperienceBroadcastEvent:GetMessageLimit()
		if globalEventMessageCounter >= limit then
			warn("[rbx-net] Exceeded message limit of " .. (tostring(limit) .. ", adding to queue..."))
			local _arg0 = {
				Name = self.name,
				Data = data,
			}
			table.insert(globalMessageQueue, _arg0)
		else
			globalEventMessageCounter += 1
			-- Since this yields
			MessagingService:PublishAsync(self.name, data)
		end
	end
	function ExperienceBroadcastEvent:SendToServer(serverJobId, sendData)
		self:sendToAllServersOrQueue({
			jobId = serverJobId,
			message = sendData,
		})
	end
	function ExperienceBroadcastEvent:SendToAllServers(sendData)
		self:sendToAllServersOrQueue(sendData)
	end
	function ExperienceBroadcastEvent:Connect(handler)
		local limit = ExperienceBroadcastEvent:GetSubscriptionLimit()
		if globalSubscriptionCounter >= limit then
			error("[rbx-net] Exceeded Subscription limit of " .. (tostring(limit) .. "!"))
		end
		globalSubscriptionCounter += 1
		return MessagingService:SubscribeAsync(self.name, function(message)
			local recieved = message
			local _binding = recieved
			local Sent = _binding.Sent
			if isJobTargetMessage(recieved) then
				local _binding_1 = recieved
				local Data = _binding_1.Data
				if game.JobId == Data.JobId then
					handler(Data.InnerData, Sent)
				end
			else
				handler(recieved.Data, Sent)
			end
		end)
	end
end
table.insert(ServerTickFunctions, processMessageQueue)
return {
	isSubscriptionMessage = isSubscriptionMessage,
	default = ExperienceBroadcastEvent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="163">
                  <Properties>
                    <string name="Name">MessagingService</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local MessagingService = game:GetService("MessagingService")

local MockMessagingService = {}
local topics = {}

function MockMessagingService:PublishAsync(topicName, message)
	local topic = topics[topicName]
	if topic then
		topic:Fire(
			{
				Sent = tick(),
				Data = message
			}
		)
	end
end

function MockMessagingService:SubscribeAsync(topicName, callback)
	local topic = topics[topicName]
	if not topic then
		topic = Instance.new("BindableEvent")
		topic.Parent = script
		topic.Name = topicName
		topics[topicName] = topic
	end

	return topic.Event:Connect(callback)
end

local service
if RunService:IsStudio() then
    service = MockMessagingService
else
    service = MessagingService
end


return service</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="164">
                <Properties>
                  <string name="Name">middleware</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local createLoggerMiddleware = TS.import(script, script, "LoggerMiddleware")
local createRateLimiter = TS.import(script, script, "RateLimitMiddleware").default
local NetTypeCheckingMiddleware = TS.import(script, script, "TypeCheckMiddleware")
local NetMiddleware = {}
do
	local _container = NetMiddleware
	local RateLimit = createRateLimiter
	_container.RateLimit = RateLimit
	local Logging = createLoggerMiddleware
	_container.Logging = Logging
	-- * The type checking middleware
	local TypeChecking = NetTypeCheckingMiddleware
	_container.TypeChecking = TypeChecking
	--[[
		*
		* Creates a global read-only middleware for use in `Net.Definitions` global middleware.
	]]
	local function Global(middleware)
		local _arg0 = function(processNext, event)
			return function(sender, ...)
				local args = { ... }
				middleware(event:GetInstance().Name, args, sender)
				return processNext(sender, unpack(args))
			end
		end
		return _arg0
	end
	_container.Global = Global
end
local createTypeChecker = NetTypeCheckingMiddleware
return {
	NetMiddleware = NetMiddleware,
	createRateLimiter = createRateLimiter,
	createTypeChecker = createTypeChecker,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="165">
                  <Properties>
                    <string name="Name">LoggerMiddleware</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio()

local function defaultLogger(name, args)
    if IS_STUDIO then
        local str = {};
        for _, arg in ipairs(args) do
            table.insert(str, HttpService:JSONEncode(arg))
        end
        print("[rbx-net] Called", name, "with arguments", "[ " .. table.concat(str, ", ") .. " ]")
    end
end

return function(options)
    options = options or {}
    local logger = options.Logger or defaultLogger

    return function (next, event)
        local name = options.Name or event:GetInstance().Name
        return function(player, ...)
            logger(name, {...})
            return next(player, ...)
        end
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="166">
                  <Properties>
                    <string name="Name">RateLimitMiddleware</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local format = _internal.format
local IS_SERVER = _internal.IS_SERVER
local ServerTickFunctions = _internal.ServerTickFunctions
local throttler = TS.import(script, script, "throttle")
local throttles = {}
local function rateLimitWarningHandler(rateLimitError)
	warn("[rbx-net]", rateLimitError.Message)
end
local THROTTLE_RESET_TIMER = 60
--[[
	*
	* Creates a throttle middleware for this event
	*
	* Will limit the amount of requests a player can make to this event
	*
	* _NOTE: Must be used before **other** middlewares as it's not a type altering middleware_
	* @param maxRequestsPerMinute The maximum requests per minute
]]
local function createRateLimiter(options)
	local maxRequestsPerMinute = options.MaxRequestsPerMinute
	local errorHandler = options.ErrorHandler or rateLimitWarningHandler
	local _condition = options.ThrottleMessage
	if _condition == nil then
		_condition = "Request limit exceeded ({limit}) by {player} via {remote}"
	end
	local throttleMessage = _condition
	return function(processNext, event)
		local instance = event:GetInstance()
		local throttle = throttles[event]
		if throttle == nil then
			throttle = throttler:Get(instance:GetFullName())
		end
		return function(player, ...)
			local args = { ... }
			local count = throttle:Get(player)
			if count >= maxRequestsPerMinute then
				local _result = errorHandler
				if _result ~= nil then
					_result({
						Message = format(throttleMessage, {
							player = player.UserId,
							remote = instance.Name,
							limit = maxRequestsPerMinute,
						}),
						MaxRequestsPerMinute = maxRequestsPerMinute,
						RemoteId = instance.Name,
						UserId = player.UserId,
					})
				end
			else
				throttle:Increment(player)
				return processNext(player, unpack(args))
			end
		end
	end
end
if IS_SERVER then
	local lastTick = 0
	local _arg0 = function()
		if tick() > lastTick + THROTTLE_RESET_TIMER then
			lastTick = tick()
			throttler:Clear()
		end
	end
	table.insert(ServerTickFunctions, _arg0)
end
local default = createRateLimiter
return {
	rateLimitWarningHandler = rateLimitWarningHandler,
	default = default,
}
]]></string>
                  </Properties>
                  <Item class="ModuleScript" referent="167">
                    <Properties>
                      <string name="Name">throttle</string>
                      <string name="Source"><![CDATA[local Throttle = {
	counters = {}
}
local RequestCounter = {}
RequestCounter.__index = RequestCounter

function RequestCounter.new()
	local self = {
		counter = {}
	}

	return setmetatable(self, RequestCounter)
end

function RequestCounter:Get(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]
	return playerQueue or 0
end

function RequestCounter:Increment(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]

	if not counter[player.UserId] then
		counter[player.UserId] = 1
	else
		counter[player.UserId] = playerQueue + 1
	end
end

function RequestCounter:__tostring()
	return "RequestCounter"
end

function RequestCounter:ClearAll()
	self.counter = {}
end

function Throttle:Get(name)
	local existing = self.counters[name]
	if (existing) then
		return existing
	else
		local newCounter = RequestCounter.new()
		self.counters[name] = newCounter
		return newCounter
	end
end

function Throttle:Clear()
	for _, counter in pairs(self.counters) do
		counter:ClearAll()
	end
end

return Throttle
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="168">
                  <Properties>
                    <string name="Name">TypeCheckMiddleware</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio();

local function defaultErrorHandler(event, args, index)
    local name = event:GetInstance().Name
    if IS_STUDIO then
        warn("[TypeCheckMiddleware] Call to " .. name .. " failed")
        warn("\tRecieved: " .. HttpService:JSONEncode(args))
        warn("\tInvalid argument at index " .. tostring(index))
    end
end

local MiddlewareGlobal = {}
MiddlewareGlobal.__index = MiddlewareGlobal
MiddlewareGlobal.defaultErrorHandler = defaultErrorHandler

local function typeCheckMiddleware(...)
    local checks = {...}
    local MiddlewareInstance = {}
    MiddlewareInstance.__index = MiddlewareInstance;

    function MiddlewareInstance:next(next, event)
        local errorHandler = self.errorHandler or MiddlewareGlobal.defaultErrorHandler
        --  what's returned as callbackFn
        return function(player, ...)
            local args = {...}
            for index, check in ipairs(checks) do
                if not check(args[index]) then
                    pcall(errorHandler, event, args, index)
                    return false
                end
            end

            -- Invoke the next middleware OR the callback (if none left)
            return next(player, ...)
        end
    end

    function MiddlewareInstance.__tostring()
        return "TypeCheckMiddleware"
    end

    function MiddlewareInstance:WithErrorHandler(fn)
        self.errorHandler = fn
        return self
    end

    function MiddlewareInstance:__call(...)
        return self:next(...)
    end
    
    return setmetatable({}, MiddlewareInstance)
    -- ^ The middleware
end

function MiddlewareGlobal.__call(_, ...)
    return typeCheckMiddleware(...)
end

function MiddlewareGlobal.SetDefaultErrorHandler(_, fn)
    MiddlewareGlobal.defaultErrorHandler = fn
end

return setmetatable({}, MiddlewareGlobal)</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="169">
                <Properties>
                  <string name="Name">server</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ServerAsyncFunction").default
local Event = TS.import(script, script, "ServerEvent").default
local MessagingEvent = TS.import(script, script, "ServerMessagingEvent").default
local Function = TS.import(script, script, "ServerFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
	MessagingEvent = MessagingEvent,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="170">
                  <Properties>
                    <string name="Name">CreateServerListener</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerEventV2 = TS.import(script, script.Parent, "ServerEvent").default
local function isMiddlewareArgument(args)
	local _condition = #args > 1
	if _condition then
		local _arg0 = args[1]
		_condition = type(_arg0) == "table"
	end
	return _condition
end
--[[
	*
	* Creates a server listening event
]]
local function createServerListener(id, ...)
	local args = { ... }
	local event
	if isMiddlewareArgument(args) then
		local _binding = args
		local middleware = _binding[1]
		local connect = _binding[2]
		event = ServerEventV2.new(id, middleware)
		return event:Connect(connect)
	else
		local _binding = args
		local connect = _binding[1]
		event = ServerEventV2.new(id)
		return event:Connect(connect)
	end
end
return {
	default = createServerListener,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="171">
                  <Properties>
                    <string name="Name">MiddlewareEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- * @internal
local MiddlewareEvent
do
	MiddlewareEvent = {}
	function MiddlewareEvent:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareEvent:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareEvent:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			local _arg0 = type(middlewares) == "table"
			local _arg1 = "The middleware argument should be an array of middlewares not a " .. typeof(middlewares)
			assert(_arg0, _arg1)
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareEvent
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="172">
                  <Properties>
                    <string name="Name">MiddlewareFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local MiddlewareFunction
do
	MiddlewareFunction = {}
	function MiddlewareFunction:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareFunction:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareFunction:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareFunction
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="173">
                  <Properties>
                    <string name="Name">NetServerScriptSignal</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* A wrapper around a RBXScriptSignal for remotes, that always has a listener set.
]]
local NetServerScriptSignal
do
	NetServerScriptSignal = setmetatable({}, {
		__tostring = function()
			return "NetServerScriptSignal"
		end,
	})
	NetServerScriptSignal.__index = NetServerScriptSignal
	function NetServerScriptSignal.new(...)
		local self = setmetatable({}, NetServerScriptSignal)
		return self:constructor(...) or self
	end
	function NetServerScriptSignal:constructor(signalInstance, instance)
		self.signalInstance = signalInstance
		self.instance = instance
		self.connections = {}
		self.connectionRefs = setmetatable({}, {
			__mode = "k",
		})
		self.defaultConnectionDelegate = (function(player, ...)
			local args = { ... }
		end)
		self.defaultConnection = signalInstance:Connect(self.defaultConnectionDelegate)
		local sig
		sig = self.instance.AncestryChanged:Connect(function(child, parent)
			if child == instance and parent == nil then
				self:DisconnectAll()
				sig:Disconnect()
			end
		end)
	end
	function NetServerScriptSignal:Connect(callback)
		if self.defaultConnection then
			self.defaultConnection:Disconnect()
			self.defaultConnection = nil
		end
		local connection = self.signalInstance:Connect(callback)
		local _connections = self.connections
		table.insert(_connections, connection)
		local ref
		local _arg0 = {
			NetSignal = self,
			RBXSignal = connection,
			Connected = connection.Connected,
			Disconnect = function(self)
				local _connections_1 = self.NetSignal.connections
				local _arg0_1 = function(f)
					return f == ref
				end
				-- ▼ ReadonlyArray.findIndex ▼
				local _result = -1
				for _i, _v in ipairs(_connections_1) do
					if _arg0_1(_v, _i - 1, _connections_1) == true then
						_result = _i - 1
						break
					end
				end
				-- ▲ ReadonlyArray.findIndex ▲
				local idx = _result
				if idx ~= -1 then
					self.NetSignal:DisconnectAt(idx)
					self.Connected = false
				end
			end,
		}
		ref = _arg0
		self.connectionRefs[ref] = true
		return ref
	end
	function NetServerScriptSignal:Wait()
		return self.signalInstance:Wait()
	end
	function NetServerScriptSignal:WaitAsync()
		return TS.Promise.defer(function(resolve)
			local result = { self.signalInstance:Wait() }
			resolve(result)
		end)
	end
	function NetServerScriptSignal:GetCount()
		return #self.connections
	end
	function NetServerScriptSignal:DisconnectAt(index)
		local connection = self.connections[index + 1]
		if connection then
			connection:Disconnect()
			table.remove(self.connections, index + 1)
		end
		if #self.connections == 0 then
			self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
		end
	end
	function NetServerScriptSignal:DisconnectAll()
		for _, connection in ipairs(self.connections) do
			connection:Disconnect()
		end
		table.clear(self.connections)
		for ref in pairs(self.connectionRefs) do
			ref.Connected = false
		end
		table.clear(self.connectionRefs)
		self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
	end
end
return {
	NetServerScriptSignal = NetServerScriptSignal,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="174">
                  <Properties>
                    <string name="Name">ServerAsyncFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local function isEventArgs(value)
	if #value < 2 then
		return false
	end
	local _binding = value
	local eventId = _binding[1]
	local data = _binding[2]
	return type(eventId) == "string" and type(data) == "table"
end
--[[
	*
	* An asynchronous function for two way communication between the client and server
]]
local ServerAsyncFunction
do
	local super = MiddlewareEvent
	ServerAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ServerAsyncFunction"
		end,
		__index = super,
	})
	ServerAsyncFunction.__index = ServerAsyncFunction
	function ServerAsyncFunction.new(...)
		local self = setmetatable({}, ServerAsyncFunction)
		return self:constructor(...) or self
	end
	function ServerAsyncFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.timeout = 10
		self.listeners = {}
		self.instance = findOrCreateRemote("AsyncRemoteFunction", name, function(instance)
			-- Default connection
			self.defaultHook = instance.OnServerEvent:Connect(ServerAsyncFunction.DefaultEventHook)
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerAsyncFunction on the client!")
	end
	function ServerAsyncFunction:GetInstance()
		return self.instance
	end
	function ServerAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
		return self
	end
	function ServerAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ServerAsyncFunction:SetCallback(callback)
		if self.defaultHook ~= nil then
			self.defaultHook:Disconnect()
			self.defaultHook = nil
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnServerEvent:Connect(TS.async(function(player, ...)
			local args = { ... }
			if isEventArgs(args) then
				local _binding = args
				local eventId = _binding[1]
				local data = _binding[2]
				local _result = self:_processMiddleware(callback)
				if _result ~= nil then
					_result = _result(player, unpack(data))
				end
				local result = _result
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireClient(player, eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to client: " .. err)
					end)
				else
					self.instance:FireClient(player, eventId, result)
				end
			else
				warn("[rbx-net-async] Recieved message without eventId")
			end
		end))
	end
	ServerAsyncFunction.CallPlayerAsync = TS.async(function(self, player, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireClient(player, id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnServerEvent:Connect(function(fromPlayer, ...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" and data ~= nil then
					if player == player and eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			repeat
				do
					RunService.Stepped:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to client timed out")
			end
		end)
	end)
	ServerAsyncFunction.DefaultEventHook = function(player, ...)
		local args = { ... }
	end
end
local default = ServerAsyncFunction
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="175">
                  <Properties>
                    <string name="Name">ServerEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local IS_RUNNING = _internal.IS_RUNNING
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local NetServerScriptSignal = TS.import(script, script.Parent, "NetServerScriptSignal").NetServerScriptSignal
--[[
	*
	* Interface for server listening events
]]
--[[
	*
	* Interface for server sender events
]]
local ServerEvent
do
	local super = MiddlewareEvent
	ServerEvent = setmetatable({}, {
		__tostring = function()
			return "ServerEvent"
		end,
		__index = super,
	})
	ServerEvent.__index = ServerEvent
	function ServerEvent.new(...)
		local self = setmetatable({}, ServerEvent)
		return self:constructor(...) or self
	end
	function ServerEvent:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerEvent on the client!")
		self.instance = findOrCreateRemote("RemoteEvent", name)
		self.connection = NetServerScriptSignal.new(self.instance.OnServerEvent, self.instance)
	end
	function ServerEvent:GetInstance()
		return self.instance
	end
	function ServerEvent:Connect(callback)
		return self.connection:Connect(function(player, ...)
			local args = { ... }
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result(player, unpack(args))
			end
		end)
	end
	function ServerEvent:SendToAllPlayers(...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireAllClients(unpack(args))
	end
	function ServerEvent:SendToAllPlayersExcept(blacklist, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		local Players = game:GetService("Players")
		if typeof(blacklist) == "Instance" then
			local _exp = Players:GetPlayers()
			local _arg0 = function(p)
				return p ~= blacklist
			end
			-- ▼ ReadonlyArray.filter ▼
			local _newValue = {}
			local _length = 0
			for _k, _v in ipairs(_exp) do
				if _arg0(_v, _k - 1, _exp) == true then
					_length += 1
					_newValue[_length] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local otherPlayers = _newValue
			for _, player in ipairs(otherPlayers) do
				self.instance:FireClient(player, unpack(args))
			end
		elseif type(blacklist) == "table" then
			for _, player in ipairs(Players:GetPlayers()) do
				if (table.find(blacklist, player) or 0) - 1 == -1 then
					self.instance:FireClient(player, unpack(args))
				end
			end
		end
	end
	function ServerEvent:SendToPlayer(player, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireClient(player, unpack(args))
	end
	function ServerEvent:SendToPlayers(players, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		for _, player in ipairs(players) do
			self:SendToPlayer(player, unpack(args))
		end
	end
end
return {
	default = ServerEvent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="176">
                  <Properties>
                    <string name="Name">ServerFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_SERVER = _internal.IS_SERVER
local MiddlewareFunction = TS.import(script, script.Parent, "MiddlewareFunction").default
local CollectionService = game:GetService("CollectionService")
local ServerFunction
do
	local super = MiddlewareFunction
	ServerFunction = setmetatable({}, {
		__tostring = function()
			return "ServerFunction"
		end,
		__index = super,
	})
	ServerFunction.__index = ServerFunction
	function ServerFunction.new(...)
		local self = setmetatable({}, ServerFunction)
		return self:constructor(...) or self
	end
	function ServerFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.instance = findOrCreateRemote("RemoteFunction", name, function(instance)
			-- Default listener
			instance.OnServerInvoke = ServerFunction.DefaultFunctionHook
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		assert(IS_SERVER, "Cannot create a Net.ServerFunction on the Client!")
	end
	function ServerFunction:GetInstance()
		return self.instance
	end
	function ServerFunction:SetCallback(callback)
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		self.instance.OnServerInvoke = function(player, ...)
			local args = { ... }
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result = _result(player, unpack(args))
			end
			local result = _result
			if TS.Promise.is(result) then
				warn("[rbx-net] WARNING: Promises should be used with an AsyncFunction!")
				local success, value = result:await()
				if success then
					return value
				else
					error(value)
				end
			end
			return result
		end
	end
	ServerFunction.DefaultFunctionHook = function()
		-- TODO: 2.2 make usable for analytics?
		-- Although, unlike `Event`, this will need to be part of `SetCallback`'s stuff.
		return nil
	end
end
return {
	default = ServerFunction,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="177">
                  <Properties>
                    <string name="Name">ServerMessagingEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent")
local ExperienceBroadcastEvent = _ExperienceBroadcastEvent.default
local isSubscriptionMessage = _ExperienceBroadcastEvent.isSubscriptionMessage
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local IS_CLIENT = _internal.IS_CLIENT
local isLuaTable = _internal.isLuaTable
local ServerEvent = TS.import(script, script.Parent, "ServerEvent").default
local Players = game:GetService("Players")
local function isTargetedSubscriptionMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.InnerData ~= nil
		end
	end
	return false
end
--[[
	*
	* Similar to a ServerEvent, but works across all servers.
]]
local ServerMessagingEvent
do
	ServerMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ServerMessagingEvent"
		end,
	})
	ServerMessagingEvent.__index = ServerMessagingEvent
	function ServerMessagingEvent.new(...)
		local self = setmetatable({}, ServerMessagingEvent)
		return self:constructor(...) or self
	end
	function ServerMessagingEvent:constructor(name)
		self.instance = ServerEvent.new(getGlobalRemote(name))
		self.event = ExperienceBroadcastEvent.new(name)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a Net.GlobalServerEvent on the Client!")
		self.eventHandler = self.event:Connect(function(message)
			if isTargetedSubscriptionMessage(message) then
				self:recievedMessage(message.Data)
			else
				warn("[rbx-net] Recieved malformed message for ServerGameEvent: " .. name)
			end
		end)
	end
	function ServerMessagingEvent:getPlayersMatchingId(matching)
		if type(matching) == "number" then
			return Players:GetPlayerByUserId(matching)
		else
			local players = {}
			for _, id in ipairs(matching) do
				local player = Players:GetPlayerByUserId(id)
				if player then
					table.insert(players, player)
				end
			end
			return players
		end
	end
	function ServerMessagingEvent:recievedMessage(message)
		if message.TargetIds then
			local players = self:getPlayersMatchingId(message.TargetIds)
			if players then
				self.instance:SendToPlayers(players, unpack(message.InnerData))
			end
		elseif message.TargetId ~= nil then
			local player = self:getPlayersMatchingId(message.TargetId)
			if player then
				self.instance:SendToPlayer(player, unpack(message.InnerData))
			end
		else
			self.instance:SendToAllPlayers(unpack(message.InnerData))
		end
	end
	function ServerMessagingEvent:Connect(serverListener)
		return self.event:Connect(function(data, sent)
			serverListener(data, sent)
		end)
	end
	function ServerMessagingEvent:SendToAllServers(...)
		local args = { ... }
		self.event:SendToAllServers({
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToServer(jobId, ...)
		local args = { ... }
		self.event:SendToServer(jobId, {
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToUserId(userId, ...)
		local args = { ... }
		local player = Players:GetPlayerByUserId(userId)
		-- If the player exists in this instance, just send it straight to them.
		if player then
			self.instance:SendToPlayer(player, unpack(args))
		else
			self.event:SendToAllServers({
				InnerData = args,
				TargetId = userId,
			})
		end
	end
	function ServerMessagingEvent:SendToUserIds(userIds, ...)
		local args = { ... }
		-- Check to see if any of these users are in this server first, and handle accordingly.
		for _, targetId in ipairs(userIds) do
			local player = Players:GetPlayerByUserId(targetId)
			if player then
				self.instance:SendToPlayer(player, unpack(args))
				table.remove(userIds, targetId + 1)
			end
		end
		if #userIds > 0 then
			self.event:SendToAllServers({
				InnerData = args,
				TargetIds = userIds,
			})
		end
	end
end
return {
	default = ServerMessagingEvent,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="178">
            <Properties>
              <string name="Name">netto</string>
            </Properties>
            <Item class="ModuleScript" referent="179">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local server_rpc = TS.import(script, script, "server").server_rpc
local client_rpc = TS.import(script, script, "client").client_rpc
local stack = {}
local function new_node()
	local node = {}
	table.insert(stack, node)
	return node
end
local function create_events(events)
	local mapped_events = {}
	for name, fn in pairs(events) do
		local node = stack[#stack - 1 + 1]
		mapped_events[name] = fn(node.instance)
	end
	return setmetatable(mapped_events, {
		__call = function()
			print("initialized")
		end,
	})
end
local function host_events(root)
	local node = new_node()
	node.instance = root
	return node
end
local function create_apis(events)
	return create_events(events)
end
return {
	host_events = host_events,
	create_apis = create_apis,
	server_rpc = server_rpc,
	client_rpc = client_rpc,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="180">
                <Properties>
                  <string name="Name">client</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local get_or_create = TS.import(script, script.Parent, "get_or_create").get_or_create
local function client_rpc(name)
	if name == nil then
		name = tostring((debug.info(1, "s")))
	end
	return function(root)
		return get_or_create("RemoteEvent", name, root)
	end
end
return {
	client_rpc = client_rpc,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="181">
                <Properties>
                  <string name="Name">get_or_create</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local function get_or_create(class_name, name, target)
	local maybe_found = target:FindFirstChild(name)
	if maybe_found ~= nil and maybe_found:IsA(class_name) then
		return maybe_found
	end
	local inst = Instance.new(class_name)
	inst.Name = name
	inst.Parent = target
	return inst
end
return {
	get_or_create = get_or_create,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="182">
                <Properties>
                  <string name="Name">server</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local get_or_create = TS.import(script, script.Parent, "get_or_create").get_or_create
local function server_rpc(name)
	if name == nil then
		name = tostring((debug.info(1, "s")))
	end
	return function(root)
		return get_or_create("RemoteEvent", name, root)
	end
end
return {
	server_rpc = server_rpc,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="183">
            <Properties>
              <string name="Name">object-utils</string>
              <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="184">
            <Properties>
              <string name="Name">plasma</string>
            </Properties>
            <Item class="ModuleScript" referent="185">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--- @class Plasma

local Runtime = require(script.Runtime)
local Style = require(script.Style)

return {
	new = Runtime.new,
	start = Runtime.start,
	continueFrame = Runtime.continueFrame,
	beginFrame = Runtime.beginFrame,
	finishFrame = Runtime.finishFrame,
	scope = Runtime.scope,
	widget = Runtime.widget,
	useState = Runtime.useState,
	useInstance = Runtime.useInstance,
	useEffect = Runtime.useEffect,
	useKey = Runtime.useKey,
	setEventCallback = Runtime.setEventCallback,

	useStyle = Style.get,
	setStyle = Style.set,

	automaticSize = require(script.automaticSize),
	hydrateAutomaticSize = require(script.hydrateAutomaticSize),
	create = require(script.create),

	window = require(script.widgets.window),
	button = require(script.widgets.button),
	portal = require(script.widgets.portal),
	blur = require(script.widgets.blur),
	row = require(script.widgets.row),
	spinner = require(script.widgets.spinner),
	checkbox = require(script.widgets.checkbox),
	arrow = require(script.widgets.arrow),
	heading = require(script.widgets.heading),
	label = require(script.widgets.label),
	slider = require(script.widgets.slider),
	space = require(script.widgets.space),
	table = require(script.widgets.table),
	highlight = require(script.widgets.highlight),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="186">
                <Properties>
                  <string name="Name">Runtime</string>
                  <string name="Source"><![CDATA[type EventCallback = (Instance, string, (...any) -> ()) -> ()

type Node = {
	instance: Instance?,
	refs: { [any]: Instance }?,
	containerInstance: Instance?,
	effects: {
		[TopoKey]: {
			lastDependencies: { any }?,
			lastDependenciesLength: number,
			destructor: (() -> ())?,
		},
	},
	states: { [TopoKey]: any },
	children: { [TopoKey]: Node },
	generation: number,
	eventCallback: EventCallback?,
}

type TopoKey = string

type StackFrame = {
	node: Node,
	contextValues: {
		[any]: any,
	},
	childrenCount: number,
	effectCounts: { [TopoKey]: number },
	stateCounts: { [TopoKey]: number },
	childCounts: { [TopoKey]: number },
	discriminator: string | number,
}

local stack: { StackFrame } = {}

local recentErrors = {}
local recentErrorLastTime = 0

local function newNode(state: {}): Node
	if state == nil then
		state = {}
	end

	return {
		instance = nil,
		containerInstance = nil,
		effects = {},
		states = {},
		children = {},
		generation = 0,
	}
end

local function destroyNode(node: Node)
	if node.instance ~= nil then
		node.instance:Destroy()
	end

	for _, effect in pairs(node.effects) do
		if effect.destructor ~= nil then
			effect.destructor()
		end
	end

	for _, child in pairs(node.children) do
		destroyNode(child)
	end
end

local function newStackFrame(node: Node): StackFrame
	return {
		node = node,
		contextValues = {},
		childrenCount = 0,
		effectCounts = {},
		stateCounts = {},
		childCounts = {},
	}
end

local Runtime = {}

--[=[
	@within Plasma
	@param rootInstance Instance -- The root instance of which to mount all children. Likely a ScreenGui.
	@return Node -- An opaque object which holds persistent state about your UI.
]=]
function Runtime.new(rootInstance: Instance): Node
	local node = newNode()
	node.instance = rootInstance
	return node
end

--[=[
	@within Plasma
	@param name string -- The human-readable name of the context. This is only for debug purposes.
	@return Context -- An opqaue Context object which holds persistent state.

	Creates a [Context] object which is used to pass state downwards through the tree without needing to thread it
	through every child as props.
]=]
function Runtime.createContext(name: string)
	local fullName = string.format("PlasmaContext(%s)", name)
	return setmetatable({}, {
		__tostring = function()
			return fullName
		end,
	})
end

--[=[
	@within Plasma
	@param context Context -- A context object previously created with `createContext`
	@return T
	@tag hooks

	Returns the value of this context provided by the most recent ancestor that used `provideContext` with this context.
]=]
function Runtime.useContext(context)
	for i = #stack - 1, 1, -1 do
		local frame = stack[i]

		if frame.contextValues[context] ~= nil then
			return frame.contextValues[context]
		end
	end

	return nil
end

--[=[
	@within Plasma
	@param context Context -- A context object previously created with `createContext`
	@param value T -- Any value you want to provide for this context

	Provides a value for this context for any subsequent uses of `useContext` in this scope.
]=]
function Runtime.provideContext(context, value)
	local frame = stack[#stack]
	frame.contextValues[context] = value
end

--[=[
	@within Plasma
	@param callback () -> () | () -> () -> () -- A callback function that optionally returns a cleanup function
	@param ... any -- Dependencies
	@tag hooks

	`useEffect` takes a callback as a parameter which is then only invoked if passed dependencies are different from the
	last time this function was called. The callback is always invoked the first time this code path is reached.

	If no dependencies are passed, the callback only runs once.

	This function can be used to skip expensive work if none of the dependencies have changed since the last run.
	For example, you might use this to set a bunch of properties in a widget if any of the inputs change.
]=]
function Runtime.useEffect(callback: () -> () | () -> () -> (), ...)
	local frame = stack[#stack]
	local effects = frame.node.effects

	local file = debug.info(2, "s")
	local line = debug.info(2, "l")
	local baseKey = string.format("%s:%s:%d", tostring(frame.discriminator) or "", file, line)

	frame.effectCounts[baseKey] = (frame.effectCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, frame.effectCounts[baseKey])

	local existing = effects[key]
	local gottaRunIt = existing == nil -- We ain't never run this before!
		or select("#", ...) ~= existing.lastDependenciesLength -- I have altered the dependencies. Pray that I do not alter them further.

	if not gottaRunIt then
		for i = 1, select("#", ...) do
			if select(i, ...) ~= existing.lastDependencies[i] then
				gottaRunIt = true
				break
			end
		end
	end

	if gottaRunIt then
		if existing ~= nil and existing.destructor ~= nil then
			existing.destructor()
		end

		effects[key] = {
			destructor = callback(),
			lastDependencies = { ... },
			lastDependenciesLength = select("#", ...),
		}
	end
end

--[=[
	@within Plasma
	@param initialValue T -- The value this hook returns if the set callback has never been called
	@return T -- The previously set value, or the initial value if none has been set
	@return (newValue: T) -> () -- A function which when called stores the value in this hook for the next run
	@tag hooks

	```lua
	local checked, setChecked = useState(false)

	useInstance(function()
		local TextButton = Instance.new("TextButton")

		TextButton.Activated:Connect(function()
			setChecked(not checked)
		end)

		return TextButton
	end)

	TextButton.Text = if checked then "X" else ""
	```
]=]
function Runtime.useState<T>(initialValue: T): T
	local frame = stack[#stack]
	local states = frame.node.states

	local file = debug.info(2, "s")
	local line = debug.info(2, "l")
	local baseKey = string.format("%s:%s:%d", tostring(frame.discriminator) or "", file, line)
	frame.stateCounts[baseKey] = (frame.stateCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, frame.stateCounts[baseKey])

	local existing = states[key]
	if existing == nil then
		states[key] = initialValue
	end

	local function setter(newValue)
		if type(newValue) == "function" then
			newValue = newValue(states[key])
		end

		states[key] = newValue
	end

	return states[key], setter
end

--[=[
	@within Plasma
	@param key

	Specify a key by which to store all future state in this scope. This is similar to React's `key` prop.

	This is important to use to prevent state from one source being still being applied when it should actually reset.
]=]
function Runtime.useKey(key: string | number)
	local frame = stack[#stack]

	frame.discriminator = key
end

--[=[
	@within Plasma
	@param creator (ref: {}) -> (Instance, Instance?) -- A callback which creates the widget and returns it
	@return Instance -- Returns the instance returned by `creator`
	@tag hooks

	`useInstance` takes a callback which should be used to create the initial UI for the widget.
	The callback is only ever invoked on the first time this widget runs and never again.
	The callback should return the instance it created.
	The callback can optionally return a second value, which is the instance where children of this widget should be
	placed. Otherwise, children are placed in the first instance returned.

	`useInstance` returns the `ref` table that is passed to it. You can use this to create references to objects
	you want to update in the widget body.
]=]
function Runtime.useInstance(creator: () -> Instance): Instance
	local node = stack[#stack].node
	local parentFrame = Runtime.nearestStackFrameWithInstance()

	if node.instance == nil then
		local parent = parentFrame.node.containerInstance or parentFrame.node.instance

		node.refs = {}
		local instance, container = creator(node.refs)

		if instance ~= nil then
			instance.Parent = parent
			node.instance = instance
		end

		if container ~= nil then
			node.containerInstance = container
		end
	end

	if node.instance ~= nil and node.instance:IsA("GuiObject") then
		parentFrame.childrenCount += 1
		node.instance.LayoutOrder = parentFrame.childrenCount
	end

	return node.refs
end

function Runtime.nearestStackFrameWithInstance(): StackFrame?
	for i = #stack - 1, 1, -1 do
		local frame = stack[i]

		if frame.node.containerInstance ~= nil or frame.node.instance ~= nil then
			return frame
		end
	end

	return nil
end

local function scope(level, scopeKey, fn, ...)
	local parentFrame = stack[#stack]
	local parentNode = parentFrame.node

	local file = debug.info(1 + level, "s")
	local line = debug.info(1 + level, "l")
	local baseKey = string.format("%s:%s:%s:%d", scopeKey, tostring(parentFrame.discriminator) or "", file, line)

	parentFrame.childCounts[baseKey] = (parentFrame.childCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, parentFrame.childCounts[baseKey])

	local currentNode = parentNode.children[key]

	if currentNode == nil then
		currentNode = newNode()
		parentNode.children[key] = currentNode
	end

	currentNode.generation = parentNode.generation

	table.insert(stack, newStackFrame(currentNode))
	local thread = coroutine.create(fn)

	local success, widgetHandle = coroutine.resume(thread, ...)

	if coroutine.status(thread) ~= "dead" then
		success = false
		widgetHandle =
			"Plasma: Handler passed to Plasma.start yielded! Yielding is not allowed and the handler thread has been closed."

		coroutine.close(thread)
	end

	if not success then
		if os.clock() - recentErrorLastTime > 10 then
			recentErrorLastTime = os.clock()
			recentErrors = {}
		end

		local errorValue = debug.traceback(thread, tostring(widgetHandle))

		if not recentErrors[errorValue] then
			task.spawn(error, tostring(errorValue))
			warn("Plasma: The above error will be suppressed for the next 10 seconds")
			recentErrors[errorValue] = true
		end

		local errorWidget = require(script.Parent.widgets.error)

		errorWidget(tostring(errorValue))
	end

	table.remove(stack)

	for childKey, childNode in pairs(currentNode.children) do
		if childNode.generation ~= currentNode.generation then
			destroyNode(childNode)
			currentNode.children[childKey] = nil
		end
	end

	return widgetHandle
end

--[=[
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`

	Begins a new frame for this Plasma instance. The `callback` is invoked immediately.
	Code run in the `callback` function that uses plasma APIs will be associated with this Plasma node.
	The `callback` function is **not allowed to yield**.

	If this function is used, `Plasma.beginFrame`, `Plasma.continueFrame`, and `Plasma.finishFrame` should not be used.
]=]
function Runtime.start(rootNode: Node, fn, ...)
	Runtime.beginFrame(rootNode, fn, ...)

	Runtime.finishFrame(rootNode)
end

--[=[
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`
	@return ContinueHandle -- A handle to pass to `continueFrame`

	Begins a *continuable* Plasma frame. Same semantics as [Plasma.start].

	For a frame:
	- Call `beginFrame` once.
	- Call `continueFrame` any number of times.
	- Call `finishFrame` when the frame is complete.

	If this function is used, `Plasma.start` should not be used.
]=]
function Runtime.beginFrame(rootNode: Node, fn, ...)
	if #stack > 0 then
		error("Runtime.start cannot be called while Runtime.start is already running", 2)
	end

	debug.profilebegin("Plasma")

	if rootNode.generation == 0 then
		rootNode.generation = 1
	else
		rootNode.generation = 0
	end

	stack[1] = newStackFrame(rootNode)
	scope(2, "root", fn, ...)
	local continueHandle = table.remove(stack)

	debug.profileend()

	return continueHandle
end

--[=[
	Finishes a continuable Plasma frame, cleaning up any objects that have been removed since the last frame.
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
]=]
function Runtime.finishFrame(rootNode: Node)
	for childKey, childNode in pairs(rootNode.children) do
		if childNode.generation ~= rootNode.generation then
			destroyNode(childNode)
			rootNode.children[childKey] = nil
		end
	end
end

--[=[
	Continue the Plasma frame with a new handler function. Calling this will not trigger any cleanup that typically
	happens every frame.

	This is intended to be used to continue creating UI within the same frame that you started on. You should call
	[Plasma.beginFrame] once per frame, then `Plasma.continueFrame` any number of times after that, finally calling
	[Plasma.finishFrame].

	@within Plasma
	@param continueHandle ContinueHandle -- An object returned by Plasma.start
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`
]=]
function Runtime.continueFrame(continueHandle, fn, ...)
	if #stack > 0 then
		error("Runtime.continue cannot be called while Runtime.start is already running", 2)
	end

	stack[1] = continueHandle

	scope(2, "root", fn, ...)

	table.remove(stack)
end

--[=[
	@within Plasma
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`

	Begins a new scope. This function may only be called within a `Plasma.start` callback.
	The `callback` is invoked immediately.

	Beginning a new scope associates all further calls to Plasma APIs with a nested scope inside this one.
]=]
function Runtime.scope(fn, ...)
	return scope(2, "", fn, ...)
end

--[=[
	@within Plasma
	@param fn (...: T) -> () -- The widget function
	@return (...: T) -> () -- A function which can be called to create the widget

	This function takes a widget function and returns a function that automatically starts a new scope when the function
	is called.
]=]
function Runtime.widget(fn)
	local file, line = debug.info(2, "sl")
	local scopeKey = string.format("%s+%d", file, line)

	return function(...)
		return scope(2, scopeKey, fn, ...)
	end
end

function Runtime.setEventCallback(callback: EventCallback)
	stack[1].node.eventCallback = callback
end

function Runtime.useEventCallback(): EventCallback?
	local frame = stack[1]

	if not frame then
		return nil
	end

	return frame.node.eventCallback
end

return Runtime
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="187">
                <Properties>
                  <string name="Name">Style</string>
                  <string name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

local ContextKey = Runtime.createContext("Style")

local defaultStyle = {
	bg1 = Color3.fromRGB(31, 31, 31),
	bg2 = Color3.fromRGB(42, 42, 42),
	bg3 = Color3.fromRGB(54, 54, 54),
	mutedTextColor = Color3.fromRGB(147, 147, 147),
	textColor = Color3.fromRGB(255, 255, 255),
}

local Style = {}

--[=[
	@within Plasma
	@function useStyle
	@tag style

	Returns the current style information, with styles that are set more recently in the tree overriding styles that
	were set further up. In this way, styles cascade downwards, similar to CSS.
]=]
function Style.get()
	return Runtime.useContext(ContextKey) or defaultStyle
end

--[=[
	@within Plasma
	@function setStyle
	@tag style
	@param styleFragment {[string]: any} -- A dictionary of style information

	Defines style for any subsequent calls in this scope. Merges with any existing styles.
]=]
function Style.set(styleFragment)
	local existing = Runtime.useContext(ContextKey) or defaultStyle
	local newStyle = {}

	for key, value in pairs(existing) do
		newStyle[key] = value
	end

	for key, value in pairs(styleFragment) do
		newStyle[key] = value
	end

	Runtime.provideContext(ContextKey, newStyle)
end

return Style
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="188">
                <Properties>
                  <string name="Name">automaticSize</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local function applyLayout(container, layout)
	local axisName = container:GetAttribute("axis") or "XY"
	local axis = Enum.AutomaticSize[axisName]

	local maxSize = container:GetAttribute("maxSize") or Vector2.new(math.huge, math.huge)
	local minSize = container:GetAttribute("minSize") or Vector2.new(0, 0)

	if typeof(maxSize) == "UDim2" then
		if container.Parent == nil then
			maxSize = Vector2.new(0, 0)
		else
			local parentSize = container.Parent.AbsoluteSize

			maxSize = Vector2.new(
				(parentSize.X / maxSize.X.Scale) + maxSize.X.Offset,
				(parentSize.Y / maxSize.Y.Scale) + maxSize.Y.Offset
			)
		end
	end

	local padX = 0
	local padY = 0
	local padding = container:FindFirstChildOfClass("UIPadding")
	if padding ~= nil then
		padX = padding.PaddingLeft.Offset + padding.PaddingRight.Offset
		padY = padding.PaddingTop.Offset + padding.PaddingBottom.Offset
	end

	local contentSize

	if layout then
		contentSize = layout.AbsoluteContentSize
	elseif container:IsA("TextButton") or container:IsA("TextLabel") then
		contentSize = container.TextBounds
	else
		contentSize = Vector2.new(0, 0)

		for _, child in container:GetChildren() do
			if child:IsA("GuiObject") then
				local farX = child.Position.X.Offset + child.Size.X.Offset
				local farY = child.Position.Y.Offset + child.Size.Y.Offset

				contentSize = Vector2.new(math.max(contentSize.X, farX), math.max(contentSize.Y, farY))
			end
		end
	end

	local baseX = math.max(contentSize.X + padX, minSize.X)
	local baseY = math.max(contentSize.Y + padY, minSize.Y)

	local x, y
	local xClamped, yClamped

	if axis == Enum.AutomaticSize.XY then
		x = UDim.new(0, baseX)
		y = UDim.new(0, baseY)
		xClamped = UDim.new(0, math.min(baseX, maxSize.X))
		yClamped = UDim.new(0, math.min(baseY, maxSize.Y))
	elseif axis == Enum.AutomaticSize.X then
		x = UDim.new(0, baseX)
		y = container.Size.Y
		xClamped = UDim.new(0, math.min(baseX, maxSize.X))
		yClamped = container.Size.Y
	else
		x = container.Size.X
		y = UDim.new(0, baseY)
		xClamped = container.Size.X
		yClamped = UDim.new(0, math.min(baseY, maxSize.Y))
	end

	if container:IsA("ScrollingFrame") then
		local canvasX = x
		local canvasY = y

		if x.Offset > xClamped.Offset then
			canvasY -= UDim.new(0, container.ScrollBarThickness)
		end
		if y.Offset > yClamped.Offset then
			canvasX -= UDim.new(0, container.ScrollBarThickness)
		end

		container.CanvasSize = UDim2.new(canvasX, canvasY)
	end

	container.Size = UDim2.new(xClamped, yClamped)
end

local function trackParentSize(instance, callback)
	local parent = nil
	local connection = nil

	local function parentChanged(newParent)
		if parent == newParent then
			return
		end

		if connection ~= nil then
			connection:Disconnect()
			connection = nil
		end

		if newParent == nil then
			return
		end

		connection = newParent:GetPropertyChangedSignal("AbsoluteSize"):Connect(callback)
		parent = newParent
	end

	parentChanged(instance.Parent)

	instance:GetPropertyChangedSignal("Parent"):Connect(function()
		parentChanged(instance.Parent)
	end)
end

local defaultOptions = {}

--[=[
	@within Plasma
	@function automaticSize
	@param container GuiObject -- The instance to apply automatic sizing to.
	@param options { axis: Enum.AutomaticSize, maxSize: Vector2 | UDim2, minSize: Vector2 } | nil
	@tag utilities

	Applies padding-aware automatic size to the given GUI instance. This function sets up events to listen to further changes, so
	should only be called once per object.

	Also supports ScrollingFrames by correctly clamping actual and canvas sizes.

	:::note
	If this function is called from the server, if `maxSize` is a UDim2, because of differing screen sizes, it instead
	configures the instance to be compatible with the [Plasma.hydrateAutomaticSize] function, adding the
	CollectionService tag and other attributes.

	You must also call `hydrateAutomaticSize` once on the client for this to work.
	:::

	::warning
	There is currently no way to undo this other than destroying the instance. Once automatic sizing has been applied,
	it is always applied to that instance.
	:::
]=]
local function automaticSize(container, options)
	options = options or defaultOptions

	if options.maxSize then
		container:SetAttribute("maxSize", options.maxSize)
	end

	if options.minSize then
		container:SetAttribute("minSize", options.maxSize)
	end

	if options.axis then
		container:SetAttribute("axis", options.axis.Name)
	end

	if not RunService:IsClient() and typeof(container:GetAttribute("maxSize") or nil) == "UDim2" then
		CollectionService:AddTag(container, "PlasmaAutomaticSize")

		return
	end

	local layout = container:FindFirstChildWhichIsA("UIGridStyleLayout")

	applyLayout(container, layout)

	if typeof(container:GetAttribute("maxSize") or nil) == "UDim2" then
		trackParentSize(container, function()
			applyLayout(container, layout)
		end)
	end

	if layout then
		layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			applyLayout(container, layout)
		end)
	elseif container:IsA("TextLabel") or container:IsA("TextButton") then
		container:GetPropertyChangedSignal("TextBounds"):Connect(function()
			applyLayout(container)
		end)
	else
		local function connect(child)
			if child:IsA("GuiObject") then
				child:GetPropertyChangedSignal("Size"):Connect(function()
					applyLayout(container)
				end)
			end
		end

		for _, child in container:GetChildren() do
			connect(child)
		end

		container.ChildAdded:Connect(function(child)
			applyLayout(container)

			connect(child)
		end)

		container.ChildRemoved:Connect(function()
			applyLayout(container)
		end)
	end

	container:GetAttributeChangedSignal("maxSize"):Connect(function()
		applyLayout(container, layout)
	end)

	container:GetAttributeChangedSignal("minSize"):Connect(function()
		applyLayout(container, layout)
	end)
end

return automaticSize
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="189">
                <Properties>
                  <string name="Name">create</string>
                  <string name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

--[=[
	@within Plasma
	@function create
	@param className string -- The class name of the Instance to create
	@param props CreateProps
	@return Instance -- The created instance
	@tag utilities

	A function that creates an Instance tree.

	CreateProps is a table:
	- String keys are interpreted as properties to set
	- Numerical keys are interpreted as children
	- Function values are interpreted as event handlers
	- Table keys can be used to get references to instances deep in the tree, the value becomes the key in the table

	This function doesn't do anything special. It just creates an instance.

	```lua
	create("Frame", {
		BackgroundTransparency = 1,
		Name = "Checkbox",

		create("TextButton", {
			BackgroundColor3 = Color3.fromRGB(54, 54, 54),
			Size = UDim2.new(0, 30, 0, 30),

			create("UICorner", {
				CornerRadius = UDim.new(0, 8),
			}),

			Activated = function()
				setClicked(true)
			end,
		}),
	})
	```

	Getting references to instances deep in a tree:

	```lua
	local ref = {}

	create("Frame", {
		create("TextButton", {
			[ref] = "button",
			Text = "hi"
		})
	})

	print(ref.button.Text) --> hi
	```
]=]
local function create(className, props)
	props = props or {}

	local eventCallback = Runtime.useEventCallback()

	local instance = Instance.new(className)

	for key, value in pairs(props) do
		if type(value) == "function" then
			if eventCallback then
				eventCallback(instance, key, value)
			else
				instance[key]:Connect(value)
			end
		elseif type(key) == "number" then
			value.Parent = instance
		elseif type(key) == "table" then
			key[value] = instance

			if props.Name == nil then
				instance.Name = value
			end
		else
			instance[key] = value
		end
	end

	return instance
end

return create
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="190">
                <Properties>
                  <string name="Name">createConnect</string>
                  <string name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

local function createConnect()
	local eventCallback = Runtime.useEventCallback()

	return function(instance, eventName, handler)
		if eventCallback then
			return eventCallback(instance, eventName, handler)
		else
			return instance[eventName]:Connect(handler)
		end
	end
end

return createConnect
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="191">
                <Properties>
                  <string name="Name">hydrateAutomaticSize</string>
                  <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local automaticSize = require(script.Parent.automaticSize)

--[=[
	Applies automatic sizing to any current or future instances in the DataModel that are tagged with
	`"PlasmaAutomaticSize"`. Attributes `axis` (string) and `maxSize` (UDim2 or Vector2) are allowed.

	@within Plasma
	@tag utilities
	@client
	@return RBXScriptConnection
]=]
local function hydrateAutomaticSize()
	for _, instance in CollectionService:GetTagged("PlasmaAutomaticSize") do
		automaticSize(instance)
	end

	return CollectionService:GetInstanceAddedSignal("PlasmaAutomaticSize"):Connect(function(instance)
		task.defer(automaticSize, instance) -- instance added signal fires before children are added
	end)
end

return hydrateAutomaticSize
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="192">
                <Properties>
                  <string name="Name">widgets</string>
                </Properties>
                <Item class="ModuleScript" referent="193">
                  <Properties>
                    <string name="Name">arrow</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function arrow
	@tag widgets
	@param from Vector3 | CFrame | BasePart
	@param to Vector3 | BasePart | nil
	@param color Color3? -- Optional color. Random if not specified.

	- `arrow(from: Vector3, to: Vector3)` -> Creates an arrow between `from` and `to`
	- `arrow(point: Vector3)` -> Creates an arrow pointing at `point`
	- `arrow(cframe: CFrame)` -> Creates an arrow with its point at the CFrame position facing the CFrame LookVector
	- `arrow(part: BasePart)` -> Arrow represents the Part's CFrame
	- `arrow(fromPart: BasePart, toPart: BasePart)` -> Arrow between the two parts

	![Arrows](https://i.eryn.io/2150/arrows.png)

	```lua
	Plasma.arrow(Vector3.new(0, 0, 0))
	Plasma.arrow(Vector3.new(5, 5, 5), Vector3.new(10, 10, 10))
	```
]=]

local function arrow(name, container, scale, color, zindex)
	local body = Instance.new("CylinderHandleAdornment")

	body.Name = name .. "Body"
	body.Color3 = color
	body.Radius = 0.15
	body.Adornee = workspace.Terrain
	body.Transparency = 0
	body.Radius = 0.15 * scale
	body.Transparency = 0
	body.AlwaysOnTop = true
	body.ZIndex = zindex

	body.Parent = container

	local point = Instance.new("ConeHandleAdornment")

	scale = scale == 1 and 1 or 1.4

	point.Name = name .. "Point"
	point.Color3 = color
	point.Radius = 0.5 * scale
	point.Transparency = 0
	point.Adornee = workspace.Terrain
	point.Height = 2 * scale
	point.AlwaysOnTop = true
	point.ZIndex = zindex

	point.Parent = container
end

local function update(body, point, from, to, scale)
	body.Height = (from - to).magnitude - 2
	body.CFrame = CFrame.lookAt(((from + to) / 2) - ((to - from).unit * 1), to)
	point.CFrame = CFrame.lookAt((CFrame.lookAt(to, from) * CFrame.new(0, 0, -2 - ((scale - 1) / 2))).p, to)
end

local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function(from, to, color)
	local fallbackColor = Runtime.useState(BrickColor.random().Color)
	color = color or fallbackColor

	if typeof(from) == "Instance" then
		if from:IsA("BasePart") then
			from = from.CFrame
		elseif from:IsA("Attachment") then
			from = from.WorldCFrame
		end

		if to ~= nil then
			from = from.p
		end
	end

	if typeof(to) == "Instance" then
		if to:IsA("BasePart") then
			to = to.Position
		elseif to:IsA("Attachment") then
			to = to.WorldPosition
		end
	end

	if typeof(from) == "CFrame" and to == nil then
		local look = from.lookVector
		to = from.p
		from = to + (look * -10)
	end

	if to == nil then
		to = from
		from = to + Vector3.new(0, 10, 0)
	end

	assert(typeof(from) == "Vector3" and typeof(to) == "Vector3", "Passed parameters are of invalid types")

	local refs = Runtime.useInstance(function(ref)
		local container = Instance.new("Folder")
		container.Name = "Arrow"

		ref.folder = container

		arrow("front", container, 1, color, 1)
		arrow("back", container, 2, Color3.new(0, 0, 0), -1)

		return container
	end)

	local folder = refs.folder

	update(folder.frontBody, folder.frontPoint, from, to, 1)
	update(folder.backBody, folder.backPoint, from, to, 1.4)

	folder.frontBody.Color3 = color
	folder.frontPoint.Color3 = color
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="194">
                  <Properties>
                    <string name="Name">blur</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function blur
	@tag widgets
	@param size number -- The size of the blur

	A blur effect in the world. Created in Lighting.
]=]

local Lighting = game:GetService("Lighting")
local Runtime = require(script.Parent.Parent.Runtime)
local portal = require(script.Parent.portal)

return function(size)
	portal(Lighting, function()
		Runtime.useInstance(function()
			local blur = Instance.new("BlurEffect")
			blur.Size = size
			return blur
		end)
	end)
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="195">
                  <Properties>
                    <string name="Name">button</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function button
	@tag widgets
	@param label string -- The label for the checkbox
	@return ButtonWidgetHandle

	A text button.

	Returns a widget handle, which has the field:

	- `clicked`, a function you can call to check if the checkbox was clicked this frame

	![A button](https://i.eryn.io/2150/RobloxStudioBeta-iwRM0RMx.png)

	```lua
	Plasma.window("Button", function()
		if Plasma.button("button text"):clicked() then
			print("clicked!")
		end
	end)
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text)
	local clicked, setClicked = Runtime.useState(false)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextButton", {
			[ref] = "button",
			BackgroundColor3 = style.bg3,
			BorderSizePixel = 0,
			Font = Enum.Font.SourceSans,
			Size = UDim2.new(0, 100, 0, 40),
			TextColor3 = style.textColor,
			AutomaticSize = Enum.AutomaticSize.X,
			TextSize = 21,

			create("UIPadding", {
				PaddingLeft = UDim.new(0, 10),
				PaddingRight = UDim.new(0, 10),
			}),

			create("UICorner"),

			Activated = function()
				setClicked(true)
			end,
		})
	end)

	local instance = refs.button

	instance.Text = text

	local handle = {
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="196">
                  <Properties>
                    <string name="Name">checkbox</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function checkbox
	@tag widgets
	@param label string -- The label for the checkbox
	@param options {disabled: boolean, checked: boolean}
	@return CheckboxWidgetHandle

	A checkbox. A checkbox may either be controlled or uncontrolled.

	By passing the `checked` field in `options`, you make the checkbox controlled. Controlling the checkbox means that
	the checked state is controlled by your code. Otherwise, the controlled state is controlled by the widget itself.

	Returns a widget handle, which has the fields:

	- `checked`, a function you can call to check if the checkbox is checked
	- `clicked`, a function you can call to check if the checkbox was clicked this frame

	![Checkboxes](https://i.eryn.io/2150/9Yg31gc8.png)

	```lua
	Plasma.window("Checkboxes", function()
		if Plasma.checkbox("Controlled checkbox", {
			checked = checked,
		}):clicked() then
			checked = not checked
		end

		Plasma.checkbox("Disabled checkbox", {
			checked = checked,
			disabled = true,
		})

		Plasma.checkbox("Uncontrolled checkbox")
	end)
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text, options)
	options = options or {}

	local checked, setChecked = Runtime.useState(false)
	local clicked, setClicked = Runtime.useState(false)

	local refs = Runtime.useInstance(function(ref)
		local Checkbox = create("Frame", {
			[ref] = "checkbox",
			BackgroundTransparency = 1,
			Name = "Checkbox",
			Size = UDim2.new(0, 30, 0, 30),
			AutomaticSize = Enum.AutomaticSize.X,

			create("TextButton", {
				BackgroundColor3 = Color3.fromRGB(54, 54, 54),
				BorderSizePixel = 0,
				Font = Enum.Font.SourceSansBold,
				Size = UDim2.new(0, 30, 0, 30),
				TextColor3 = Color3.fromRGB(153, 153, 153),
				TextSize = 24,

				create("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),

				Activated = function()
					setClicked(true)
					setChecked(function(currentlyChecked)
						return not currentlyChecked
					end)
				end,
			}),

			create("TextLabel", {
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				Font = Enum.Font.GothamMedium,
				TextColor3 = Color3.fromRGB(203, 203, 203),
				TextSize = 18,
				AutomaticSize = Enum.AutomaticSize.X,
				RichText = true,
			}),

			create("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				Padding = UDim.new(0, 10),
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),
		})

		return Checkbox
	end)

	local instance = refs.checkbox

	instance.TextLabel.Text = text
	instance.TextButton.AutoButtonColor = not options.disabled

	Runtime.useEffect(function()
		local isChecked
		if options.checked ~= nil then
			isChecked = options.checked
		else
			isChecked = checked
		end

		instance.TextButton.Text = isChecked and "✓" or ""
	end, options.checked, checked)

	Runtime.useEffect(function()
		instance.TextButton.BackgroundColor3 = options.disabled and Color3.fromRGB(112, 112, 112)
			or Color3.fromRGB(54, 54, 54)
	end, options.disabled)

	local handle = {
		checked = function()
			if options.checked or checked then
				return true
			end

			return false
		end,
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="197">
                  <Properties>
                    <string name="Name">error</string>
                    <string name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text)
	local refs = Runtime.useInstance(function(ref)
		return create("Frame", {
			[ref] = "error",
			BackgroundTransparency = 0,
			BackgroundColor3 = Color3.fromRGB(231, 76, 60),
			Name = "Error",
			Size = UDim2.new(0, 100, 0, 75),
			AutomaticSize = Enum.AutomaticSize.XY,

			create("UIPadding", {
				PaddingBottom = UDim.new(0, 20),
				PaddingLeft = UDim.new(0, 20),
				PaddingRight = UDim.new(0, 20),
				PaddingTop = UDim.new(0, 20),
			}),

			create("UIListLayout", {}),

			create("TextLabel", {
				Font = Enum.Font.GothamBold,
				BackgroundTransparency = 1,
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 25,
				AutomaticSize = Enum.AutomaticSize.X,
				Text = "⚠️  An Error Occurred",
				Size = UDim2.fromOffset(0, 75),
			}),

			create("TextLabel", {
				Name = "error",
				Font = Enum.Font.GothamMedium,
				BackgroundTransparency = 1,
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 20,
				LineHeight = 1.2,
				AutomaticSize = Enum.AutomaticSize.XY,
				Size = UDim2.fromOffset(100, 75),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
			}),
		})
	end)

	local instance = refs.error

	instance.error.Text = text
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="198">
                  <Properties>
                    <string name="Name">heading</string>
                    <string name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)
local Style = require(script.Parent.Parent.Style)

--[=[
	@within Plasma
	@function heading
	@param text string
	@param options? {font: Font}
	@tag widgets

	Text, but bigger!
]=]
return Runtime.widget(function(text, options)
	options = options or {}
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextLabel", {
			[ref] = "heading",
			BackgroundTransparency = 1,
			Font = Enum.Font.GothamBold,
			AutomaticSize = Enum.AutomaticSize.XY,
			TextColor3 = style.mutedTextColor,
			TextSize = 20,
			RichText = true,
		})
	end)

	local instance = refs.heading
	instance.Text = text
	instance.Font = options.font or Enum.Font.GothamBold
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="199">
                  <Properties>
                    <string name="Name">highlight</string>
                    <string name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

--[=[
	@interface HighlightOptions
	@within Plasma

	.outlineColor?: Color3
	.fillColor?: Color3
	.fillTransparency?: number
	.outlineTransparency?: number
	.fillMode?: HighlightFillMode
]=]

--[=[
	@within Plasma
	@function highlight
	@param adornee Instance
	@param options? HighlightOptions


	Creates a highlight over an instance with the specified options, using the Roblox [Highlight] instance
]=]
return Runtime.widget(function(adornee, options)
	options = options or {}

	local refs = Runtime.useInstance(function(ref)
		return create("Highlight", {
			[ref] = "highlight",
		})
	end)

	refs.highlight.Adornee = adornee

	Runtime.useEffect(function()
		refs.highlight.OutlineColor = options.outlineColor or Color3.new(1, 1, 1)
		refs.highlight.FillColor = options.fillColor or Color3.new(1, 0, 0)
	end, options.fillColor, options.outlineColor)

	refs.highlight.FillTransparency = options.fillTransparency or 0.5
	refs.highlight.OutlineTransparency = options.outlineTransparency or 0
	refs.highlight.DepthMode = options.depthMode or Enum.HighlightDepthMode.AlwaysOnTop
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="200">
                  <Properties>
                    <string name="Name">label</string>
                    <string name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)
local Style = require(script.Parent.Parent.Style)
local automaticSize = require(script.Parent.Parent.automaticSize)

--[=[
	@within Plasma
	@function label
	@param text string
	@tag widgets

	Text.
]=]
return Runtime.widget(function(text)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		create("TextLabel", {
			[ref] = "label",
			BackgroundTransparency = 1,
			Font = Enum.Font.SourceSans,
			TextColor3 = style.textColor,
			TextSize = 20,
			RichText = true,
		})

		automaticSize(ref.label)

		return ref.label
	end)

	refs.label.Text = text
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="201">
                  <Properties>
                    <string name="Name">portal</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function portal
	@tag widgets
	@param targetInstance Instance -- Where the portal goes to
	@param children () -> () -- Children

	The portal widget creates its children inside the specified `targetInstance`. For example, you could use this
	to create lighting effects in Lighting as a widget:


	```lua
	return function(size)
		portal(Lighting, function()
			useInstance(function()
				local blur = Instance.new("BlurEffect")
				blur.Size = size
				return blur
			end)
		end)
	end
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function(targetInstance, fn)
	Runtime.useInstance(function()
		return nil, targetInstance
	end)

	Runtime.scope(fn)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="202">
                  <Properties>
                    <string name="Name">row</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function row
	@tag widgets
	@param options {padding: Vector2}
	@param children () -> () -- Children

	Lays out children horizontally
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local automaticSize = require(script.Parent.Parent.automaticSize)

return Runtime.widget(function(options, fn)
	if type(options) == "function" and fn == nil then
		fn = options
		options = {}
	end

	if options.padding then
		if type(options.padding) == "number" then
			options.padding = UDim.new(0, options.padding)
		end
	else
		options.padding = UDim.new(0, 10)
	end

	local refs = Runtime.useInstance(function(ref)
		local Frame = Instance.new("Frame")
		Frame.BackgroundTransparency = 1

		local UIListLayout = Instance.new("UIListLayout")
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		UIListLayout.FillDirection = Enum.FillDirection.Horizontal
		UIListLayout.Padding = options.padding
		UIListLayout.Parent = Frame

		ref.frame = Frame

		automaticSize(Frame)

		return Frame
	end)

	local frame = refs.frame

	frame.UIListLayout.HorizontalAlignment = options.alignment or Enum.HorizontalAlignment.Left

	Runtime.scope(fn)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="203">
                  <Properties>
                    <string name="Name">slider</string>
                    <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(options)
	if type(options) == "number" then
		options = {
			max = options,
		}
	end

	local min = options.min or 0
	local max = options.max or 1
	local value, setValue = Runtime.useState(options.initial or 0)

	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		local frame = create("Frame", {
			[ref] = "frame",
			BackgroundTransparency = 1,
			Size = UDim2.new(0, 200, 0, 30),

			create("Frame", {
				Name = "line",
				Size = UDim2.new(1, 0, 0, 2),
				BackgroundColor3 = style.mutedTextColor,
				BorderSizePixel = 0,
				Position = UDim2.new(0, 0, 0.5, 0),
			}),

			create("TextButton", {
				Name = "dot",
				Size = UDim2.new(0, 15, 0, 15),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = style.textColor,
				Position = UDim2.new(0, 0, 0.5, 0),
				Text = "",

				create("UICorner", {
					CornerRadius = UDim.new(1, 0),
				}),
			}),
		})

		local inputs = {}

		frame.dot.InputBegan:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseButton1 then
				return
			end

			inputs[input] = UserInputService.InputChanged:Connect(function(moveInput)
				if moveInput.UserInputType ~= Enum.UserInputType.MouseMovement then
					return
				end

				local x = UserInputService:GetMouseLocation().X

				local maxPos = frame.AbsoluteSize.X - frame.dot.AbsoluteSize.X
				x -= frame.AbsolutePosition.X + frame.dot.AbsoluteSize.X / 2
				x = math.clamp(x, 0, maxPos)

				local percent = x / maxPos

				setValue(percent * (max - min) + min)
			end)
		end)

		frame.dot.InputEnded:Connect(function(input)
			if inputs[input] then
				inputs[input]:Disconnect()
			end
		end)

		return frame
	end)

	local maxPos = refs.frame.AbsoluteSize.X - refs.frame.dot.AbsoluteSize.X
	local percent = (value - min) / (max - min)
	refs.frame.dot.Position = UDim2.new(0, percent * maxPos + refs.frame.dot.AbsoluteSize.X / 2, 0.5, 0)

	return value
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="204">
                  <Properties>
                    <string name="Name">space</string>
                    <string name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

--[=[
	@within Plasma
	@function space
	@param size number

	Blank space of a certain size.

]=]
return Runtime.widget(function(size)
	local refs = Runtime.useInstance(function(ref)
		return create("Frame", {
			[ref] = "space",
			BackgroundTransparency = 1,
		})
	end)

	Runtime.useEffect(function()
		refs.space.Size = UDim2.new(0, size, 0, size)
	end, size)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="205">
                  <Properties>
                    <string name="Name">spinner</string>
                    <string name="Source"><![CDATA[--[=[
	@within Plasma
	@function spinner
	@tag widgets

	A spinner widget, indicating loading.

	![A spinner](https://i.eryn.io/2150/RobloxStudioBeta-sEyci8qy.png)
]=]

local RunService = game:GetService("RunService")
local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function()
	local refs = Runtime.useInstance(function(ref)
		local Frame = Instance.new("Frame")
		Frame.BackgroundTransparency = 1
		Frame.Size = UDim2.new(0, 100, 0, 100)

		local ImageLabel = Instance.new("ImageLabel")
		ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		ImageLabel.BackgroundTransparency = 1
		ImageLabel.Image = "rbxassetid://2689141406"
		ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
		ImageLabel.Size = UDim2.new(0, 100, 0, 100)
		ImageLabel.Parent = Frame

		ref.frame = Frame

		return Frame
	end)

	Runtime.useEffect(function()
		local connection = RunService.RenderStepped:Connect(function()
			refs.frame.ImageLabel.Rotation = os.clock() * 100 % 360
		end)

		return function()
			connection:Disconnect()
		end
	end)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="206">
                  <Properties>
                    <string name="Name">table</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)
local automaticSize = require(script.Parent.Parent.automaticSize)

local cell = Runtime.widget(function(text, font)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextLabel", {
			[ref] = "label",
			BackgroundTransparency = 1,
			Font = Enum.Font.SourceSans,
			AutomaticSize = Enum.AutomaticSize.XY,
			TextColor3 = style.textColor,
			TextSize = 20,
			TextXAlignment = Enum.TextXAlignment.Left,
			RichText = true,

			create("UIPadding", {
				PaddingBottom = UDim.new(0, 8),
				PaddingLeft = UDim.new(0, 8),
				PaddingRight = UDim.new(0, 8),
				PaddingTop = UDim.new(0, 8),
			}),
		})
	end)

	refs.label.Font = font or Enum.Font.SourceSans
	refs.label.Text = text
end)

local row = Runtime.widget(function(columns, darken, selectable, font)
	local clicked, setClicked = Runtime.useState(false)
	local hovering, setHovering = Runtime.useState(false)

	local selected = columns.selected

	local refs = Runtime.useInstance(function(ref)
		return create("TextButton", {
			[ref] = "row",
			BackgroundTransparency = if darken then 0.7 else 1,
			BackgroundColor3 = Color3.fromRGB(0, 0, 0),
			AutoButtonColor = false,
			Text = "",
			Active = false,

			MouseEnter = function()
				setHovering(true)
			end,

			MouseLeave = function()
				setHovering(false)
			end,

			Activated = function()
				setClicked(true)
			end,
		})
	end)

	refs.row.Active = selectable and not selected or false

	local transparency = 1

	if selected then
		transparency = 0
	elseif hovering and selectable then
		transparency = 0.4
	elseif darken then
		transparency = 0.7
	end

	refs.row.BackgroundTransparency = transparency
	refs.row.BackgroundColor3 = selected and Color3.fromHex("bd515c") or Color3.fromRGB(0, 0, 0)

	for _, column in ipairs(columns) do
		if type(column) == "function" then
			Runtime.scope(column)
		else
			cell(column, font)
		end
	end

	return {
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end
			return false
		end,
		hovered = function()
			return hovering
		end,
	}
end)

--[=[
	@within Plasma
	@function table
	@param items {{string}}
	@param options {marginTop?: number, selectable?: boolean, font?: Font, headings?: boolean}
	@tag widgets

	A table widget. Items is a list of rows, with each row being a list of cells.

	```lua
	local items = {
		{"cell one", "cell two"},
		{"cell three", "cell four"}
	}
	```

	![Table](https://i.eryn.io/2227/NEc4Dmnv.png)
]=]
return Runtime.widget(function(items, options)
	options = options or {}

	Runtime.useInstance(function(ref)
		create("Frame", {
			[ref] = "table",
			BackgroundTransparency = 1,
			Position = UDim2.new(0, 0, 0, options.marginTop or 0),

			create("UITableLayout", {
				[ref] = "layout",
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
		})

		local connection

		connection = ref.table:GetPropertyChangedSignal("Parent"):Connect(function()
			connection:Disconnect()
			connection = nil

			RunService.Heartbeat:Wait()
			RunService.Heartbeat:Wait()

			-- Wtf roblox

			for _, child in ref.table:GetChildren() do
				if child:IsA("GuiObject") then
					child.Visible = false
				end
			end

			local _ = ref.layout.AbsoluteContentSize

			for _, child in ref.table:GetChildren() do
				if child:IsA("GuiObject") then
					child.Visible = true
				end
			end
		end)

		automaticSize(ref.table)

		return ref.table
	end)

	local selected, setSelected = Runtime.useState()
	local hovered

	for i, columns in items do
		local selectable = options.selectable
		local font = options.font

		if options.headings and i == 1 then
			selectable = false
			font = Enum.Font.GothamBold
		end

		local currentRow = row(columns, i % 2 == 1, selectable, font)

		if currentRow:clicked() then
			setSelected(columns)
		end

		if currentRow:hovered() then
			hovered = columns
		end
	end

	return {
		selected = function()
			if selected then
				setSelected(nil)
				return selected
			end
		end,
		hovered = function()
			return hovered
		end,
	}
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="207">
                  <Properties>
                    <string name="Name">window</string>
                    <string name="Source"><![CDATA[local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

--[=[
	@interface WindowOptions
	@within Plasma

	.title? string
	.closable? boolean
	.movable? boolean
	.resizable? boolean
]=]

--[=[
	@within Plasma
	@function window
	@param options string | WindowOptions -- The title of the window, or options
	@param children () -> () -- Children
	@tag widgets
	@return WindowWidgetHandle

	A window widget. Contains children.

	- Closable
	- Draggable
	- Resizable

	Returns a widget handle, which has the field:

	- `closed`, a function you can call to check if the close button was clicked.

	![Window with checkboxes](https://i.eryn.io/2150/TVkkOnxj.png)
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local createConnect = require(script.Parent.Parent.createConnect)
local Style = require(script.Parent.Parent.Style)
local automaticSize = require(script.Parent.Parent.automaticSize)
local c = require(script.Parent.Parent.create)

local MIN_SIZE = Vector2.new(50, 50)
local MAX_SIZE = Vector2.new(1500, 500)

return Runtime.widget(function(options, fn)
	local closed, setClosed = Runtime.useState(false)

	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		local dragConnection

		local connect = createConnect()

		c("Frame", {
			[ref] = "frame",
			BackgroundColor3 = style.bg2,
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(0, 50, 0, 40),

			c("UICorner", {}),

			c("UIPadding", {
				PaddingBottom = UDim.new(0, 20),
				PaddingLeft = UDim.new(0, 20),
				PaddingRight = UDim.new(0, 20),
				PaddingTop = UDim.new(0, 20),
			}),

			c("UIStroke", {}),

			c("TextButton", {
				[ref] = "titleBar",
				Size = UDim2.new(1, 0, 0, 40),
				BackgroundTransparency = 1,
				Text = "",

				InputBegan = function(clickInput)
					if not ref.titleBar.Active then
						return
					end
					if clickInput.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					local lastMousePosition = clickInput.Position

					if
						ref.frame.Parent:FindFirstChildWhichIsA("UIGridStyleLayout")
						and not ref.frame.Parent:IsA("ScreenGui")
					then
						local beforePosition = ref.frame.AbsolutePosition

						local screenGui = ref.frame:FindFirstAncestorOfClass("ScreenGui")

						if screenGui.IgnoreGuiInset then
							beforePosition += GuiService:GetGuiInset()
						end

						ref.frame.Parent = screenGui
						ref.frame.Position = UDim2.new(0, beforePosition.X, 0, beforePosition.Y)
					end

					dragConnection = connect(UserInputService, "InputChanged", function(moveInput)
						local delta = lastMousePosition - moveInput.Position

						lastMousePosition = moveInput.Position

						ref.frame.Position = ref.frame.Position - UDim2.new(0, delta.X, 0, delta.Y)
					end)
				end,

				InputEnded = function(input)
					if dragConnection and input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragConnection:Disconnect()
						dragConnection = nil
					end
				end,

				c("Frame", {
					[ref] = "handle",
					Position = UDim2.new(0, -5, 0, 0),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, 0),
						BackgroundTransparency = 1,
						TextSize = 20,
						TextColor3 = style.mutedTextColor,
					}),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, 7),
						BackgroundTransparency = 1,
						TextSize = 20,
						TextColor3 = style.mutedTextColor,
					}),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, -7),
						BackgroundTransparency = 1,
						TextSize = 20,
						TextColor3 = style.mutedTextColor,
					}),
				}),

				c("TextLabel", {
					[ref] = "title",
					BackgroundTransparency = 1,
					Font = Enum.Font.GothamBold,
					Size = UDim2.new(1, 0, 1, 0),
					TextColor3 = style.mutedTextColor,
					TextSize = 20,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					TextTruncate = Enum.TextTruncate.AtEnd,
				}),

				c("TextButton", {
					[ref] = "close",
					BackgroundColor3 = Color3.fromHex("e74c3c"),
					Size = UDim2.new(0, 20, 0, 20),
					Text = "",
					AnchorPoint = Vector2.new(0.5, 0),
					Position = UDim2.new(1, -10, 0, 0),
					TextColor3 = Color3.fromHex("#71190f"),
					TextSize = 20,
					Font = Enum.Font.Gotham,

					MouseEnter = function()
						ref.close.Text = "x"
					end,

					MouseLeave = function()
						ref.close.Text = ""
					end,

					Activated = function()
						setClosed(true)
					end,

					c("UICorner", {
						CornerRadius = UDim.new(1, 0),
					}),
				}),
			}),

			c("ScrollingFrame", {
				[ref] = "container",
				BackgroundTransparency = 1,
				VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
				HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
				BorderSizePixel = 0,
				ScrollBarThickness = 6,
				Position = UDim2.new(0, 0, 0, 40),

				c("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					Padding = UDim.new(0, 10),
				}),
			}),

			c("TextButton", {
				[ref] = "resizeHandle",
				Size = UDim2.new(0, 20, 0, 20),
				Text = "≡",
				Font = Enum.Font.SourceSans,
				TextSize = 20,
				Rotation = -45,
				BackgroundTransparency = 1,
				TextColor3 = style.mutedTextColor,
				Position = UDim2.new(1, 0, 1, 0),

				InputBegan = function(clickInput)
					if clickInput.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					local initialMousePosition = clickInput.Position
					local initialSize = ref.container.AbsoluteSize

					dragConnection = connect(UserInputService, "InputChanged", function(moveInput)
						if moveInput.UserInputType ~= Enum.UserInputType.MouseMovement then
							return
						end

						local delta = Vector2.new(
							(moveInput.Position.X - initialMousePosition.X),
							(moveInput.Position.Y - initialMousePosition.Y)
						)

						local size = initialSize + delta

						ref.container:SetAttribute(
							"maxSize",
							Vector2.new(math.max(MIN_SIZE.X, size.X), math.max(MIN_SIZE.Y, size.Y))
						)
					end)
				end,

				InputEnded = function(input)
					if dragConnection and input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragConnection:Disconnect()
						dragConnection = nil
					end
				end,
			}),
		})

		automaticSize(ref.container)
		automaticSize(ref.frame)

		return ref.frame, ref.container
	end)

	if type(options) == "string" then
		options = {
			title = options,
		}
	end

	local movable = if options.movable ~= nil then options.movable else true
	local resizable = if options.resizable ~= nil then options.movable else true

	refs.close.Visible = options.closable or false
	refs.handle.Visible = movable
	refs.titleBar.Active = movable
	refs.resizeHandle.Visible = resizable

	refs.title.Size = UDim2.new(1, if options.closable then -30 else 0, 1, 0)

	local spaces = if movable then "  " else ""
	refs.title.Text = options.title and spaces .. string.upper(options.title) or ""

	Runtime.useEffect(function()
		refs.container:SetAttribute("maxSize", options.maxSize or MAX_SIZE)
	end, options.maxSize)

	Runtime.useEffect(function()
		refs.container:SetAttribute("minSize", options.minSize)
	end, options.minSize)

	Runtime.scope(fn)

	local handle = {
		closed = function()
			if closed then
				setClosed(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="208">
            <Properties>
              <string name="Name">promise-character</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local promiseTree = TS.import(script, TS.getModule(script, "@rbxts", "validate-tree")).promiseTree
local CharacterRigR6 = {
	["$className"] = "Model",
	Head = {
		["$className"] = "Part",
		FaceCenterAttachment = "Attachment",
		FaceFrontAttachment = "Attachment",
		HairAttachment = "Attachment",
		HatAttachment = "Attachment",
	},
	HumanoidRootPart = {
		["$className"] = "BasePart",
		RootAttachment = "Attachment",
		RootJoint = "Motor6D",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		HumanoidDescription = "HumanoidDescription",
	},
	["Left Arm"] = {
		["$className"] = "BasePart",
		LeftGripAttachment = "Attachment",
		LeftShoulderAttachment = "Attachment",
	},
	["Left Leg"] = {
		["$className"] = "BasePart",
		LeftFootAttachment = "Attachment",
	},
	["Right Arm"] = {
		["$className"] = "BasePart",
		RightGripAttachment = "Attachment",
		RightShoulderAttachment = "Attachment",
	},
	["Right Leg"] = {
		["$className"] = "BasePart",
		RightFootAttachment = "Attachment",
	},
	Torso = {
		["$className"] = "BasePart",
		["Left Hip"] = "Motor6D",
		["Left Shoulder"] = "Motor6D",
		["Right Hip"] = "Motor6D",
		["Right Shoulder"] = "Motor6D",
		Neck = "Motor6D",
		BodyBackAttachment = "Attachment",
		BodyFrontAttachment = "Attachment",
		LeftCollarAttachment = "Attachment",
		NeckAttachment = "Attachment",
		RightCollarAttachment = "Attachment",
		WaistBackAttachment = "Attachment",
		WaistCenterAttachment = "Attachment",
		WaistFrontAttachment = "Attachment",
	},
	["Body Colors"] = "BodyColors",
}
local CharacterRigR15 = {
	["$className"] = "Model",
	HumanoidRootPart = {
		["$className"] = "BasePart",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		OriginalSize = "Vector3Value",
	},
	LeftHand = {
		["$className"] = "MeshPart",
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerArm = {
		["$className"] = "MeshPart",
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperArm = {
		["$className"] = "MeshPart",
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightHand = {
		["$className"] = "MeshPart",
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerArm = {
		["$className"] = "MeshPart",
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperArm = {
		["$className"] = "MeshPart",
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	UpperTorso = {
		["$className"] = "MeshPart",
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Waist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftFoot = {
		["$className"] = "MeshPart",
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerLeg = {
		["$className"] = "MeshPart",
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperLeg = {
		["$className"] = "MeshPart",
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightFoot = {
		["$className"] = "MeshPart",
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerLeg = {
		["$className"] = "MeshPart",
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperLeg = {
		["$className"] = "MeshPart",
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LowerTorso = {
		["$className"] = "MeshPart",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Root = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		BodyTypeScale = "NumberValue",
		BodyProportionScale = "NumberValue",
		BodyWidthScale = "NumberValue",
		BodyHeightScale = "NumberValue",
		BodyDepthScale = "NumberValue",
		HeadScale = "NumberValue",
		HumanoidDescription = "HumanoidDescription",
	},
	Head = {
		["$className"] = "MeshPart",
		FaceCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		FaceFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HairAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HatAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Neck = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	["Body Colors"] = "BodyColors",
}
-- * Yields until every member of CharacterRigR6 exists
local function promiseR6(character)
	return promiseTree(character, CharacterRigR6)
end
-- * Yields until every member of CharacterRigR15 exists
local function promiseR15(character)
	return promiseTree(character, CharacterRigR15)
end
local default = promiseR15
return {
	promiseR6 = promiseR6,
	promiseR15 = promiseR15,
	CharacterRigR6 = CharacterRigR6,
	CharacterRigR15 = CharacterRigR15,
	default = default,
}
]]></string>
            </Properties>
            <Item class="Folder" referent="209">
              <Properties>
                <string name="Name">node_modules</string>
              </Properties>
              <Item class="Folder" referent="210">
                <Properties>
                  <string name="Name">@rbxts</string>
                </Properties>
                <Item class="Folder" referent="211">
                  <Properties>
                    <string name="Name">compiler-types</string>
                  </Properties>
                  <Item class="Folder" referent="212">
                    <Properties>
                      <string name="Name">types</string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="213">
            <Properties>
              <string name="Name">rewire</string>
            </Properties>
            <Item class="ModuleScript" referent="214">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[local Constants = require(script.Constants)

return {
	HotReloader = require(script.HotReloader),
	CollectionServiceTag = Constants.CollectionServiceTag,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="215">
                <Properties>
                  <string name="Name">Constants</string>
                  <string name="Source">return {
	CollectionServiceTag = "RewireClonedModule"
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="216">
                <Properties>
                  <string name="Name">HotReloader</string>
                  <string name="Source"><![CDATA[--!strict
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Constants = require(script.Parent.Constants)

local HotReloader = {}
HotReloader.__index = HotReloader

--[=[
	@class HotReloader
]=]

type Context = {
	originalModule: ModuleScript,
	isReloading: boolean,
}

--[=[
	@interface Context
	@within HotReloader

	.originalModule ModuleScript
	.isReloading boolean
]=]

--[=[
	Creates a new HotReloader.

	@return HotReloader
]=]
function HotReloader.new()
	local self = setmetatable({
		_listeners = {},
		_clonedModules = {},
	}, HotReloader)
	return self
end

--[=[
	Cleans up this HotReloader, forgetting about any previously modules that were being listened to.
]=]
function HotReloader:destroy()
	for _, listener: RBXScriptConnection in pairs(self._listeners) do
		listener:Disconnect()
	end
	self._listeners = {}
	for _, cloned in pairs(self._clonedModules) do
		cloned:Destroy()
	end
	self._clonedModules = {}
end

--[=[
	Listen to changes from a single module.

	Runs the given `callback` once to start, and then again whenever the module changes.

	Runs the given `cleanup` callback after a module is changed, but before `callback` is run.

	Both are passed a [Context] object, which contains information about the original module
	and whether or not the script is reloading.

	- For `callback`, `Context.isReloading` is true if running as a result of a hot-reload (false indicates first run).
	- For `cleanup`, `Context.isReloading` is true if the module is about to be hot-reloaded (false indicates this is the last cleanup).

	@param module -- The original module to attach listeners to
	@param callback -- A callback that runs when the ModuleScript is added or changed
	@param cleanup -- A callback that runs when the ModuleScript is changed or removed
]=]
function HotReloader:listen(
	module: ModuleScript,
	callback: (ModuleScript, Context) -> (),
	cleanup: (ModuleScript, Context) -> ()
)
	if RunService:IsStudio() then
		local moduleChanged = module.Changed:Connect(function()
			local originalStillExists = game:IsAncestorOf(module)

			local cleanupContext = {
				isReloading = originalStillExists,
				originalModule = module,
			}

			if self._clonedModules[module] then
				cleanup(self._clonedModules[module], cleanupContext)
				self._clonedModules[module]:Destroy()
			else
				cleanup(module, cleanupContext)
			end

			if not originalStillExists then
				return
			end

			local cloned = module:Clone()

			CollectionService:AddTag(cloned, Constants.CollectionServiceTag)

			cloned.Parent = module.Parent
			self._clonedModules[module] = cloned

			callback(cloned, {
				originalModule = module,
				isReloading = true,
			})
			warn(("HotReloaded %s!"):format(module:GetFullName()))
		end)
		table.insert(self._listeners, moduleChanged)
	end

	callback(module, {
		originalModule = module,
		isReloading = false,
	})
end

--[=[
	Scans current and new descendants of an object for ModuleScripts, and runs `callback` for each of them.

	This function has the same semantics as [HotReloader:listen].

	@param container -- The root instance
	@param callback -- A callback that runs when the ModuleScript is added or changed
	@param cleanup -- A callback that runs when the ModuleScript is changed or removed
]=]
function HotReloader:scan(
	container: Instance,
	callback: (ModuleScript, Context) -> (),
	cleanup: (ModuleScript, Context) -> ()
)
	local function add(module)
		self:listen(module, callback, cleanup)
	end

	for _, instance in container:GetDescendants() do
		if instance:IsA("ModuleScript") then
			add(instance)
		end
	end

	local descendantAdded = container.DescendantAdded:Connect(function(instance)
		if instance:IsA("ModuleScript") and not CollectionService:HasTag(instance, Constants.CollectionServiceTag) then
			add(instance)
		end
	end)

	table.insert(self._listeners, descendantAdded)
end

return HotReloader
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="217">
            <Properties>
              <string name="Name">roact</string>
            </Properties>
            <Item class="ModuleScript" referent="218">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--~strict
--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict({
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	forwardRef = require(script.forwardRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {},
})

return Roact
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="219">
                <Properties>
                  <string name="Name">Binding</string>
                  <string name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(_newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = ("Expected arg #1 to contain only bindings, but key %q had a non-binding value"):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(_newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="220">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if
		lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate
		or lifecyclePhase == ComponentLifecyclePhase.WillUpdate
		or lifecyclePhase == ComponentLifecyclePhase.Render
		or lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)
	elseif
		lifecyclePhase == ComponentLifecyclePhase.DidMount
		or lifecyclePhase == ComponentLifecyclePhase.DidUpdate
		or lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)
	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)
	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(tostring(internalData.componentClass))

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(
			("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
				typeof(validator),
				self.__componentName
			)
		)
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(
			("Property validation failed in %s: %s\n\n%s"):format(
				self.__componentName,
				tostring(failureReason),
				self:getElementTraceback() or "<enable element tracebacks>"
			),
			0
		)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="221">
                <Properties>
                  <string name="Name">ComponentLifecyclePhase</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="222">
                <Properties>
                  <string name="Name">Config</string>
                  <string name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = ("Invalid global configuration key %q. Valid configuration keys are: %s"):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end,
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = ("Invalid global configuration key %q (type %s). Valid configuration keys are: %s"):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(tostring(value), typeof(value), tostring(key))

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="223">
                <Properties>
                  <string name="Name">ElementKind</string>
                  <string name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="224">
                <Properties>
                  <string name="Name">ElementUtils</string>
                  <string name="Source"><![CDATA[local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="225">
                <Properties>
                  <string name="Name">GlobalConfig</string>
                  <string name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="226">
                <Properties>
                  <string name="Name">Logging</string>
                  <string name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = { "LogInfo {" }

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="227">
                <Properties>
                  <string name="Name">None</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="228">
                <Properties>
                  <string name="Name">NoopRenderer</string>
                  <string name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(_reconciler, _node) end

function NoopRenderer.unmountHostNode(_reconciler, _node) end

function NoopRenderer.updateHostNode(_reconciler, node, _newElement)
	return node
end

return NoopRenderer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="229">
                <Properties>
                  <string name="Name">Portal</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="230">
                <Properties>
                  <string name="Name">PropMarkers</string>
                </Properties>
                <Item class="ModuleScript" referent="231">
                  <Properties>
                    <string name="Name">Change</string>
                    <string name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(_self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="232">
                  <Properties>
                    <string name="Name">Children</string>
                    <string name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="233">
                  <Properties>
                    <string name="Name">Event</string>
                    <string name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(_self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="234">
                  <Properties>
                    <string name="Name">Ref</string>
                    <string name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="235">
                <Properties>
                  <string name="Name">PureComponent</string>
                  <string name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="236">
                <Properties>
                  <string name="Name">RobloxRenderer</string>
                  <string name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(typeof(ref)))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="237">
                <Properties>
                  <string name="Name">SingleEventManager</string>
                  <string name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(tostring(key), event), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount)
			)

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="238">
                <Properties>
                  <string name="Name">Symbol</string>
                  <string name="Source"><![CDATA[--!nonstrict
--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="239">
                <Properties>
                  <string name="Name">Type</string>
                  <string name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="240">
                <Properties>
                  <string name="Name">assertDeepEqual</string>
                  <string name="Source"><![CDATA[--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(typeof(a), typeof(b))
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate:gsub("{1}", "first"):gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="241">
                <Properties>
                  <string name="Name">assign</string>
                  <string name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="242">
                <Properties>
                  <string name="Name">createContext</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(_props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
			self.disconnect = nil
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="243">
                <Properties>
                  <string name="Name">createElement</string>
                  <string name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="244">
                <Properties>
                  <string name="Name">createFragment</string>
                  <string name="Source"><![CDATA[local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="245">
                <Properties>
                  <string name="Name">createReconciler</string>
                  <string name="Source"><![CDATA[--!nonstrict
local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth
		local parent = virtualNode.parent

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		-- If updating this node has caused a component higher up the tree to re-render
		-- and updateChildren to be re-entered then this node could already have been
		-- unmounted in the previous updateChildren pass.
		if not virtualNode.wasUnmounted then
			unmountVirtualNode(virtualNode)
		end
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
			newNode.parent = parent
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		virtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1

		local currentUpdateChildrenCount = virtualNode.updateChildrenCount

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			-- If updating this node has caused a component higher up the tree to re-render
			-- and updateChildren to be re-entered for this virtualNode then
			-- this result is invalid and needs to be disgarded.
			if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
				if newNode and newNode ~= virtualNode.children[childKey] then
					unmountVirtualNode(newNode)
				end
				return
			end

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- If updating this node has caused a component higher up the tree to re-render
				-- and updateChildren to be re-entered for this virtualNode then
				-- this result is invalid and needs to be discarded.
				if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
					if childNode then
						unmountVirtualNode(childNode)
					end
					return
				end

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					childNode.parent = virtualNode
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == "boolean" then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(
				("%s\n%s"):format(
					"Component returned invalid children:",
					virtualNode.currentElement.source or "<enable element tracebacks>"
				),
				0
			)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		virtualNode.wasUnmounted = true

		local kind = ElementKind.of(virtualNode.currentElement)

		-- selene: allow(if_same_then_else)
		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(
				renderer.isHostObject(hostParent) or hostParent == nil,
				"Expected arg #2 to be a host object"
			)
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			parent = nil,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,
			updateChildrenCount = 0,
			wasUnmounted = false,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(
				renderer.isHostObject(hostParent) or hostParent == nil,
				"Expected arg #2 to be a host object"
			)
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="246">
                <Properties>
                  <string name="Name">createReconcilerCompat</string>
                  <string name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="247">
                <Properties>
                  <string name="Name">createRef</string>
                  <string name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(_self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(_self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(_self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="248">
                <Properties>
                  <string name="Name">createSignal</string>
                  <string name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function createSignal()
	local connections = {}
	local suspendedConnections = {}
	local firing = false

	local function subscribe(_self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
			disconnected = false,
		}

		-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable
		-- the existing one.
		if firing and not connections[callback] then
			suspendedConnections[callback] = connection
		end

		connections[callback] = connection

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections[callback] = nil
			suspendedConnections[callback] = nil
		end

		return disconnect
	end

	local function fire(_self, ...)
		firing = true
		for callback, connection in pairs(connections) do
			if not connection.disconnected and not suspendedConnections[callback] then
				callback(...)
			end
		end

		firing = false

		for callback, _ in pairs(suspendedConnections) do
			suspendedConnections[callback] = nil
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="249">
                <Properties>
                  <string name="Name">createSpy</string>
                  <string name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {}
	self.callCount = 0
	self.values = {}
	self.valuesLength = 0
	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = { ... }
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
		return nil
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="250">
                <Properties>
                  <string name="Name">forwardRef</string>
                  <string name="Source"><![CDATA[local assign = require(script.Parent.assign)
local None = require(script.Parent.None)
local Ref = require(script.Parent.PropMarkers.Ref)

local config = require(script.Parent.GlobalConfig).get()

local excludeRef = {
	[Ref] = None,
}

--[[
	Allows forwarding of refs to underlying host components. Accepts a render
	callback which accepts props and a ref, and returns an element.
]]
local function forwardRef(render)
	if config.typeChecks then
		assert(typeof(render) == "function", "Expected arg #1 to be a function")
	end

	return function(props)
		local ref = props[Ref]
		local propsWithoutRef = assign({}, props, excludeRef)

		return render(propsWithoutRef, ref)
	end
end

return forwardRef
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="251">
                <Properties>
                  <string name="Name">getDefaultInstanceProperty</string>
                  <string name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="252">
                <Properties>
                  <string name="Name">internalAssert</string>
                  <string name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="253">
                <Properties>
                  <string name="Name">invalidSetStateMessages</string>
                  <string name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="254">
                <Properties>
                  <string name="Name">oneChild</string>
                  <string name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="255">
                <Properties>
                  <string name="Name">strict</string>
                  <string name="Source"><![CDATA[--!nonstrict
local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(_self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), name)

			error(message, 2)
		end,

		__newindex = function(_self, key, _value)
			local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), name)

			error(message, 2)
		end,
	})
end

return strict
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="256">
            <Properties>
              <string name="Name">roact-hooks</string>
            </Properties>
            <Item class="ModuleScript" referent="257">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[local createUseBinding = require(script.createUseBinding)
local createUseCallback = require(script.createUseCallback)
local createUseContext = require(script.createUseContext)
local createUseEffect = require(script.createUseEffect)
local createUseMemo = require(script.createUseMemo)
local createUseReducer = require(script.createUseReducer)
local createUseState = require(script.createUseState)
local createUseValue = require(script.createUseValue)
local dependenciesDifferent = require(script.dependenciesDifferent)

local Hooks = {}

local function createHooks(roact, component)
	local useEffect = createUseEffect(component)
	local useState = createUseState(component)
	local useValue = createUseValue(component)

	local useBinding = createUseBinding(roact, useValue)
	local useContext = createUseContext(component, useEffect, useState)
	local useMemo = createUseMemo(useValue)

	local useCallback = createUseCallback(useMemo)

	local useReducer = createUseReducer(useCallback, useState)

	return {
		Roact = roact,
		useBinding = useBinding,
		useCallback = useCallback,
		useContext = useContext,
		useEffect = useEffect,
		useMemo = useMemo,
		useReducer = useReducer,
		useState = useState,
		useValue = useValue,
	}
end

function Hooks.new(roact)
	return function(render, options)
		assert(typeof(render) == "function", "Hooked components must be functions.")

		if options == nil then
			options = {}
		end

		local componentType = options.componentType
		local name = options.name or debug.info(render, "n")

		local classComponent

		if componentType == nil or componentType == "Component" then
			classComponent = roact.Component:extend(name)
		elseif componentType == "PureComponent" then
			classComponent = roact.PureComponent:extend(name)
		else
			error(
				string.format(
					"'%s' is not a valid componentType. componentType must either be nil, 'Component', or 'PureComponent'",
					tostring(componentType)
				)
			)
		end

		classComponent.defaultProps = options.defaultProps
		classComponent.validateProps = options.validateProps

		function classComponent:init()
			self.defaultStateValues = {}
			self.effectDependencies = {}
			self.effects = {}
			self.unmountEffects = {}

			self.hooks = createHooks(roact, self)
		end

		function classComponent:runEffects()
			for index = 1, self.hookCounter do
				local effectData = self.effects[index]
				if effectData == nil then
					continue
				end

				local effect, dependsOn = unpack(effectData)

				if dependsOn ~= nil then
					local lastDependencies = self.effectDependencies[index]
					if lastDependencies ~= nil and not dependenciesDifferent(dependsOn, lastDependencies) then
						continue
					end

					self.effectDependencies[index] = dependsOn
				end

				local unmountEffect = self.unmountEffects[index]
				if unmountEffect ~= nil then
					unmountEffect()
				end

				self.unmountEffects[index] = effect()
			end
		end

		function classComponent:didMount()
			self:runEffects()
		end

		function classComponent:didUpdate()
			self:runEffects()
		end

		function classComponent:willUnmount()
			for index = 1, self.hookCounter do
				local unmountEffect = self.unmountEffects[index]

				if unmountEffect ~= nil then
					unmountEffect()
				end
			end
		end

		function classComponent:render()
			self.hookCounter = 0

			return render(self.props, self.hooks)
		end

		return classComponent
	end
end

return Hooks
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="258">
                <Properties>
                  <string name="Name">createUseBinding</string>
                  <string name="Source"><![CDATA[local function createUseBinding(roact, useValue)
	return function(defaultValue)
		return unpack(useValue({
			roact.createBinding(defaultValue)
		}).value)
	end
end

return createUseBinding
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="259">
                <Properties>
                  <string name="Name">createUseCallback</string>
                  <string name="Source"><![CDATA[local function createUseCallback(useMemo)
	return function(callback, dependencies)
		return useMemo(function()
			return callback
		end, dependencies)
	end
end

return createUseCallback
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="260">
                <Properties>
                  <string name="Name">createUseContext</string>
                  <string name="Source"><![CDATA[local function createUseContext(component, useEffect, useState)
	-- HACK: I'd like to just use the values from the consumers directly.
	-- However, we don't know what contexts to listen to until `useContext` is called.
	-- Thus, we do this insanely unstable method for doing it. :)
	local fakeConsumer = setmetatable({}, {
		__index = component,
	})

	return function(context)
		context.Consumer.init(fakeConsumer)

		local contextEntry = fakeConsumer.contextEntry
		local value, setValue = useState(if contextEntry == nil then nil else contextEntry.value)

		useEffect(function()
			if contextEntry == nil then
				return
			end

			if value ~= contextEntry.value then
				setValue(contextEntry.value)
			end
			
			return contextEntry.onUpdate:subscribe(setValue)
		end, { contextEntry })

		return value
	end
end

return createUseContext
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="261">
                <Properties>
                  <string name="Name">createUseEffect</string>
                  <string name="Source"><![CDATA[local function createUseEffect(component)
	return function(callback, dependsOn)
		assert(typeof(callback) == "function", "useEffect callback is not a function")

		component.hookCounter += 1
		local hookCount = component.hookCounter

		-- TODO: This mutates the component in the middle of render. That's bad, right?
		-- It's idempotent, so it shouldn't matter.
		-- Is there a way to do this that keeps `render` truly pure?
		component.effects[hookCount] = { callback, dependsOn }
	end
end

return createUseEffect
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="262">
                <Properties>
                  <string name="Name">createUseMemo</string>
                  <string name="Source"><![CDATA[local dependenciesDifferent = require(script.Parent.dependenciesDifferent)

local function createUseMemo(useValue)
	return function(createValue, dependencies)
		local currentValue = useValue(nil)

		local needToRecalculate = dependencies == nil

		if currentValue.value == nil or dependenciesDifferent(dependencies, currentValue.value.dependencies) then
			needToRecalculate = true
		end

		if needToRecalculate then
			currentValue.value = {
				dependencies = dependencies,
				memoizedValue = { createValue() },
			}
		end

		return unpack(currentValue.value.memoizedValue)
	end
end

return createUseMemo
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="263">
                <Properties>
                  <string name="Name">createUseReducer</string>
                  <string name="Source"><![CDATA[local function createUseReducer(useCallback, useState)
	return function(reducer, initialState)
		local state, setState = useState(initialState)
		local dispatch = useCallback(function(action)
			setState(reducer(state, action))
		end, { state })

		return state, dispatch
	end
end

return createUseReducer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="264">
                <Properties>
                  <string name="Name">createUseState</string>
                  <string name="Source"><![CDATA[local NONE = {}

local function extractValue(valueOrCallback, currentValue)
	if type(valueOrCallback) == "function" then
		return valueOrCallback(currentValue)
	else
		return valueOrCallback
	end
end

local function createUseState(component)
	local setValues = {}

	return function(defaultValue)
		component.hookCounter += 1
		local hookCount = component.hookCounter
		local value = component.state[hookCount]

		if value == nil then
			local storedDefaultValue = component.defaultStateValues[hookCount]
			if storedDefaultValue == NONE then
				value = nil
			elseif storedDefaultValue ~= nil then
				value = storedDefaultValue
			elseif type(defaultValue) == "function" then
				value = defaultValue()

				if value == nil then
					component.defaultStateValues[hookCount] = NONE
				else
					component.defaultStateValues[hookCount] = value
				end
			else
				value = defaultValue
				component.defaultStateValues[hookCount] = value
			end
		elseif value == NONE then
			value = nil
		end

		local setValue = setValues[hookCount]
		if setValue == nil then
			setValue = function(newValue)
				local currentValue = component.state[hookCount]

				if currentValue == nil then
					currentValue = component.defaultStateValues[hookCount]
				end

				if currentValue == NONE then
					currentValue = nil
				end

				newValue = extractValue(newValue, currentValue)

				if newValue == nil then
					newValue = NONE
				end

				component:setState({
					[hookCount] = newValue,
				})
			end

			setValues[hookCount] = setValue
		end

		return value, setValue
	end
end

return createUseState
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="265">
                <Properties>
                  <string name="Name">createUseValue</string>
                  <string name="Source"><![CDATA[local function createUseValue(component)
	return function(defaultValue)
		component.hookCounter += 1
		local hookCount = component.hookCounter

		if component.values == nil then
			component.values = {}
		end

		if component.values[hookCount] == nil then
			component.values[hookCount] = { value = defaultValue }
		end

		return component.values[hookCount]
	end
end

return createUseValue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="266">
                <Properties>
                  <string name="Name">dependenciesDifferent</string>
                  <string name="Source"><![CDATA[local function dependenciesDifferent(dependencies, lastDependencies)
	local length = 0

	for index, dependency in pairs(dependencies) do
		length += 1

		if dependency ~= lastDependencies[index] then
			return true
		end
	end

	for _ in pairs(lastDependencies) do
		length -= 1
	end

	if length ~= 0 then
		return true
	end

	return false
end

return dependenciesDifferent
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="267">
            <Properties>
              <string name="Name">rust-classes</string>
            </Properties>
            <Item class="ModuleScript" referent="268">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyRegister = TS.import(script, script, "util", "lazyLoad").lazyRegister
local _HashMap = TS.import(script, script, "classes", "HashMap")
local Entry = _HashMap.Entry
local HashMap = _HashMap.HashMap
lazyRegister("HashMap", HashMap)
local Iterator = TS.import(script, script, "classes", "Iterator").Iterator
lazyRegister("Iterator", Iterator)
local Option = TS.import(script, script, "classes", "Option").Option
lazyRegister("Option", Option)
local OptionMut = TS.import(script, script, "classes", "OptionMut").OptionMut
local Result = TS.import(script, script, "classes", "Result").Result
lazyRegister("Result", Result)
local Vec = TS.import(script, script, "classes", "Vec").Vec
lazyRegister("Vec", Vec)
local unit = TS.import(script, script, "util", "Unit").unit
return {
	Entry = Entry,
	HashMap = HashMap,
	Iterator = Iterator,
	Option = Option,
	OptionMut = OptionMut,
	Result = Result,
	Vec = Vec,
	unit = unit,
}
]]></string>
              </Properties>
              <Item class="Folder" referent="269">
                <Properties>
                  <string name="Name">classes</string>
                </Properties>
                <Item class="ModuleScript" referent="270">
                  <Properties>
                    <string name="Name">HashMap</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local _sizeHint = TS.import(script, script.Parent.Parent, "util", "sizeHint")
local fixedSizeHint = _sizeHint.fixedSizeHint
local upperSizeHint = _sizeHint.upperSizeHint
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local Entry
do
	Entry = setmetatable({}, {
		__tostring = function()
			return "Entry"
		end,
	})
	Entry.__index = Entry
	function Entry.new(...)
		local self = setmetatable({}, Entry)
		return self:constructor(...) or self
	end
	function Entry:constructor(map, index)
		self.map = map
		self.index = index
	end
	function Entry:construct(map, key)
		return Entry.new(map, key)
	end
	function Entry:orInsert(def)
		return self.map:get(self.index):unwrapOrElse(function()
			self.map:insert(self.index, def)
			return def
		end)
	end
	function Entry:orInsertWith(def)
		return self.map:get(self.index):unwrapOrElse(function()
			local val = def()
			self.map:insert(self.index, val)
			return val
		end)
	end
	function Entry:orInsertWithKey(def)
		return self.map:get(self.index):unwrapOrElse(function()
			local val = def(self.index)
			self.map:insert(self.index, val)
			return val
		end)
	end
	function Entry:key()
		return self.index
	end
	function Entry:andModify(f)
		self.map:get(self.index):map(f)
		return self
	end
	function Entry:insert(value)
		self.map:insert(self.index, value)
		return self
	end
end
local HashMap
do
	HashMap = setmetatable({}, {
		__tostring = function()
			return "HashMap"
		end,
	})
	HashMap.__index = HashMap
	function HashMap.new(...)
		local self = setmetatable({}, HashMap)
		return self:constructor(...) or self
	end
	function HashMap:constructor(map)
		self.map = map
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in pairs(self.map) do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		self.length = _size
	end
	function HashMap:withCapacity(size)
		return HashMap.new(table.create(size))
	end
	function HashMap:empty()
		return HashMap.new({})
	end
	function HashMap:fromPtr(map)
		return HashMap.new(map)
	end
	function HashMap:toString()
		return "HashMap{" .. string.sub(self:iter():fold("", function(acc, item)
			return acc .. "(" .. tostring(item[1]) .. ", " .. tostring(item[2]) .. "), "
		end), 0, -3) .. "}"
	end
	function HashMap:i(i)
		local val = self.map[i]
		if val == nil then
			error("called `HashMap.i` with an out-of-range index: " .. tostring(i), 2)
		end
		return val
	end
	function HashMap:keys()
		local last
		return Iterator:fromRawParts(function()
			local key = (next(self.map, last))
			return Option:wrap(key):map(function()
				last = key
				return key
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:values()
		local last
		return Iterator:fromRawParts(function()
			local key, value = next(self.map, last)
			return Option:wrap(value):map(function()
				last = key
				return value
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:iter()
		local last
		return Iterator:fromRawParts(function()
			local key, value = next(self.map, last)
			return Option:wrap(value):map(function()
				last = key
				return { key, value }
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:len()
		return self.length
	end
	function HashMap:isEmpty()
		return self.length == 0
	end
	function HashMap:drain()
		local last
		return Iterator:fromRawParts(function()
			local key, value = next(self.map, last)
			return self:removeEntry(key):map(function()
				last = key
				return { key, value }
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:drainFilter(filter)
		local last
		return Iterator:fromRawParts(function()
			while true do
				last = (next(self.map, last))
				if not (last ~= 0 and last == last and last ~= "" and last) then
					break
				end
				local element = self:removeEntry(last)
				if element:map(function(_param)
					local k = _param[1]
					local v = _param[2]
					return filter(k, v)
				end):contains(true) then
					return element
				end
			end
			return Option:none()
		end, upperSizeHint(self.length))
	end
	function HashMap:clear()
		-- ▼ Map.clear ▼
		table.clear(self.map)
		-- ▲ Map.clear ▲
		self.length = 0
		return self
	end
	function HashMap:entry(key)
		return Entry:construct(self, key)
	end
	function HashMap:get(key)
		return Option:wrap(self.map[key])
	end
	function HashMap:getKeyValue(key)
		return Option:some(key):zip(Option:wrap(self.map[key]))
	end
	function HashMap:containsKey(key)
		return self.map[key] ~= nil
	end
	function HashMap:insert(key, value)
		local old = self.map[key]
		-- ▼ Map.set ▼
		self.map[key] = value
		-- ▲ Map.set ▲
		return Option:wrap(old)
	end
	function HashMap:tryInsert(key, value)
		local old = self.map[key]
		if old ~= 0 and old == old and old ~= "" and old then
			return Result:err({
				entry = Entry:construct(self, key),
				value = value,
			})
		end
		-- ▼ Map.set ▼
		self.map[key] = value
		-- ▲ Map.set ▲
		return Result:ok(value)
	end
	function HashMap:remove(key)
		local old = self.map[key]
		-- ▼ Map.delete ▼
		self.map[key] = nil
		-- ▲ Map.delete ▲
		return Option:wrap(old)
	end
	function HashMap:removeEntry(key)
		local old = self.map[key]
		-- ▼ Map.delete ▼
		self.map[key] = nil
		-- ▲ Map.delete ▲
		return Option:some(key):zip(Option:wrap(old))
	end
	function HashMap:retain(filter)
		local _map = self.map
		local _arg0 = function(v, k)
			if not filter(k, v) then
				-- ▼ Map.delete ▼
				self.map[k] = nil
				-- ▲ Map.delete ▲
			end
		end
		-- ▼ ReadonlyMap.forEach ▼
		for _k, _v in pairs(_map) do
			_arg0(_v, _k, _map)
		end
		-- ▲ ReadonlyMap.forEach ▲
		return self
	end
	function HashMap:intoKeys()
		local last
		return Iterator:fromRawParts(function()
			local key, value = next(self.map, last)
			return Option:wrap(key):map(function()
				last = key
				return key
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:intoValues()
		local last
		return Iterator:fromRawParts(function()
			local key, value = next(self.map, last)
			return Option:wrap(key):map(function()
				last = key
				return value
			end)
		end, fixedSizeHint(self.length))
	end
	function HashMap:__tostring()
		return self:toString()
	end
end
return {
	Entry = Entry,
	HashMap = HashMap,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="271">
                  <Properties>
                    <string name="Name">Iterator</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local _sizeHint = TS.import(script, script.Parent.Parent, "util", "sizeHint")
local fixedSizeHint = _sizeHint.fixedSizeHint
local lowerSizeHint = _sizeHint.lowerSizeHint
local unit = TS.import(script, script.Parent.Parent, "util", "Unit").unit
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local Iterator
do
	Iterator = setmetatable({}, {
		__tostring = function()
			return "Iterator"
		end,
	})
	Iterator.__index = Iterator
	function Iterator.new(...)
		local self = setmetatable({}, Iterator)
		return self:constructor(...) or self
	end
	function Iterator:constructor(nextItem, sizeHint)
		self.nextItem = nextItem
		self.consumed = false
		local _condition = sizeHint
		if _condition == nil then
			_condition = lowerSizeHint(0)
		end
		self.sizeHint = _condition
	end
	function Iterator:fromRawParts(nextItem, sizeHint)
		return Iterator.new(nextItem, sizeHint)
	end
	function Iterator:fromItems(...)
		local items = { ... }
		local i = 0
		return Iterator.new(function()
			local _fn = Option
			local _exp = items
			local _original = i
			i += 1
			return _fn:wrap(_exp[_original + 1])
		end, fixedSizeHint(#items))
	end
	function Iterator:consume()
		if self.consumed then
			error("Attempt to consume Iterator twice", 3)
		end
		self.consumed = true
	end
	function Iterator:count()
		self:consume()
		local i = 0
		repeat
			do
				i += 1
			end
		until not self.nextItem():isSome()
		return i
	end
	function Iterator:last()
		self:consume()
		local last = Option:none()
		while true do
			local curr = self.nextItem()
			if curr:isNone() then
				break
			end
			last = curr
		end
		return last
	end
	function Iterator:advanceBy(n)
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < n) then
					break
				end
				if self.nextItem():isNone() then
					return Result:err(i - 1)
				end
			end
		end
		return Result:ok(unit())
	end
	function Iterator:nth(n)
		return self:advanceBy(n):okOption():andWith(function()
			return self.nextItem()
		end)
	end
	function Iterator:stepBy(step)
		self:consume()
		if step == 0 then
			error("called Iterator.stepBy with a step of 0", 2)
		end
		local takeFirst = true
		return Iterator.new(function()
			if takeFirst then
				takeFirst = false
				return self.nextItem()
			else
				return self:nth(step - 1)
			end
		end, function()
			local low, high = self.sizeHint()
			local firstSize = function(step)
				return function(n)
					return n == 0 and 0 or 1 + (n - 1) / step
				end
			end
			local otherSize = function(step)
				return function(n)
					return n / step
				end
			end
			local f = (takeFirst and firstSize or otherSize)(step)
			return f(low), high:map(f)
		end)
	end
	function Iterator:chain(other)
		self:consume()
		other:consume()
		local firstDone = false
		return Iterator.new(function()
			if firstDone then
				return other.nextItem()
			else
				local result = self.nextItem()
				if result:isNone() then
					firstDone = true
					return other.nextItem()
				else
					return result
				end
			end
		end, function()
			local firstLow, firstHigh = self.sizeHint()
			local lastLow, lastHigh = other.sizeHint()
			return firstLow + lastLow, firstHigh:andWith(function(firstSize)
				return lastHigh:map(function(lastSize)
					return firstSize + lastSize
				end)
			end)
		end)
	end
	function Iterator:zip(other)
		self:consume()
		other:consume()
		return Iterator.new(function()
			local first = self.nextItem()
			if first:isSome() then
				return first:zip(other.nextItem())
			else
				return Option:none()
			end
		end, function()
			local firstLow, firstHigh = self.sizeHint()
			local lastLow, lastHigh = other.sizeHint()
			local _exp = math.min(firstLow, lastLow)
			local _fn = firstHigh:map(function(firstSize)
				return lastHigh:map(function(lastSize)
					return math.min(firstSize, lastSize)
				end):unwrapOr(firstSize)
			end)
			return _exp, _fn["or"](_fn, lastHigh)
		end)
	end
	function Iterator:intersperse(other)
		return self:intersperseWith(function()
			return other
		end)
	end
	function Iterator:intersperseWith(other)
		self:consume()
		local doIntermediate = true
		return Iterator.new(function()
			doIntermediate = not doIntermediate
			if doIntermediate then
				return Option:some(other())
			else
				return self.nextItem()
			end
		end, function()
			local low, high = self.sizeHint()
			local f = function(n)
				if n < 2 then
					return n
				else
					return n * 2 - 1
				end
			end
			return f(low), high:map(f)
		end)
	end
	function Iterator:map(f)
		self:consume()
		return Iterator.new(function()
			return self.nextItem():map(f)
		end, function()
			return self.sizeHint()
		end)
	end
	function Iterator:forEach(f)
		self:consume()
		local result
		while true do
			result = self.nextItem()
			if result:isNone() then
				break
			end
			result:map(f)
		end
	end
	function Iterator:filter(f)
		self:consume()
		return Iterator.new(function()
			while true do
				local item = self.nextItem()
				if item:isNone() or item:map(f):contains(true) then
					return item
				end
			end
		end, function()
			return 0, (select(2, self.sizeHint()))
		end)
	end
	function Iterator:filterMap(f)
		self:consume()
		return Iterator.new(function()
			while true do
				local item = self.nextItem()
				local mapped = item:andWith(f)
				if mapped:isSome() then
					return mapped
				end
			end
		end, function()
			return 0, (select(2, self.sizeHint()))
		end)
	end
	function Iterator:enumerate()
		self:consume()
		local i = 0
		return Iterator.new(function()
			return Option:some(i):zip(self.nextItem()):map(function(item)
				i += 1
				return item
			end)
		end, function()
			return self.sizeHint()
		end)
	end
	function Iterator:skipWhile(f)
		self:consume()
		while true do
			local item = self.nextItem()
			local mapped = item:map(f)
			if not mapped:contains(true) then
				break
			end
		end
		return Iterator.new(function()
			return self.nextItem()
		end, function()
			return 0, (select(2, self.sizeHint()))
		end)
	end
	function Iterator:takeWhile(f)
		self:consume()
		local done = false
		return Iterator.new(function()
			if done then
				return Option:none()
			else
				local item = self.nextItem()
				local mapped = item:map(f)
				if not mapped:contains(true) then
					return item
				else
					if item:isSome() then
						done = true
					end
					return Option:none()
				end
			end
		end, function()
			if done then
				return 0, Option:some(0)
			else
				return 0, (select(2, self.sizeHint()))
			end
		end)
	end
	function Iterator:mapWhile(f)
		self:consume()
		return Iterator.new(function()
			return self.nextItem():andWith(f)
		end, function()
			return 0, (select(2, self.sizeHint()))
		end)
	end
	function Iterator:skip(n)
		self:consume()
		local skipped = false
		return Iterator.new(function()
			if not skipped then
				skipped = true
				return self:nth(n)
			else
				return self.nextItem()
			end
		end, function()
			local low, high = self.sizeHint()
			return math.max(0, low - n), high:map(function(size)
				return math.max(0, size - n)
			end)
		end)
	end
	function Iterator:take(n)
		self:consume()
		local toGo = n
		return Iterator.new(function()
			if toGo > 0 then
				toGo -= 1
				return self.nextItem()
			else
				return Option:none()
			end
		end, function()
			local low, high = self.sizeHint()
			local _exp = math.min(low, n)
			local _fn = high:andWith(function(size)
				return size < n and Option:some(size) or Option:none()
			end)
			return _exp, _fn["or"](_fn, Option:some(n))
		end)
	end
	function Iterator:scan(state, f)
		self:consume()
		return Iterator.new(function()
			return self.nextItem():andWith(function(item)
				return f(state, item)
			end)
		end, function()
			return 0, (select(2, self.sizeHint()))
		end)
	end
	function Iterator:flatMap(f)
		self:consume()
		local curr
		return Iterator.new(function()
			local item = curr.nextItem()
			if item:isNone() then
				local nextIter = self.nextItem()
				return nextIter:match(function(iter)
					curr = f(iter)
					return curr.nextItem()
				end, function()
					return Option:none()
				end)
			else
				return item
			end
		end, function()
			if (select(2, self.sizeHint())):contains(0) then
				return curr.sizeHint()
			else
				return (curr.sizeHint()), Option:none()
			end
		end)
	end
	function Iterator:flatten()
		return self:flatMap(function(i)
			return i
		end)
	end
	function Iterator:fuse()
		self:consume()
		local done = false
		return Iterator.new(function()
			if done then
				return Option:none()
			else
				local item = self.nextItem()
				if item:isNone() then
					done = true
				end
				return item
			end
		end, function()
			if done then
				return 0, Option:some(0)
			else
				return 0, (select(2, self.sizeHint()))
			end
		end)
	end
	function Iterator:inspect(f)
		self:consume()
		return Iterator.new(function()
			local item = self.nextItem()
			item:map(f)
			return item
		end, function()
			return self.sizeHint()
		end)
	end
	function Iterator:byRef()
		return Iterator.new(function()
			return self.nextItem()
		end, function()
			return self.sizeHint()
		end)
	end
	function Iterator:collect()
		self:consume()
		local size = { self.sizeHint() }
		local vec = Vec:withCapacity(size[2]:unwrapOr(size[1]))
		local item = self.nextItem()
		while item:isSome() do
			vec:push(item:unwrap())
			item = self.nextItem()
		end
		return vec
	end
	function Iterator:partition(f)
		local trueVec = Vec:vec()
		local falseVec = Vec:vec()
		self:forEach(function(item)
			if f(item) then
				trueVec:push(item)
			else
				falseVec:push(item)
			end
		end)
		return trueVec, falseVec
	end
	function Iterator:tryFold(init, f)
		local acc = Result:ok(init)
		local item = self.nextItem()
		while item:isSome() do
			acc = f(acc:asPtr(), item:unwrap())
			if acc:isErr() then
				break
			end
			item = self.nextItem()
		end
		return acc
	end
	function Iterator:tryForEach(f)
		return self:tryFold(unit(), function(_, item)
			return f(item)
		end)
	end
	function Iterator:fold(init, f)
		self:consume()
		local acc = init
		local item = self.nextItem()
		while item:isSome() do
			acc = f(acc, item:unwrap())
			item = self.nextItem()
		end
		return acc
	end
	function Iterator:reduce(f)
		local first = self.nextItem()
		return first:map(function(item)
			return self:fold(item, f)
		end):orElse(function()
			self:consume()
			return Option:none()
		end)
	end
	function Iterator:all(f)
		local item = self.nextItem()
		while item:isSome() do
			if not f(item:unwrap()) then
				return false
			end
			item = self.nextItem()
		end
		return true
	end
	function Iterator:any(f)
		local item = self.nextItem()
		while item:isSome() do
			if f(item:unwrap()) then
				return true
			end
			item = self.nextItem()
		end
		return false
	end
	function Iterator:find(f)
		local item = self.nextItem()
		while item:isSome() do
			if f(item:unwrap()) then
				return item
			end
			item = self.nextItem()
		end
		return Option:none()
	end
	function Iterator:findMap(f)
		local item = self.nextItem()
		while item:isSome() do
			local result = f(item:unwrap())
			if result:isSome() then
				return result
			end
			item = self.nextItem()
		end
		return Option:none()
	end
	function Iterator:tryFind(f)
		local item = self.nextItem()
		while item:isSome() do
			local result = f(item:unwrap())
			if result:contains(true) then
				return Result:ok(item)
			elseif result:isErr() then
				-- Result err variants are both R
				return result
			end
			item = self.nextItem()
		end
		return Result:ok(Option:none())
	end
	function Iterator:position(f)
		local item = self.nextItem()
		local i = 0
		while item:isSome() do
			if f(item:unwrap()) then
				return Option:some(i)
			end
			item = self.nextItem()
			i += 1
		end
		return Option:none()
	end
	function Iterator:max()
		return self:reduce(function(a, b)
			return b >= a and b or a
		end)
	end
	function Iterator:min()
		return self:reduce(function(a, b)
			return b < a and b or a
		end)
	end
	function Iterator:maxByKey(f)
		return self:reduce(function(a, b)
			local _result
			if f(b) >= f(a) then
				_result = b
			else
				_result = a
			end
			return _result
		end)
	end
	function Iterator:minByKey(f)
		return self:reduce(function(a, b)
			local _result
			if f(b) < f(a) then
				_result = b
			else
				_result = a
			end
			return _result
		end)
	end
	function Iterator:maxBy(f)
		return self:reduce(function(a, b)
			local _result
			if f(a, b) >= 0 then
				_result = a
			else
				_result = b
			end
			return _result
		end)
	end
	function Iterator:unzip()
		self:consume()
		local size = { self.sizeHint() }
		local leftVec = Vec:withCapacity(size[2]:unwrapOr(size[1]))
		local rightVec = Vec:withCapacity(size[2]:unwrapOr(size[1]))
		local item = self.nextItem()
		while item:isSome() do
			local _binding = item:unwrap()
			local a = _binding[1]
			local b = _binding[2]
			leftVec:push(a)
			rightVec:push(b)
			item = self.nextItem()
		end
		return leftVec, rightVec
	end
	function Iterator:sum()
		return self:reduce(function(acc, item)
			return acc + item
		end):unwrapOr(0)
	end
	function Iterator:product()
		return self:reduce(function(acc, item)
			return acc * item
		end):unwrapOr(1)
	end
	function Iterator:eq(other)
		return self:eqBy(other, function(a, b)
			return a == b
		end)
	end
	function Iterator:eqBy(other, eq)
		self:consume()
		while true do
			local item = self.nextItem()
			if item:isNone() then
				return other.nextItem():isNone()
			end
			local a = item:unwrap()
			local otherItem = other.nextItem()
			if otherItem:isNone() then
				return false
			end
			local b = otherItem:unwrap()
			if not eq(a, b) then
				return false
			end
		end
	end
	function Iterator:ne(other)
		return not self:eq(other)
	end
	function Iterator:isSorted()
		return self:isSortedBy(function(a, b)
			return Option:some(a - b)
		end)
	end
	function Iterator:isSortedBy(f)
		self:consume()
		local lastOpt = self.nextItem()
		if lastOpt:isNone() then
			return true
		else
			local last = lastOpt:unwrap()
			return self:all(function(item)
				local result = f(last, item)
				if not result:map(function(ord)
					return ord > 0
				end):contains(false) then
					return false
				end
				last = item
				return true
			end)
		end
	end
	function Iterator:isSortedByKey(f)
		return self:map(f):isSorted()
	end
	function Iterator:generator()
		return TS.generator(function()
			local item = self.nextItem()
			while item:isSome() do
				coroutine.yield(item:unwrap())
				item = self.nextItem()
			end
		end)
	end
end
return {
	Iterator = Iterator,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="272">
                  <Properties>
                    <string name="Name">Option</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local Option
do
	Option = setmetatable({}, {
		__tostring = function()
			return "Option"
		end,
	})
	Option.__index = Option
	function Option.new(...)
		local self = setmetatable({}, Option)
		return self:constructor(...) or self
	end
	function Option:constructor(value)
		self.value = value
	end
	function Option:none()
		return Option.new(nil)
	end
	function Option:some(val)
		return Option.new(val)
	end
	function Option:wrap(val)
		return Option.new(val)
	end
	function Option:toString()
		return self:match(function(val)
			return "Option.some(" .. tostring(val) .. ")"
		end, function()
			return "Option.none"
		end)
	end
	function Option:isSome()
		return self.value ~= nil
	end
	function Option:isNone()
		return not self:isSome()
	end
	function Option:contains(x)
		return self.value == x
	end
	function Option:expect(msg)
		if self:isSome() then
			return self.value
		else
			error(msg)
		end
	end
	function Option:unwrap()
		return self:expect("called `Option.unwrap()` on a `None` value")
	end
	function Option:unwrapOr(def)
		local _result
		if self:isSome() then
			_result = (self.value)
		else
			_result = def
		end
		return _result
	end
	function Option:unwrapOrElse(gen)
		local _result
		if self:isSome() then
			_result = (self.value)
		else
			_result = gen()
		end
		return _result
	end
	function Option:map(func)
		return self:isSome() and Option:some(func(self.value)) or Option:none()
	end
	function Option:mapOr(def, func)
		local _result
		if self:isSome() then
			_result = func(self.value)
		else
			_result = def
		end
		return _result
	end
	function Option:mapOrElse(def, func)
		local _result
		if self:isSome() then
			_result = func(self.value)
		else
			_result = def()
		end
		return _result
	end
	function Option:okOr(err)
		return self:isSome() and Result:ok(self.value) or Result:err(err)
	end
	function Option:okOrElse(err)
		return self:isSome() and Result:ok(self.value) or Result:err(err())
	end
	Option["and"] = function(self, other)
		return self:isNone() and Option:none() or other
	end
	function Option:andWith(other)
		return self:isSome() and other(self.value) or Option:none()
	end
	function Option:filter(func)
		return self:isSome() and (func(self.value) and Option:some(self.value) or Option:none()) or Option:none()
	end
	Option["or"] = function(self, other)
		return self:isSome() and Option:some(self.value) or other
	end
	function Option:orElse(other)
		return self:isSome() and Option:some(self.value) or other()
	end
	function Option:xor(other)
		return self:isSome() and (other:isSome() and Option:none() or Option:some(self.value)) or other:isSome() and Option:some(other.value) or Option:none()
	end
	function Option:zip(other)
		if self:isSome() and other:isSome() then
			return Option:some({ self.value, other.value })
		end
		return Option:none()
	end
	function Option:zipWith(other, func)
		if self:isSome() and other:isSome() then
			return Option:some(func(self.value, other.value))
		end
		return Option:none()
	end
	function Option:copied()
		return Option:wrap(self.value)
	end
	function Option:cloned()
		return self:map(function(i)
			return i.cloned()
		end)
	end
	function Option:transpose()
		return self:isSome() and (self.value:isOk() and Result:ok(Option:some(self.value:asPtr())) or Result:err(self.value:asPtr())) or Result:ok(Option:none())
	end
	function Option:flatten()
		return self:isSome() and Option:wrap(self.value.value) or Option:none()
	end
	function Option:match(ifSome, ifNone)
		local _result
		if self:isSome() then
			_result = ifSome(self.value)
		else
			_result = ifNone()
		end
		return _result
	end
	function Option:asPtr()
		return self.value
	end
	function Option:__tostring()
		return self:toString()
	end
end
local optionMeta = Option
optionMeta.__unm = function(option)
	return option:map(function(item)
		return -item
	end)
end
optionMeta.__add = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item + otherItem
		end)
	end)
end
optionMeta.__sub = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item - otherItem
		end)
	end)
end
optionMeta.__mul = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item * otherItem
		end)
	end)
end
optionMeta.__div = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item / otherItem
		end)
	end)
end
optionMeta.__mod = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item % otherItem
		end)
	end)
end
optionMeta.__pow = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return bit32.bxor(item, otherItem)
		end)
	end)
end
optionMeta.__eq = function(a, b)
	return a:asPtr() == b:asPtr()
end
optionMeta.__len = function(option)
	return option:map(function(item)
		return #item
	end):unwrapOr(0)
end
return {
	Option = Option,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="273">
                  <Properties>
                    <string name="Name">OptionMut</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local fixedSizeHint = TS.import(script, script.Parent.Parent, "util", "sizeHint").fixedSizeHint
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local OptionMut
do
	local super = Option
	OptionMut = setmetatable({}, {
		__tostring = function()
			return "OptionMut"
		end,
		__index = super,
	})
	OptionMut.__index = OptionMut
	function OptionMut.new(...)
		local self = setmetatable({}, OptionMut)
		return self:constructor(...) or self
	end
	function OptionMut:constructor(...)
		super.constructor(self, ...)
	end
	function OptionMut:none()
		return OptionMut.new(nil)
	end
	function OptionMut:some(val)
		return OptionMut.new(val)
	end
	function OptionMut:wrap(val)
		return OptionMut.new(val)
	end
	function OptionMut:toString()
		return self:match(function(val)
			return "OptionMut.some(" .. tostring(val) .. ")"
		end, function()
			return "OptionMut.none"
		end)
	end
	function OptionMut:insert(val)
		self.value = val
		return self.value
	end
	function OptionMut:getOrInsert(val)
		if not self:isSome() then
			self.value = val
			return self.value
		else
			return self.value
		end
	end
	function OptionMut:getOrInsertWith(val)
		if not self:isSome() then
			self.value = val()
			return self.value
		else
			return self.value
		end
	end
	function OptionMut:take()
		local val = self.value
		self.value = nil
		return Option:wrap(val)
	end
	function OptionMut:replace(val)
		local oldVal = self.value
		self.value = val
		return Option:wrap(oldVal)
	end
	function OptionMut:iter()
		return Iterator:fromRawParts(function()
			return self:take()
		end, self:isSome() and fixedSizeHint(1) or fixedSizeHint(0))
	end
	function OptionMut:__tostring()
		return self:toString()
	end
end
local optionMutMeta = OptionMut
optionMutMeta.__unm = function(option)
	return option:map(function(item)
		return -item
	end)
end
optionMutMeta.__add = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item + otherItem
		end)
	end)
end
optionMutMeta.__sub = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item - otherItem
		end)
	end)
end
optionMutMeta.__mul = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item * otherItem
		end)
	end)
end
optionMutMeta.__div = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item / otherItem
		end)
	end)
end
optionMutMeta.__mod = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return item % otherItem
		end)
	end)
end
optionMutMeta.__pow = function(option, other)
	return option:andWith(function(item)
		return other:map(function(otherItem)
			return bit32.bxor(item, otherItem)
		end)
	end)
end
optionMutMeta.__eq = function(a, b)
	return a:asPtr() == b:asPtr()
end
optionMutMeta.__len = function(option)
	return option:map(function(item)
		return #item
	end):unwrapOr(0)
end
return {
	OptionMut = OptionMut,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="274">
                  <Properties>
                    <string name="Name">Result</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local unit = TS.import(script, script.Parent.Parent, "util", "Unit").unit
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local Result
do
	Result = setmetatable({}, {
		__tostring = function()
			return "Result"
		end,
	})
	Result.__index = Result
	function Result.new(...)
		local self = setmetatable({}, Result)
		return self:constructor(...) or self
	end
	function Result:constructor(okValue, errValue)
		self.okValue = okValue
		self.errValue = errValue
	end
	function Result:ok(val)
		return Result.new(val, nil)
	end
	function Result:err(val)
		return Result.new(nil, val)
	end
	function Result:fromCallback(c)
		local success, result = pcall(c)
		return success and Result:ok(result) or Result:err(Option:wrap(result))
	end
	function Result:fromVoidCallback(c)
		local success, result = pcall(c)
		return success and Result:ok(unit()) or Result:err(Option:wrap(result))
	end
	Result.fromPromise = TS.async(function(self, p)
		local _arg0 = function(v)
			return Result:ok(v)
		end
		local _arg1 = function(e)
			return Result:err(Option:wrap(e))
		end
		return p:andThen(_arg0, _arg1)
	end)
	Result.fromVoidPromise = TS.async(function(self, p)
		local _arg0 = function()
			return Result:ok(unit())
		end
		local _arg1 = function(e)
			return Result:err(Option:wrap(e))
		end
		return p:andThen(_arg0, _arg1)
	end)
	function Result:toString()
		return self:match(function(ok)
			return "Result.ok(" .. tostring(ok) .. ")"
		end, function(err)
			return "Result.err(" .. tostring(err) .. ")"
		end)
	end
	function Result:isOk()
		return self.okValue ~= nil
	end
	function Result:isErr()
		return self.errValue ~= nil
	end
	function Result:contains(x)
		return self.okValue == x
	end
	function Result:containsErr(x)
		return self.errValue == x
	end
	function Result:okOption()
		return Option:wrap(self.okValue)
	end
	function Result:errOption()
		return Option:wrap(self.errValue)
	end
	function Result:map(func)
		return self:isOk() and Result:ok(func(self.okValue)) or Result:err(self.errValue)
	end
	function Result:mapOr(def, func)
		local _result
		if self:isOk() then
			_result = func(self.okValue)
		else
			_result = def
		end
		return _result
	end
	function Result:mapOrElse(def, func)
		local _result
		if self:isOk() then
			_result = func(self.okValue)
		else
			_result = def(self.errValue)
		end
		return _result
	end
	function Result:mapErr(func)
		return self:isErr() and Result:err(func(self.errValue)) or Result:ok(self.okValue)
	end
	Result["and"] = function(self, other)
		return self:isErr() and Result:err(self.errValue) or other
	end
	function Result:andWith(func)
		return self:isErr() and Result:err(self.errValue) or func(self.okValue)
	end
	Result["or"] = function(self, other)
		return self:isOk() and Result:ok(self.okValue) or other
	end
	function Result:orElse(other)
		return self:isOk() and Result:ok(self.okValue) or other(self.errValue)
	end
	function Result:expect(msg)
		if self:isOk() then
			return self.okValue
		else
			error(msg)
		end
	end
	function Result:unwrap()
		return self:expect("called \`Result.unwrap()\` on an \`Err\` value: " .. tostring(self.errValue))
	end
	function Result:unwrapOr(def)
		local _result
		if self:isOk() then
			_result = (self.okValue)
		else
			_result = def
		end
		return _result
	end
	function Result:unwrapOrElse(gen)
		local _result
		if self:isOk() then
			_result = (self.okValue)
		else
			_result = gen(self.errValue)
		end
		return _result
	end
	function Result:expectErr(msg)
		if self:isErr() then
			return self.errValue
		else
			error(msg)
		end
	end
	function Result:unwrapErr()
		return self:expectErr("called \`Result.unwrapErr()\` on an \`Ok\` value: " .. tostring(self.okValue))
	end
	function Result:transpose()
		return self:isOk() and self.okValue:map(function(some)
			return Result:ok(some)
		end) or Option:some(Result:err(self.errValue))
	end
	function Result:flatten()
		return self:isOk() and Result.new(self.okValue.okValue, self.okValue.errValue) or Result:err(self.errValue)
	end
	function Result:match(ifOk, ifErr)
		local _result
		if self:isOk() then
			_result = ifOk(self.okValue)
		else
			_result = ifErr(self.errValue)
		end
		return _result
	end
	function Result:asPtr()
		local _condition = (self.okValue)
		if _condition == nil then
			_condition = (self.errValue)
		end
		return _condition
	end
	function Result:__tostring()
		return self:toString()
	end
end
local resultMeta = Result
resultMeta.__eq = function(a, b)
	return b:match(function(ok)
		return a:contains(ok)
	end, function(err)
		return a:containsErr(err)
	end)
end
return {
	Result = Result,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="275">
                  <Properties>
                    <string name="Name">Vec</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent.Parent, "util", "lazyLoad").lazyGet
local resolveRange = TS.import(script, script.Parent.Parent, "util", "Range").resolveRange
local _sizeHint = TS.import(script, script.Parent.Parent, "util", "sizeHint")
local fixedSizeHint = _sizeHint.fixedSizeHint
local upperSizeHint = _sizeHint.upperSizeHint
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
do
	Vec = setmetatable({}, {
		__tostring = function()
			return "Vec"
		end,
	})
	Vec.__index = Vec
	function Vec.new(...)
		local self = setmetatable({}, Vec)
		return self:constructor(...) or self
	end
	function Vec:constructor(array)
		self.array = array
		self.length = #self.array
	end
	function Vec:withCapacity(size)
		return Vec.new(table.create(size))
	end
	function Vec:vec(...)
		local values = { ... }
		return Vec.new(values)
	end
	function Vec:fromPtr(array)
		return Vec.new(array)
	end
	function Vec:toString()
		return "Vec[" .. string.sub(self:iter():fold("", function(acc, item)
			return acc .. tostring(item) .. ", "
		end), 0, -3) .. "]"
	end
	function Vec:i(i)
		local val = self.array[i + 1]
		if val == nil then
			error("called `Vec.i` with an out-of-range index: " .. tostring(i), 2)
		end
		return val
	end
	function Vec:truncate(len)
		if len < 0 then
			error("called `Vec.truncate` with an out-of-range length: " .. tostring(len), 2)
		end
		if len >= self.length then
			return self
		end
		do
			local i = self.length - 1
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i -= 1
				else
					_shouldIncrement = true
				end
				if not (i >= len) then
					break
				end
				self.array[i + 1] = nil
			end
		end
		self.length = len
		return self
	end
	function Vec:asPtr()
		return self.array
	end
	function Vec:setLen(len)
		self.length = len
		return self
	end
	function Vec:swapRemove(i)
		if i < 0 or i >= self.length then
			error("called `Vec.swapRemove` with an out-of-range index: " .. tostring(i), 2)
		end
		self.length -= 1
		-- ▼ Array.unorderedRemove ▼
		local _index = i + 1
		local _exp = self.array
		local _length = #_exp
		local _value = _exp[_index]
		if _value then
			_exp[_index] = _exp[_length]
			_exp[_length] = nil
		end
		-- ▲ Array.unorderedRemove ▲
		return _value
	end
	function Vec:insert(i, element)
		if i < 0 or i > self.length then
			error("called `Vec.insert` with an out-of-range index: " .. tostring(i), 2)
		end
		self.length += 1
		table.insert(self.array, i + 1, element)
		return self
	end
	function Vec:remove(i)
		if i < 0 or i >= self.length then
			error("called `Vec.remove` with an out-of-range index: " .. tostring(i), 2)
		end
		self.length -= 1
		return table.remove(self.array, i + 1)
	end
	function Vec:retain(func)
		local length = self.length
		local deleted = 0
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < length) then
					break
				end
				if not func(self.array[i + 1]) then
					deleted += 1
				elseif deleted > 0 then
					self:swap(i - deleted, i)
				end
			end
		end
		if deleted > 0 then
			self:truncate(length - deleted)
		end
		return self
	end
	function Vec:dedupByKey(func)
		return self:dedupBy(function(a, b)
			return func(a) == func(b)
		end)
	end
	function Vec:dedupBy(isDup)
		if self.length > 1 then
			local nextRead = 1
			local nextWrite = 1
			while nextRead < self.length do
				if not isDup(self.array[nextRead + 1], self.array[nextWrite - 1 + 1]) then
					self:swap(nextRead, nextWrite)
					nextWrite += 1
				end
				nextRead += 1
			end
			self:truncate(nextWrite)
		end
		return self
	end
	function Vec:dedup()
		return self:dedupBy(function(a, b)
			return a == b
		end)
	end
	function Vec:push(element)
		self.length += 1
		local _array = self.array
		-- ▼ Array.push ▼
		_array[#_array + 1] = element
		-- ▲ Array.push ▲
		return self
	end
	function Vec:pop()
		local _fn = Option
		local _exp = self.array
		-- ▼ Array.pop ▼
		local _length = #_exp
		local _result = _exp[_length]
		_exp[_length] = nil
		-- ▲ Array.pop ▲
		return _fn:wrap(_result):map(function(e)
			self.length -= 1
			return e
		end)
	end
	function Vec:append(other)
		for _, element in ipairs(other.array) do
			local _array = self.array
			-- ▼ Array.push ▼
			_array[#_array + 1] = element
			-- ▲ Array.push ▲
		end
		self.length += other:len()
		other:clear()
		return self
	end
	function Vec:drain(r)
		local range = resolveRange(r, self.length)
		if range[1] < 0 or range[1] > range[2] or range[2] > self.length then
			error("called \`Vec.drain\` with an invalid \`Range\`: [" .. tostring(r[1]) .. ", " .. tostring(r[2]) .. "]", 2)
		end
		local size = range[2] - range[1]
		local i = range[1]
		return Iterator:fromRawParts(function()
			local _result
			if i < range[2] then
				local _fn = self
				local _original = i
				i += 1
				_result = _fn:get(_original)
			else
				_result = Option:none()
			end
			return _result
		end, fixedSizeHint(size))
	end
	function Vec:drainFilter(r, filter)
		local range = resolveRange(r, self.length)
		if range[1] < 0 or range[1] > range[2] or range[2] > self.length then
			error("called \`Vec.drainFilter\` with an invalid \`Range\`: [" .. tostring(r[1]) .. ", " .. tostring(r[2]) .. "]", 2)
		end
		local size = range[2] - range[1]
		local i = range[1]
		return Iterator:fromRawParts(function()
			while i < range[2] do
				local _fn = self
				local _original = i
				i += 1
				local element = _fn:get(_original)
				if element:map(filter):contains(true) then
					self:remove(i - 1)
					return element
				end
			end
			return Option:none()
		end, upperSizeHint(size))
	end
	function Vec:clear()
		self.length = 0
		-- ▼ Array.clear ▼
		table.clear(self.array)
		-- ▲ Array.clear ▲
		return self
	end
	function Vec:len()
		return self.length
	end
	function Vec:isEmpty()
		return self.length == 0
	end
	function Vec:splitOff(from)
		if from < 0 or from >= self.length then
			error("called `Vec.splitOff` with an out-of-range index: " .. tostring(from), 2)
		end
		local other
		if from == 0 then
			local _ptr = {}
			local _length = #_ptr
			local _array = self.array
			table.move(_array, 1, #_array, _length + 1, _ptr)
			other = Vec.new(_ptr)
			self:clear()
		else
			other = Vec:withCapacity(self.length - from)
			do
				local i = from
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < self.length) then
						break
					end
					other:push(self.array[i + 1])
				end
			end
			self:truncate(from)
		end
		return other
	end
	function Vec:resizeWith(newLen, func)
		if newLen < self.length then
			self:truncate(newLen)
		elseif newLen > self.length then
			do
				local i = self.length
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < newLen) then
						break
					end
					self:push(func())
				end
			end
		end
		return self
	end
	function Vec:resize(newLen, val)
		if newLen < self.length then
			self:truncate(newLen)
		elseif newLen > self.length then
			do
				local i = self.length
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < newLen) then
						break
					end
					self:push(val)
				end
			end
		end
		return self
	end
	function Vec:splice(r, iter)
		return TS.generator(function()
			local range = resolveRange(r, self.length)
			if range[1] < 0 or range[1] > range[2] or range[2] > self.length then
				error("called \`Vec.splice\` with an invalid \`Range\`: " .. tostring(r[1]) .. ".." .. tostring(r[2]), 2)
			end
			local i = range[1]
			for _result in iter.next do
				if _result.done then
					break
				end
				local item = _result.value
				if i >= range[2] then
					break
				end
				local temp = self.array[i + 1]
				local _exp = self.array
				local _original = i
				i += 1
				_exp[_original + 1] = item
				coroutine.yield(temp)
			end
			while i < range[2] do
				local _array = self.array
				local _i = i
				table.remove(_array, _i + 1)
				range[2] -= 1
			end
		end)
	end
	function Vec:first()
		return Option:wrap(self.array[1])
	end
	function Vec:last()
		return Option:wrap(self.array[self.length - 1 + 1])
	end
	function Vec:get(i)
		return Option:wrap(self.array[i + 1])
	end
	function Vec:swap(a, b)
		if a < 0 or a >= self.length then
			error("called `Vec.swap` with an out-of-range a: " .. tostring(a), 2)
		end
		if b < 0 or b >= self.length then
			error("called `Vec.swap` with an out-of-range b: " .. tostring(b), 2)
		end
		local temp = self.array[a + 1]
		self.array[a + 1] = self.array[b + 1]
		self.array[b + 1] = temp
		return self
	end
	function Vec:reverse()
		local tries = self.length - 1
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < tries / 2) then
					break
				end
				self:swap(i, tries - i)
			end
		end
		return self
	end
	function Vec:generator()
		return TS.generator(function()
			local i = 0
			while i < self.length do
				local _exp = self.array
				local _original = i
				i += 1
				coroutine.yield(_exp[_original + 1])
			end
		end)
	end
	function Vec:iter()
		local i = 0
		return Iterator:fromRawParts(function()
			return self:get(i):map(function(item)
				i += 1
				return item
			end)
		end, fixedSizeHint(self.length))
	end
	function Vec:__tostring()
		return self:toString()
	end
end
return {
	Vec = Vec,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="276">
                <Properties>
                  <string name="Name">util</string>
                </Properties>
                <Item class="ModuleScript" referent="277">
                  <Properties>
                    <string name="Name">Range</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local function resolveRange(r, max)
	local _condition = r[1]
	if _condition == nil then
		_condition = 0
	end
	local _condition_1 = r[2]
	if _condition_1 == nil then
		_condition_1 = max
	end
	return { _condition, _condition_1 }
end
return {
	resolveRange = resolveRange,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="278">
                  <Properties>
                    <string name="Name">Unit</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
-- eslint-disable-next-line @typescript-eslint/no-empty-interface
local unitMeta = {}
unitMeta.__eq = function()
	return true
end
unitMeta.__tostring = function()
	return "()"
end
unitMeta.__index = function()
	return error("Attempt to index Unit", 2)
end
local function unit()
	return setmetatable({}, unitMeta)
end
return {
	unit = unit,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="279">
                  <Properties>
                    <string name="Name">imports</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent, "lazyLoad").lazyGet
local HashMap
lazyGet("HashMap", function(c)
	HashMap = c
end)
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
return nil
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="280">
                  <Properties>
                    <string name="Name">lazyLoad</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local classes = {}
local waiting = {}
local function lazyGet(name, callback)
	local c = classes[name]
	if c then
		callback(c)
	else
		local waiter = waiting[name]
		if waiter then
			local _exp = waiter[1]
			local _arg0 = function(c)
				return callback(c)
			end
			_exp:andThen(_arg0)
		else
			local prom
			prom = TS.Promise.new(function(resolve)
				waiting[name] = { prom, resolve }
			end)
			local waiter = waiting[name]
			waiter[1] = prom
			local _arg0 = function(c)
				return callback(c)
			end
			prom:andThen(_arg0)
		end
	end
end
local function lazyRegister(name, c)
	classes[name] = c
	local waiter = waiting[name]
	if waiter then
		waiter[2](c)
	end
end
return {
	lazyGet = lazyGet,
	lazyRegister = lazyRegister,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="281">
                  <Properties>
                    <string name="Name">sizeHint</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local lazyGet = TS.import(script, script.Parent, "lazyLoad").lazyGet
local HashMap
lazyGet("HashMap", function(c)
	HashMap = c
end)
local Iterator
lazyGet("Iterator", function(c)
	Iterator = c
end)
local Option
lazyGet("Option", function(c)
	Option = c
end)
local Result
lazyGet("Result", function(c)
	Result = c
end)
local Vec
lazyGet("Vec", function(c)
	Vec = c
end)
local function fixedSizeHint(fixed)
	return function()
		return fixed, Option:some(fixed)
	end
end
local function upperSizeHint(upper)
	return function()
		return 0, Option:some(upper)
	end
end
local function lowerSizeHint(lower)
	return function()
		return lower, Option:none()
	end
end
return {
	fixedSizeHint = fixedSizeHint,
	upperSizeHint = upperSizeHint,
	lowerSizeHint = lowerSizeHint,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="282">
            <Properties>
              <string name="Name">services</string>
              <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="283">
            <Properties>
              <string name="Name">signal</string>
              <string name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		Bindable = Instance.new("BindableEvent");
	}, Signal)
end

function Signal:Connect(Callback)
	return self.Bindable.Event:Connect(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Fire(...)
	local Arguments = { ... }
	local n = select("#", ...)

	self.Bindable:Fire(function()
		return table.unpack(Arguments, 1, n)
	end)
end

function Signal:Wait()
	return self.Bindable.Event:Wait()()
end

function Signal:Destroy()
	self.Bindable:Destroy()
end

return Signal
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="284">
            <Properties>
              <string name="Name">t</string>
            </Properties>
            <Item class="Folder" referent="285">
              <Properties>
                <string name="Name">lib</string>
              </Properties>
              <Item class="ModuleScript" referent="286">
                <Properties>
                  <string name="Name">ts</string>
                  <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="287">
            <Properties>
              <string name="Name">testez</string>
            </Properties>
            <Item class="ModuleScript" referent="288">
              <Properties>
                <string name="Name">src</string>
                <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
              </Properties>
              <Item class="ModuleScript" referent="289">
                <Properties>
                  <string name="Name">Context</string>
                  <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="290">
                <Properties>
                  <string name="Name">Expectation</string>
                  <string name="Source">--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (typeof(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is not nil
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) &lt;= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called
]]
function Expectation:throw()
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	local message = formatMessage(self.successCondition,
		"Expected function to throw an error, but it did not.",
		("Expected function to succeed, but it threw an error: %s"):format(
			tostring(err)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="291">
                <Properties>
                  <string name="Name">LifecycleHooks</string>
                  <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="292">
                <Properties>
                  <string name="Name">Reporters</string>
                </Properties>
                <Item class="ModuleScript" referent="293">
                  <Properties>
                    <string name="Name">TeamCityReporter</string>
                    <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="294">
                  <Properties>
                    <string name="Name">TextReporter</string>
                    <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="295">
                  <Properties>
                    <string name="Name">TextReporterQuiet</string>
                    <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="296">
                <Properties>
                  <string name="Name">TestBootstrap</string>
                  <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="297">
                <Properties>
                  <string name="Name">TestEnum</string>
                  <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="298">
                <Properties>
                  <string name="Name">TestPlan</string>
                  <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = Expectation.new

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, debug.traceback)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="299">
                <Properties>
                  <string name="Name">TestPlanner</string>
                  <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="300">
                <Properties>
                  <string name="Name">TestResults</string>
                  <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="301">
                <Properties>
                  <string name="Name">TestRunner</string>
                  <string name="Source">--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local Expectation = require(script.Parent.Expectation)
local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

function TestRunner.environment.expect(...)
	return Expectation.new(...)
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. message .. "\n" .. debug.traceback()
		end

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. message .. "\n" .. debug.traceback()
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		do
			local success, errorMessage = runCallback(childPlanNode.callback)
			if not success then
				return false, errorMessage
			end
		end

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			session:pushNode(childPlanNode)

			if childPlanNode.type == TestEnum.NodeType.It then
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
			end

			session:popNode()
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="302">
                <Properties>
                  <string name="Name">TestSession</string>
                  <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)
	table.insert(self.contextStack, context)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="303">
            <Properties>
              <string name="Name">todo</string>
            </Properties>
            <Item class="ModuleScript" referent="304">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.7
local function todo()
	error("Did not expect " .. (tostring((debug.info(2, "n"))) .. " to run"))
end
return {
	todo = todo,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="305">
            <Properties>
              <string name="Name">types</string>
            </Properties>
            <Item class="Folder" referent="306">
              <Properties>
                <string name="Name">include</string>
              </Properties>
              <Item class="Folder" referent="307">
                <Properties>
                  <string name="Name">generated</string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="308">
            <Properties>
              <string name="Name">validate-tree</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
-- * Defines a Rojo-esque tree type which defines an abstract object tree.
-- * Evaluates a Rojo-esque tree and transforms it into an indexable type.
local function getService(serviceName)
	return game:GetService(serviceName)
end
--[[
	* Returns whether a given Instance matches a particular Rojo-esque InstanceTree.
	* @param object The object which needs validation
	* @param tree The tree to validate
	* @param violators
]]
local function validateTree(object, tree, violators)
	if tree["$className"] ~= nil and not object:IsA(tree["$className"]) then
		return false
	end
	local matches = true
	if object.ClassName == "DataModel" then
		for serviceName, classOrTree in pairs(tree) do
			if serviceName ~= "$className" then
				local result = { pcall(getService, serviceName) }
				if not result[1] then
					if violators then
						matches = false
						local _arg0 = 'game.GetService("' .. serviceName .. '")'
						-- ▼ Array.push ▼
						violators[#violators + 1] = _arg0
						-- ▲ Array.push ▲
					end
					return false
				end
				local _binding = result
				local value = _binding[2]
				if value and (type(classOrTree) == "string" or validateTree(value, classOrTree, violators)) then
					if value.Name ~= serviceName then
						value.Name = serviceName
					end
				else
					if violators then
						matches = false
						local _arg0 = 'game.GetService("' .. serviceName .. '")'
						-- ▼ Array.push ▼
						violators[#violators + 1] = _arg0
						-- ▲ Array.push ▲
					else
						return false
					end
				end
			end
		end
	else
		local whitelistedKeys = {
			["$className"] = true,
		}
		for _, child in ipairs(object:GetChildren()) do
			local childName = child.Name
			if childName ~= "$className" then
				local classOrTree = tree[childName]
				local _result
				if type(classOrTree) == "string" then
					_result = child:IsA(classOrTree)
				else
					_result = classOrTree and validateTree(child, classOrTree, violators)
				end
				if _result then
					-- ▼ Set.add ▼
					whitelistedKeys[childName] = true
					-- ▲ Set.add ▲
				end
			end
		end
		for key in pairs(tree) do
			if not (whitelistedKeys[key] ~= nil) then
				if violators then
					matches = false
					local _arg0 = object:GetFullName() .. "." .. key
					-- ▼ Array.push ▼
					violators[#violators + 1] = _arg0
					-- ▲ Array.push ▲
				else
					return false
				end
			end
		end
	end
	return matches
end
--[[
	* Promises a given tree of objects exists within an object.
	* @param tree Must be an object tree similar to ones considered valid by Rojo.
	* Every tree must have a `$className` member, and can have any number of keys which represent
	* the name of a child instance, which should have a corresponding value which is this same kind of tree.
	* There is also a shorthand syntax available, where setting a key equal to a className is equivalent
	* to an object with `$className` defined. Hence `Things: "Folder"` is equivalent to `Things: { $className: "Folder" }`
]]
local function promiseTree(object, tree)
	if validateTree(object, tree) then
		return TS.Promise.resolve(object)
	end
	local connections = {}
	local warner = TS.Promise.delay(5)
	local _arg0 = function()
		local violators = {}
		if not validateTree(object, tree, violators) then
			-- ▼ ReadonlyArray.join ▼
			local _arg0_1 = ", "
			if _arg0_1 == nil then
				_arg0_1 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			warn("[promiseTree] Infinite wait possible. Waiting for: " .. table.concat(violators, _arg0_1))
		end
	end
	warner:andThen(_arg0)
	local promise = TS.Promise.new(function(resolve)
		local function updateTree(violators)
			if validateTree(object, tree, violators) then
				resolve(object)
			end
		end
		for _, d in ipairs(object:GetDescendants()) do
			local _arg0_1 = d:GetPropertyChangedSignal("Name"):Connect(updateTree)
			-- ▼ Array.push ▼
			connections[#connections + 1] = _arg0_1
			-- ▲ Array.push ▲
		end
		local _arg0_1 = object.DescendantAdded:Connect(function(descendant)
			local _arg0_2 = descendant:GetPropertyChangedSignal("Name"):Connect(updateTree)
			-- ▼ Array.push ▼
			connections[#connections + 1] = _arg0_2
			-- ▲ Array.push ▲
			updateTree()
		end)
		-- ▼ Array.push ▼
		connections[#connections + 1] = _arg0_1
		-- ▲ Array.push ▲
	end)
	promise:finally(function()
		for _, connection in ipairs(connections) do
			connection:Disconnect()
		end
		warner:cancel()
	end)
	return promise
end
return {
	validateTree = validateTree,
	promiseTree = promiseTree,
}
]]></string>
            </Properties>
            <Item class="Folder" referent="309">
              <Properties>
                <string name="Name">node_modules</string>
              </Properties>
              <Item class="Folder" referent="310">
                <Properties>
                  <string name="Name">@rbxts</string>
                </Properties>
                <Item class="Folder" referent="311">
                  <Properties>
                    <string name="Name">compiler-types</string>
                  </Properties>
                  <Item class="Folder" referent="312">
                    <Properties>
                      <string name="Name">types</string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="313">
            <Properties>
              <string name="Name">variant</string>
            </Properties>
            <Item class="ModuleScript" referent="314">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local fields = TS.import(script, script, "fields").fields
local _lookup = TS.import(script, script, "lookup")
local lookup = _lookup.lookup
local partialLookup = _lookup.partialLookup
local match = TS.import(script, script, "match").match
local payload = TS.import(script, script, "payload").payload
local variantFactory = TS.import(script, script, "variantFactory").variantFactory
local _variants = TS.import(script, script, "variants")
local variantModule = _variants.default
local variant = _variants.variant
local cast = TS.import(script, script, "variants", "cast").cast
local _isOfVariant = TS.import(script, script, "variants", "isOfVariant")
local isOfVariant = _isOfVariant.isOfVariant
local outputTypes = _isOfVariant.outputTypes
local keymap = TS.import(script, script, "variants", "keymap").keymap
local keys = TS.import(script, script, "variants", "keys").keys
local narrow = TS.import(script, script, "variants", "narrow").narrow
local variantList = TS.import(script, script, "variants", "variantList").variantList
local default = variantModule
return {
	fields = fields,
	lookup = lookup,
	partialLookup = partialLookup,
	match = match,
	variantFactory = variantFactory,
	variantModule = variantModule,
	variant = variant,
	cast = cast,
	isOfVariant = isOfVariant,
	outputTypes = outputTypes,
	narrow = narrow,
	keys = keys,
	keymap = keymap,
	payload = payload,
	variantList = variantList,
	default = default,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="315">
                <Properties>
                  <string name="Name">ObjectUtils</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local ObjectUtils = {}
do
	local _container = ObjectUtils
	local function keys(value)
		local values = {}
		for key in pairs(value) do
			table.insert(values, key)
		end
		return values
	end
	_container.keys = keys
end
return {
	ObjectUtils = ObjectUtils,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="316">
                <Properties>
                  <string name="Name">fields</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local function fields(defaults)
	if defaults == nil then
		defaults = {}
	end
	return function(input)
		local _object = {}
		for _k, _v in pairs(defaults) do
			_object[_k] = _v
		end
		if type(input) == "table" then
			for _k, _v in pairs(input) do
				_object[_k] = _v
			end
		end
		return _object
	end
end
return {
	fields = fields,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="317">
                <Properties>
                  <string name="Name">identityFunc</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local function identityFunc(x)
	if x == nil then
		x = {}
	end
	return x
end
return {
	identityFunc = identityFunc,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="318">
                <Properties>
                  <string name="Name">lookup</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
--[[
	*
	* An object that has the same keys as a variant but has arbitrary values for the data.
	* a.k.a. a lookup table.
]]
--[[
	*
	* Process an unknown variant by comparing it to a provided lookup table and returning the proper result.
	* @param obj some object that extends `{[K]: string}`.
	* @param handler a lookup table going from the various keys of `obj`'s type to any.
	* @param typeKey the key used as the discriminant.
]]
local function lookup(obj, handler, typeKey)
	local _exp = obj
	local _condition = typeKey
	if _condition == nil then
		_condition = "type"
	end
	local typeString = _exp[_condition]
	return handler[typeString]
end
--[[
	*
	* Process an unknown variant by comparing it to a provided lookup table and returning the proper result.
	* If the handler does not account for the case, returns undefined
	* @param obj some object that extends `{[K]: string}`.
	* @param handler a partial lookup table going from some keys of `obj`'s type to any.
	* @param typeKey the key used as the discriminant.
]]
local function partialLookup(obj, handler, typeKey)
	-- Takes advantage of the fact that handler with missing keys will return undefined.
	return lookup(obj, handler, typeKey)
end
return {
	lookup = lookup,
	partialLookup = partialLookup,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="319">
                <Properties>
                  <string name="Name">match</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
--[[
	*
	* Built to describe an object with the same keys as a variant but instead of constructors
	* for those objects has functions that handle objects of that type.
]]
--[[
	*
	* Either the full handler or the partial set plus 'default'
]]
--[[
	*
	* Pick just the functions of an object.
]]
--[[
	*
	* The key used to indicate the default handler.
]]
local DEFAULT_KEY = "default"
--[[
	*
	* Catch-all type to express type errors.
]]
--[[
	*
	* Prevents 'overflow' in a literal.
	*
	* @todo this may be unnecessary if you use that 'splay partial' trick.
]]
--[[
	*
	* Strip undefined from a union of types.
]]
--[[
	*
	* Match a variant against its possible options and do some processing
	* based on the type of variant received.
	* @param obj the variant in question
	* @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
	* @returns The union of the return types of the various branches of the handler object
]]
--[[
	*
	* Match a variant against its possible options and do some processing
	* based on the type of variant received.
	* @param obj the variant in question
	* @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
	* @param {string?} typeKey override the property to inspect. By default, 'type'.
	* @returns The union of the return types of the various branches of the handler object
]]
--[[
	*
	* Match a variant against it's some of its possible options and do some
	* processing based on the type of variant received. Finally, take the remaining
	* possibilities and handle them in a function.
	*
	* The input to the 'or' clause is well-typed.
	*
	* @param obj the variant in question
	* @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
	* @param {string?} typeKey override the property to inspect. By default, 'type'.
	* @returns {The union of the return types of the various branches of the handler object}
]]
--[[
	*
	* Actual impl
]]
local function match(obj, handler, _elseOrKey, key)
	local typeKey = if type(_elseOrKey) == "string" then _elseOrKey else key
	local _exp = obj
	local _condition = typeKey
	if _condition == nil then
		_condition = "type"
	end
	local typeString = _exp[_condition]
	if handler[typeString] ~= nil then
		local handlerFn = handler[typeString]
		local _result = handlerFn
		if _result ~= nil then
			_result = _result(obj)
		end
		return _result
	else
		if _elseOrKey ~= nil and type(_elseOrKey) == "function" then
			return _elseOrKey(obj)
		else
			if handler.default ~= nil then
				return handler.default(obj)
			end
			return nil
		end
	end
end
--[[
	*
	* Match a literal against some of its possible options and do some processing based
	* on the type of literal received. Works well with strEnum
	* @param literal
	* @param handler
]]
local function matchLiteral(literal, handler)
	local lit = handler[literal]
	local _result = lit
	if _result ~= nil then
		_result = _result(literal)
	end
	return _result
end
-- I'm not sure if this is still necessary but I don't want to mess
-- with the match types until I add more strict tests.
return {
	match = match,
	matchLiteral = matchLiteral,
	DEFAULT_KEY = DEFAULT_KEY,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="320">
                <Properties>
                  <string name="Name">payload</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
--[[
	*
	* Take a single variable of type T and store as 'payload'
]]
local function payload(_example)
	return function(payload)
		return {
			payload = payload,
		}
	end
end
return {
	payload = payload,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="321">
                <Properties>
                  <string name="Name">variantFactory</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local identityFunc = TS.import(script, script.Parent, "identityFunc").identityFunc
local function variantFactory(key)
	--[[
		*
		* Define a case of a variant type.
		* @param tag the name of this case. Also known as the tag, label, or discriminant.
		* @returns a function `() => {type: tag}`.
	]]
	--[[
		*
		* Define a case of a variant type with some body.
		* @param tag the name of this case. Also known as the tag, label, or discriminant.
		* @param func The constructor function for the variant.
		* @returns a function `(...args: Parameters<typeof func>) => {type: tag} & ReturnType<typeof func>`.
	]]
	local function variantFunc(tag, func)
		return setmetatable({
			key = key,
			type = tag,
		}, {
			__call = function(_, ...)
				local args = { ... }
				local returned = (func or identityFunc)(unpack(args))
				local _object = {
					[key] = tag,
				}
				if type(returned) == "table" then
					for _k, _v in pairs(returned) do
						_object[_k] = _v
					end
				end
				return _object
			end,
		})
	end
	return variantFunc
end
return {
	variantFactory = variantFactory,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="322">
                <Properties>
                  <string name="Name">variants</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local identityFunc = TS.import(script, script.Parent, "identityFunc").identityFunc
local ObjectUtils = TS.import(script, script.Parent, "ObjectUtils").ObjectUtils
local variantFactory = TS.import(script, script.Parent, "variantFactory").variantFactory
local variant = variantFactory("type")
local function variantModule(variants)
	local _exp = ObjectUtils.keys(variants)
	local _arg0 = function(acc, key)
		local _object = {}
		for _k, _v in pairs(acc) do
			_object[_k] = _v
		end
		local _left = key
		local _exp_1 = key
		local _arg0_1 = variants[key]
		_object[_left] = variant(_exp_1, if type(_arg0_1) == "function" then (variants[key]) else identityFunc)
		return _object
	end
	-- ▼ ReadonlyArray.reduce ▼
	local _result = {}
	local _callback = _arg0
	for _i = 1, #_exp do
		_result = _callback(_result, _exp[_i], _i - 1, _exp)
	end
	-- ▲ ReadonlyArray.reduce ▲
	return _result
end
return {
	default = variantModule,
	variant = variant,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="323">
                  <Properties>
                    <string name="Name">cast</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
--[[
	*
	* Set a variable's type to a new case of the same variant.
	* @param obj object of concern.
	* @param _type new type tag. Restricted to keys of the variant.
	* @param _typeKey discriminant key.
]]
local function cast(obj, _type, _typeKey)
	return obj
end
return {
	cast = cast,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="324">
                  <Properties>
                    <string name="Name">isOfVariant</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ObjectUtils = TS.import(script, script.Parent.Parent, "ObjectUtils").ObjectUtils
local function outputTypes(variantObject)
	local _exp = ObjectUtils.keys(variantObject)
	local _arg0 = function(key)
		return variantObject[key].type
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#_exp)
	for _k, _v in ipairs(_exp) do
		_newValue[_k] = _arg0(_v, _k - 1, _exp)
	end
	-- ▲ ReadonlyArray.map ▲
	return _newValue
end
local function isOfVariant(instance, variant, typeKey)
	local _condition = instance ~= nil
	if _condition then
		local _exp = outputTypes(variant)
		local _arg0 = function(variantType)
			local _exp_1 = instance
			local _condition_1 = typeKey
			if _condition_1 == nil then
				_condition_1 = "type"
			end
			return variantType == _exp_1[_condition_1]
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in ipairs(_exp) do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		_condition = _result
	end
	return _condition
end
return {
	outputTypes = outputTypes,
	isOfVariant = isOfVariant,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="325">
                  <Properties>
                    <string name="Name">keymap</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ObjectUtils = TS.import(script, script.Parent.Parent, "ObjectUtils").ObjectUtils
--[[
	*
	* A variant module does not *necessarily* have a 1-1 mapping from
	* the key used to refer to the object (Animal.bird) and the key generated
	* by the variant (ANIMAL_BIRD, @animal/bird, etc.).
	* @param v
]]
local function keymap(v)
	local _exp = ObjectUtils.keys(v)
	local _arg0 = function(acc, key)
		local _object = {}
		for _k, _v in pairs(acc) do
			_object[_k] = _v
		end
		_object[key] = v[key].type
		return _object
	end
	-- ▼ ReadonlyArray.reduce ▼
	local _result = {}
	local _callback = _arg0
	for _i = 1, #_exp do
		_result = _callback(_result, _exp[_i], _i - 1, _exp)
	end
	-- ▲ ReadonlyArray.reduce ▲
	return _result
end
return {
	keymap = keymap,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="326">
                  <Properties>
                    <string name="Name">keys</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local outputTypes = TS.import(script, script.Parent, "isOfVariant").outputTypes
--[[
	*
	* Utility function to create a K:V from a list of strings
	*
	* Taken from: https://basarat.gitbook.io/typescript/type-system/literal-types#string-based-enums
	*
]]
local function strEnum(o)
	local _arg0 = function(res, key)
		res[key] = key
		return res
	end
	-- ▼ ReadonlyArray.reduce ▼
	local _result = {}
	local _callback = _arg0
	for _i = 1, #o do
		_result = _callback(_result, o[_i], _i - 1, o)
	end
	-- ▲ ReadonlyArray.reduce ▲
	return _result
end
--[[
	*
	* Return an object cache (`{[P]: P}`) of the keys.
	*
	* An object cache is more useful than an array because you can do
	* constant time checks and you can still reduce to a well-typed
	* array with Object.keys
	* @param variantDef
]]
local function keys(variantDef)
	return strEnum(outputTypes(variantDef))
end
return {
	keys = keys,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="327">
                  <Properties>
                    <string name="Name">narrow</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
--[[
	*
	*
	* @param obj object of concern.
	* @param typeId new type. Restricted to keys of the variant.
	* @param typeKey discriminant key.
]]
local function narrow(obj, typeId, typeKey)
	local _exp = obj
	local _condition = typeKey
	if _condition == nil then
		_condition = "type"
	end
	local typeString = _exp[_condition]
	return if typeString == typeId then obj else nil
end
return {
	narrow = narrow,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="328">
                  <Properties>
                    <string name="Name">variantList</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local variant = TS.import(script, script.Parent).variant
--[[
	*
	* Reduce an object to just elements that are `VariantCreator`s
]]
--[[
	*
	* Convert entries for a `variantList` to the same type.
]]
--[[
	*
	* A valid entry for `variantList`
]]
--[[
	*
	* Create a variant module based on a list of variants.
	*
	* @remarks
	* Best way to create groups of pre-existing variants.
	*
	* @param variants a list of variant creators and `string`s for tags that have no body
]]
local function variantList(variants)
	local _arg0 = function(v)
		if type(v) == "string" then
			return variant(v)
		else
			return v
		end
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#variants)
	for _k, _v in ipairs(variants) do
		_newValue[_k] = _arg0(_v, _k - 1, variants)
	end
	-- ▲ ReadonlyArray.map ▲
	local _arg0_1 = function(o, v)
		local _object = {}
		for _k, _v in pairs(o) do
			_object[_k] = _v
		end
		_object[v.type] = v
		return _object
	end
	-- ▼ ReadonlyArray.reduce ▼
	local _result = {}
	local _callback = _arg0_1
	for _i = 1, #_newValue do
		_result = _callback(_result, _newValue[_i], _i - 1, _newValue)
	end
	-- ▲ ReadonlyArray.reduce ▲
	return _result
end
return {
	variantList = variantList,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="329">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="330">
      <Properties>
        <string name="Name">TS</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local start = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "start").start
local emitEffects = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "emitEffects").emitEffects
local setupTags = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "setupTags").setupTags
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Workspace = _services.Workspace
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Charge = _components.Charge
local Renderable = _components.Renderable
local Target = _components.Target
local promiseR15 = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "promise-character").default
local world = start({ script.systems, ReplicatedStorage.TS.systems }, {})
emitEffects(world)
setupTags(world)
world:spawn(Renderable({
	model = Workspace:FindFirstChild("Lambo"),
}), Charge({
	charge = 100,
}))

local function characterAdded(character)
	promiseR15(character):andThen(function(model)
		world:spawn(Renderable({
			model = model,
		}), Target())
	end)
end
local function playerAdded(player)
	if player.Character then
		characterAdded(player.Character)
	end
	player.CharacterAdded:Connect(characterAdded)
end
Players.PlayerAdded:Connect(playerAdded)
for _, player in Players:GetPlayers() do
	if player == Players.LocalPlayer then
		continue
	end
	playerAdded(player)
end
]]></string>
      </Properties>
      <Item class="ModuleScript" referent="331">
        <Properties>
          <string name="Name">spawner</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local merge = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").merge
local _rust_classes = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "rust-classes", "out")
local HashMap = _rust_classes.HashMap
local Vec = _rust_classes.Vec
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local MAX_MONSTERS = 4
local function get_spawn_table_from_map(map)
	local _fn = Vec
	local _result = Workspace:FindFirstChild(map):FindFirstChild("Spawns")
	if _result ~= nil then
		_result = _result:GetChildren()
	end
	return _fn:fromPtr(_result)
end
local function spawn_region(map, area, spawn_list)
	local spawn_table = get_spawn_table_from_map(map)
	local spawn_points = HashMap:empty()
	local areas = Vec:fromPtr(area)
	merge({}, {})
	do
		local num_spawns = math.min(areas:len(), math.random(1, MAX_MONSTERS + 3))
		if num_spawns == 0 then
			return nil
		end
		for i = 1, num_spawns do
			local array_index = if areas:len() == 1 then 0 else math.random(1, areas:len()) - 1
			local vec3 = Vector3.one
			vec3 = vec3 * 2
			local _vec3 = vec3
			local _one = Vector3.one
			local a, b = _vec3 * _one, Vector3.zero
			a, b = b, a
			local map_idx = areas:i(array_index)
		end
	end
end
return {
	spawn_region = spawn_region,
}
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="332">
        <Properties>
          <string name="Name">systems</string>
        </Properties>
        <Item class="ModuleScript" referent="333">
          <Properties>
            <string name="Name">carsGoVroom</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Charge = _components.Charge
local Renderable = _components.Renderable
local Target = _components.Target
local function carsGoVroom(world, _, ui)
	if ui.checkbox("Disable Physical movers"):checked() == true then
		for _1, renderable in world:query(Renderable, Charge) do
			local model = renderable.model.PrimaryPart
			model.VectorForce.Enabled = false
			model.Torque.Enabled = false
		end
		return nil
	end
	local targets = {}
	for _1, _binding in world:query(Renderable, Target) do
		local model = _binding.model
		local _position = model:GetPivot().Position
		table.insert(targets, _position)
	end
	for _1, _binding, _binding_1 in world:query(Charge, Renderable) do
		local charge = _binding.charge
		local model = _binding_1.model
		if charge <= 0 then
			continue
		end
		local closestPosition, closestDistance = nil, nil
		local currentPosition = model:GetPivot().Position
		for _2, target in targets do
			local distance = (currentPosition - target).Magnitude
			if not closestPosition or distance < closestDistance then
				closestPosition, closestDistance = target, distance
			end
		end
		if closestPosition then
			local body = model.PrimaryPart
			local force = body:GetMass() * 20
			if closestDistance < 4 then
				force = 0
			end
			local lookVector = body.CFrame.LookVector
			local _closestPosition = closestPosition
			local _currentPosition = currentPosition
			local desiredLookVector = (_closestPosition - _currentPosition).Unit
			force = force * lookVector:Dot(desiredLookVector)
			body.VectorForce.Force = Vector3.new(force, 0, 0)
			local absoluteAngle = math.atan2(desiredLookVector.Z, desiredLookVector.X)
			local carAngle = math.atan2(lookVector.Z, lookVector.X)
			local angle = math.deg(absoluteAngle - carAngle)
			angle = angle % 360
			angle = (angle + 360) % 360
			if angle > 180 then
				angle -= 360
			end
			local angularVelocity = body.AssemblyAngularVelocity
			local sign = math.sign(angle)
			local motor = math.sqrt(math.abs(angle)) * sign * -1 * 20
			local friction = angularVelocity.Y * -12
			local torque = body:GetMass() * (motor + friction)
			body.Torque.Torque = Vector3.new(0, torque, 0)
			body.VectorForce.Enabled = true
			body.Torque.Enabled = true
		end
	end
end
return carsGoVroom
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="334">
          <Properties>
            <string name="Name">removingMissingModels</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Renderable = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Renderable
local function removingMissingModels(world)
	for id, _binding in world:query(Renderable) do
		local model = _binding.model
		for _ in useEvent(model, "AncestryChanged") do
			if model:IsDescendantOf(game) == false then
				world:remove(id)
				break
			end
		end
		if not model.PrimaryPart then
			world:remove(id, Renderable)
		end
	end
	for _, modelRecord in world:queryChanged(Renderable) do
		if modelRecord.new == nil then
			if modelRecord.old and modelRecord.old.model then
				modelRecord.old.model:Destroy()
			end
		end
	end
end
return removingMissingModels
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="335">
          <Properties>
            <string name="Name">replication</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local Effect = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Effect
local remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "remotes")
local Renderable = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Renderable
local remoteEvent = remotes.Server:Get("MatterRemote")
local REPLICATED_COMPONENTS = {
	[Effect] = true,
	[Renderable] = true,
}
local function replication(world)
	for _, plr in useEvent(Players, "PlayerAdded") do
		local payload = {}
		for id, entityData in world do
			local entityPayload = {}
			local _arg0 = tostring(id)
			payload[_arg0] = entityPayload
			for component, componentInstance in entityData do
				if REPLICATED_COMPONENTS[component] ~= nil then
					local _arg0_1 = tostring(component)
					local _arg1 = {
						data = componentInstance,
					}
					entityPayload[_arg0_1] = _arg1
				end
			end
		end
		remoteEvent:SendToPlayer(plr, payload)
	end
	local changes = {}
	for component in REPLICATED_COMPONENTS do
		for entityId, record in world:queryChanged(component) do
			local key = tostring(entityId)
			local name = tostring(component)
			if not (changes[key] ~= nil) then
				changes[key] = {}
			end
			if world:contains(entityId) then
				local _result = changes[key]
				if _result ~= nil then
					local _arg1 = {
						data = record.new,
					}
					_result[name] = _arg1
				end
			end
		end
	end
	if (next(changes)) ~= nil then
		remoteEvent:SendToAllPlayers(changes)
	end
end
return {
	system = replication,
	priority = math.huge,
}
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="336">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="337">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="338">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="339">
        <Properties>
          <string name="Name">TS</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local start = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "start").start
local receiveReplication = TS.import(script, script, "receiveReplication").receiveReplication
local player = Players.LocalPlayer
local state = {
	debugEnabled = true,
	character = player.Character or (player.CharacterAdded:Wait()),
	lastInput = nil,
}
local world = start({ script.systems, ReplicatedStorage.TS.systems }, state)
receiveReplication(world)
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="340">
          <Properties>
            <string name="Name">cloneTemplate</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local billboardGui = New("BillboardGui")({
	AlwaysOnTop = true,
	Enabled = true,
	Size = UDim2.new(0, 50, 20, 0),
	[Children] = { New("TextLabel")({
		Size = UDim2.fromScale(1, 1),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(27, 42, 53),
		BorderSizePixel = 1,
		TextStrokeTransparency = 1,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextSize = 15,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
	}) },
})
return function()
	return billboardGui:Clone()
end
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="341">
          <Properties>
            <string name="Name">customClient</string>
          </Properties>
          <Item class="ModuleScript" referent="342">
            <Properties>
              <string name="Name">generateCommand</string>
              <string name="Source">local module = {}
module.client = nil

local UserInputService = game:GetService("UserInputService")

--For access to control vectors
local ControlModule = nil --require(PlayerModule:WaitForChild("ControlModule"))

local function GetControlModule()
    if ControlModule == nil then
        local LocalPlayer = game.Players.LocalPlayer
        local scripts = LocalPlayer:FindFirstChild("PlayerScripts")
        if scripts == nil then
            return nil
        end

        local playerModule = scripts:FindFirstChild("PlayerModule")
        if playerModule == nil then
            return nil
        end

        local controlModule = playerModule:FindFirstChild("ControlModule")
        if controlModule == nil then
            return nil
        end

        ControlModule = require(
            LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("ControlModule")
        )
    end

    return ControlModule
end

function module:Setup(_client)
    self.client = _client
end

function module:Step(_client, _deltaTime) end


function module:GenerateCommand(command, serverTime: number, dt: number)
	
	if (command == nil) then
		command = {}
	end
	
    command.x = 0
    command.y = 0
    command.z = 0
    command.deltaTime = dt
    command.serverTime = serverTime

    GetControlModule()
    if ControlModule ~= nil then
        local moveVector = ControlModule:GetMoveVector() :: Vector3
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit
            command.x = moveVector.X
            command.y = moveVector.Y
            command.z = moveVector.Z
        end
    end
    
    -- This approach isn't ideal but it's the easiest right now
    if not UserInputService:GetFocusedTextBox() then

        local jump = UserInputService:IsKeyDown(Enum.KeyCode.Space)
        local crouch = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
        command.y = 0
        if (jump) then
            command.y = 1
        else
            if (crouch) then
                command.y = -1
            end
        end

        --Fire!
        command.f = UserInputService:IsKeyDown(Enum.KeyCode.Q) and 1 or 0

        --Fly?
        if UserInputService:IsKeyDown(Enum.KeyCode.F8) then
            command.flying = 1
        end

        --Cheat #1 - speed cheat!
        if UserInputService:IsKeyDown(Enum.KeyCode.P) then
            command.deltaTime *= 3
        end

        --Cheat #2 - suspend!
        if UserInputService:IsKeyDown(Enum.KeyCode.L) then
            local function test(f)
                return f
            end
            for j = 1, 2000000 do
                local a = j * 12
                test(a)
            end
        end
    end

    if self:GetIsJumping() == true then
        command.y = 1
    end
    
    --fire angles
     command.fa = self:GetAimPoint()
    

    --Translate the move vector relative to the camera
    local rawMoveVector = self:CalculateRawMoveVector(Vector3.new(command.x, 0, command.z))
    command.x = rawMoveVector.X
    command.z = rawMoveVector.Z

    return command
end

function module:CalculateRawMoveVector(cameraRelativeMoveVector: Vector3)
    local Camera = workspace.CurrentCamera
    local _, yaw = Camera.CFrame:ToEulerAnglesYXZ()
    return CFrame.fromEulerAnglesYXZ(0, yaw, 0) * Vector3.new(cameraRelativeMoveVector.X, 0, cameraRelativeMoveVector.Z)
end

function module:GetIsJumping()
    if ControlModule == nil then
        return false
    end
    if ControlModule.activeController == nil then
        return false
    end

    return ControlModule.activeController:GetIsJumping()
        or (ControlModule.touchJumpController and ControlModule.touchJumpController:GetIsJumping())
end


function module:GetAimPoint()
    local mouse = game.Players.LocalPlayer:GetMouse()
    local ray = game.Workspace.CurrentCamera:ScreenPointToRay(mouse.X, mouse.Y)

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist

    local whiteList = { game.Workspace.Terrain }
    local collisionRoot = self.client:GetCollisionRoot()
    if (collisionRoot) then
        table.insert(whiteList, collisionRoot)
    end
    raycastParams.FilterDescendantsInstances = whiteList

    local raycastResults = game.Workspace:Raycast(ray.Origin, ray.Direction * 2000, raycastParams)
    if raycastResults then
        return raycastResults.Position
    end
    --We hit the sky perhaps?
    return ray.Origin + (ray.Direction * 2000)
end

return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="343">
            <Properties>
              <string name="Name">netgraph</string>
              <string name="Source">local module = {}
module.heldKeys = {}
module.frameCounter = 0
local UserInputService = game:GetService("UserInputService")

function module:Setup(_client)
    self.client = _client
    _client.showFpsGraph = true
    _client.showNetGraph = true
end

function module:Step(_client, _deltaTime)

    self.frameCounter += 1

    local keys = UserInputService:GetKeysPressed()

    local keysThisFrame = {}
    for _,key in pairs(keys) do
        if (self.heldKeys[key.KeyCode] == nil) then
            self.heldKeys[key.KeyCode] = 0
        end
        self.heldKeys[key.KeyCode] += 1
        
        keysThisFrame[key.KeyCode] = 1
    end
    for key,counter in pairs(self.heldKeys) do
        if (keysThisFrame[key] == nil) then
            self.heldKeys[key] = nil
        end
    end
    
    if (self.heldKeys[Enum.KeyCode.F7] == 1) then --first frame!
        _client.showFpsGraph = not _client.showFpsGraph
        _client.showNetGraph = _client.showFpsGraph
    end
end


return module</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="344">
          <Properties>
            <string name="Name">receiveReplication</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "remotes")
local Components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local remoteEvent = remotes.Client:Get("MatterRemote")
local function receiveReplication(world)
	local entityIdMap = {}
	remoteEvent:Connect(function(entities)
		for serverEntityId, componentMap in entities do
			local clientEntityId = entityIdMap[serverEntityId]
			if clientEntityId ~= nil and (next(componentMap)) == nil then
				world:despawn(clientEntityId)
				entityIdMap[serverEntityId] = nil
				continue
			end
			local componentsToInsert = {}
			local componentsToRemove = {}
			local insertNames = {}
			local removeNames = {}
			for name, container in componentMap do
				if container.data then
					local _arg0 = Components[name](container.data)
					table.insert(componentsToInsert, _arg0)
					table.insert(insertNames, name)
				else
					local _arg0 = Components[name]
					table.insert(componentsToRemove, _arg0)
					table.insert(removeNames, name)
				end
			end
			if clientEntityId == nil then
				clientEntityId = world:spawn(unpack(componentsToInsert))
				local _clientEntityId = clientEntityId
				entityIdMap[serverEntityId] = _clientEntityId
			else
				if #componentsToInsert > 0 then
					world:insert(clientEntityId, unpack(componentsToInsert))
				end
				if #componentsToRemove > 0 then
					world:remove(clientEntityId, unpack(componentsToRemove))
				end
			end
		end
	end)
end
return {
	receiveReplication = receiveReplication,
}
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="345">
          <Properties>
            <string name="Name">systems</string>
          </Properties>
          <Item class="ModuleScript" referent="346">
            <Properties>
              <string name="Name">dashInDirection</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local HttpService = _services.HttpService
local Players = _services.Players
local UserInputService = _services.UserInputService
local Effect = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Effect
local EffectVariant = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects").EffectVariant
local DashDirection = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "bin", "dash").DashDirection
local function dashInDirection(world, state)
	for _, _binding, gameProcessedEvent in useEvent(UserInputService, "InputBegan") do
		local KeyCode = _binding.KeyCode
		if gameProcessedEvent then
			continue
		end
		local direction = DashDirection.Forward
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then
			direction = DashDirection.Left
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then
			direction = DashDirection.Back
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then
			direction = DashDirection.Right
		end
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			direction = DashDirection.Forward
		end
		if KeyCode == Enum.KeyCode.Q then
			world:spawn(Effect({
				source = Players.LocalPlayer,
				variant = EffectVariant.Dash(direction),
				predictionGUID = HttpService:GenerateGUID(false),
			}))
		end
		state.lastInput = KeyCode
	end
end
return dashInDirection
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="347">
            <Properties>
              <string name="Name">debugVision</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local DebugAdornment = _components.DebugAdornment
local Renderable = _components.Renderable
local Components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local cloneTemplate = TS.import(script, script.Parent.Parent, "cloneTemplate")
warn("Press ALT + F4 to toggle debug overlay")
local function debugVision(world, state, ui)
	local transparency = ui.slider(1)
	if not state.debugEnabled then
		for id, debugAdornment in world:query(DebugAdornment) do
			debugAdornment.label:Destroy()
			local _result = debugAdornment.highlight
			if _result ~= nil then
				_result:Destroy()
			end
			world:remove(id, DebugAdornment)
		end
		return nil
	end
	for id, _binding in world:query(Renderable) do
		local model = _binding.model
		local debugAdornment = world:get(id, DebugAdornment)
		if not debugAdornment then
			local label = cloneTemplate()
			label.Parent = model
			label.Adornee = model
			local highlight = Instance.new("Highlight")
			highlight.Parent = model
			highlight.Adornee = model
			highlight.FillTransparency = 1
			highlight.FillColor = Color3.fromRGB(255, 255, 255)
			debugAdornment = DebugAdornment({
				label = label,
				highlight = highlight,
			})
			world:insert(id, debugAdornment)
		end
		local text = "Entity: " .. tostring(id)
		text ..= "\n"
		for name, component in pairs(Components) do
			local data = world:get(id, component)
			if data then
				text ..= name .. " {"
				if (next(data)) ~= nil then
					for key, val in pairs(data) do
						text ..= "\n  " .. (key .. (": " .. tostring(val)))
					end
					text ..= "\n"
				end
				text ..= "}\n"
			end
		end
		debugAdornment.label.TextLabel.Text = text
		debugAdornment.label.TextLabel.TextTransparency = transparency
		if debugAdornment.highlight then
			debugAdornment.highlight.OutlineTransparency = transparency
		end
	end
end
return debugVision
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="348">
            <Properties>
              <string name="Name">hitScanEffect</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local HttpService = _services.HttpService
local Workspace = _services.Workspace
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Collision = _components.Collision
local Effect = _components.Effect
local ImpactEffect = _components.ImpactEffect
local Projectile = _components.Projectile
local SplashDamage = _components.SplashDamage
local Transform = _components.Transform
local Velocity = _components.Velocity
local EffectVariant = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects").EffectVariant
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
local function hitScanEffect(world, state, ui)
	for id, _binding, _binding_1, collision, impactEffect, vel in world:query(Projectile, Transform, Collision, ImpactEffect, Velocity) do
		local direction = _binding.direction
		local filter = _binding.filter
		local cf = _binding_1.cf
		raycastParams.FilterDescendantsInstances = filter
		for i = -1, 1 do
			local angle = CFrame.fromEulerAnglesXYZ(0, i * 45, 0)
			local _position = cf.Position
			local _arg0 = collision.size.Z * 2
			local _arg0_1 = direction * _arg0
			local _vector3 = Vector3.new(math.rad(i * 45), 1, math.rad(i * 45))
			local targetPosition = CFrame.new((_position + _arg0_1) * _vector3).Position
			local raycastResult = Workspace:Raycast(cf.Position, targetPosition, raycastParams)
			if state.debugEnabled then
				ui.portal(Workspace, function()
					local _fn = ui
					local _exp = cf.Position
					local _position_1 = cf.Position
					local _arg0_2 = collision.size.Z * 4
					local _arg0_3 = direction * _arg0_2
					local _cFrame = CFrame.new(_position_1 + _arg0_3)
					local _vector3_1 = Vector3.new(math.rad(i * 45), 1, math.rad(i * 45))
					_fn.arrow(_exp, _cFrame * _vector3_1)
				end)
			end
			if raycastResult and raycastResult.Instance then
				local pos = raycastResult.Position
				local target = nil
				local _result = raycastResult.Instance.Parent
				if _result ~= nil then
					_result = _result:FindFirstChild("Humanoid")
				end
				if _result then
					target = raycastResult.Instance.Parent
				end
				local _effects = impactEffect.effects
				local _arg0_2 = function(effect)
					return world:spawn(effect:patch({
						target = target,
						pos = pos,
					}))
				end
				for _k, _v in _effects do
					_arg0_2(_v, _k - 1, _effects)
				end
				local splashEffect = world:get(id, SplashDamage)
				if splashEffect then
					overlapParams.FilterDescendantsInstances = filter
					local spatialQueryResult = Workspace:GetPartBoundsInRadius(pos, splashEffect.radius, overlapParams)
					if (next(spatialQueryResult)) ~= nil then
						local _arg0_3 = function(instance)
							local target = nil
							local _result_1 = instance.Parent
							if _result_1 ~= nil then
								_result_1 = _result_1:FindFirstChild("Humanoid")
							end
							if _result_1 then
								target = instance.Parent
							end
							world:spawn(Effect({
								variant = EffectVariant.Damage(10),
								predictionGUID = HttpService:GenerateGUID(false),
								target = target,
							}))
						end
						for _k, _v in spatialQueryResult do
							_arg0_3(_v, _k - 1, spatialQueryResult)
						end
					end
				end
				world:despawn(id)
				return nil
			end
		end
	end
end
return hitScanEffect
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="349">
            <Properties>
              <string name="Name">projectilesFly</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useDeltaTime = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useDeltaTime
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Projectile = _components.Projectile
local Transform = _components.Transform
local Velocity = _components.Velocity
local function projectilesFly(world, _, ui)
	for id, transform, vel, projectile in world:query(Transform, Velocity, Projectile) do
		local velOffset = vel.speed * useDeltaTime()
		local unitDirection = projectile.direction
		local velocity = unitDirection * velOffset
		local cf = transform.cf + velocity
		transform = transform:patch({
			cf = cf,
		})
		world:insert(id, transform)
	end
end
return projectilesFly
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="350">
            <Properties>
              <string name="Name">removingMissingModels</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Renderable = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Renderable
local function removingMissingModels(world)
	for id, _binding in world:query(Renderable) do
		local model = _binding.model
		for _ in useEvent(model, "AncestryChanged") do
			if model:IsDescendantOf(game) == false then
				world:remove(id)
				break
			end
		end
		if not model.PrimaryPart then
			world:remove(id, Renderable)
		end
	end
	for _, modelRecord in world:queryChanged(Renderable) do
		if modelRecord.new == nil then
			if modelRecord.old and modelRecord.old.model then
				modelRecord.old.model:Destroy()
			end
		end
	end
end
return removingMissingModels
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="351">
            <Properties>
              <string name="Name">renderablesHaveLifetimes</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Lifetime = _components.Lifetime
local Renderable = _components.Renderable
local function renderablesHaveLifetimes(world)
	for id, _binding in world:query(Lifetime, Renderable) do
		local spawnedAt = _binding.spawnedAt
		local length = _binding.length
		if os.clock() - spawnedAt >= length then
			world:despawn(id)
		end
	end
end
return renderablesHaveLifetimes
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="352">
            <Properties>
              <string name="Name">shootProjectiles</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Collision = _components.Collision
local Lifetime = _components.Lifetime
local Projectile = _components.Projectile
local Renderable = _components.Renderable
local Transform = _components.Transform
local Velocity = _components.Velocity
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local function shootProjectiles(world, state, ui)
	for _, _binding, gameProcessedEvent in useEvent(UserInputService, "InputBegan") do
		local KeyCode = _binding.KeyCode
		if gameProcessedEvent then
			continue
		end
		if KeyCode == Enum.KeyCode.F then
			local part = Instance.new("Part")
			part.Anchored = true
			part.CanCollide = false
			local model = Instance.new("Model")
			model.Parent = Workspace
			model.PrimaryPart = part
			local cf = CFrame.new(state.character:GetPivot().Position, mouse.Hit.Position)
			part.CFrame = cf
			part.Parent = model
			local _fn = world
			local _object = {}
			local _left = "direction"
			local _position = mouse.Hit.Position
			local _position_1 = cf.Position
			_object[_left] = (_position - _position_1).Unit
			_object.filter = { player.Character }
			_fn:spawn(Projectile(_object), Renderable({
				model = model,
			}), Transform({
				cf = cf,
			}), Velocity({
				speed = 50,
			}), Collision({
				size = model.PrimaryPart.Size,
			}), Lifetime({
				spawnedAt = os.clock(),
				length = 5,
			}))
		end
	end
end
return shootProjectiles
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="353">
            <Properties>
              <string name="Name">spawnEffects</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useThrottle = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useThrottle
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local Effect = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components").Effect
local replicate_fx_on_client = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "effects", "replicate_fx_on_client").replicate_fx_on_client
local remotes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "remotes")
local remoteEvent = remotes.Client:Get("CreateFx")
local predictionGUIDBuffer = {}
local function spawnEffects(world)
	for id, effect in world:query(Effect) do
		local _predictionGUID = effect.predictionGUID
		if predictionGUIDBuffer[_predictionGUID] ~= nil then
			world:despawn(id)
			continue
		end
		local _predictionGUID_1 = effect.predictionGUID
		predictionGUIDBuffer[_predictionGUID_1] = true
		replicate_fx_on_client(world, effect)
		if effect.source == Players.LocalPlayer then
			remoteEvent:SendToServer(effect)
		end
	end
	if useThrottle(2) then
		table.clear(predictionGUIDBuffer)
	end
end
return spawnEffects
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="354">
            <Properties>
              <string name="Name">updateTransforms</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3-dev-d657049
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "components")
local Renderable = _components.Renderable
local Transform = _components.Transform
local function updateTransforms(world)
	for id, transformRecord in world:queryChanged(Transform) do
		if not world:contains(id) then
			continue
		end
		local renderable = world:get(id, Renderable)
		if not renderable then
			continue
		end
		if transformRecord.new and not transformRecord.new.doNotReconcile then
			renderable.model:PivotTo(transformRecord.new.cf)
		end
	end
end
return updateTransforms
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="355">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
    </Properties>
    <Item class="Part" referent="356">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <bool name="Locked">true</bool>
        <token name="Material">1568</token>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-8</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>2048</X>
          <Y>16</Y>
          <Z>2048</Z>
        </Vector3>
      </Properties>
      <Item class="Texture" referent="357">
        <Properties>
          <string name="Name">texture</string>
          <Color3 name="Color3">
            <R>0.831373</R>
            <G>0.913725</G>
            <B>1</B>
          </Color3>
          <token name="Face">1</token>
          <float name="StudsPerTileU">10</float>
          <float name="StudsPerTileV">10</float>
          <Content name="Texture">
            <url>http://www.roblox.com/asset/?id=7045573215</url>
          </Content>
          <int name="ZIndex">1</int>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="358">
      <Properties>
        <string name="Name">Effects</string>
      </Properties>
    </Item>
  </Item>
</roblox>